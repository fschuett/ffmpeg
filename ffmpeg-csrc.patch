diff -pruN /usr/include/ffmpeg/libavc1394/avc1394.h csrc/libavc1394/avc1394.h
--- /usr/include/ffmpeg/libavc1394/avc1394.h	2013-09-28 02:18:27.000000000 +0200
+++ csrc/libavc1394/avc1394.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,517 +0,0 @@
-/*
- * libavc1394 - GNU/Linux 1394 AV/C Library
- *
- * Originally written by Andreas Micklei <andreas.micklei@ivistar.de>
- * Currently maintained by Dan Dennedy <dan@dennedy.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef AVC1394_H
-#define AVC1394_H 1
-
-
-#include <libraw1394/raw1394.h>
-
-/* AV/C response codes */
-#define AVC1394_RESPONSE_NOT_IMPLEMENTED 0x08000000
-#define AVC1394_RESPONSE_ACCEPTED 0x09000000
-#define AVC1394_RESPONSE_REJECTED 0x0A000000
-#define AVC1394_RESPONSE_IN_TRANSITION 0x0B000000
-#define AVC1394_RESPONSE_IMPLEMENTED 0x0C000000
-#define AVC1394_RESPONSE_STABLE 0x0C000000
-#define AVC1394_RESPONSE_CHANGED 0x0D000000
-#define AVC1394_RESPONSE_INTERIM 0x0F000000
-
-/* variants */
-#define AVC1394_RESP_NOT_IMPLEMENTED 0x08
-#define AVC1394_RESP_ACCEPTED 0x09
-#define AVC1394_RESP_REJECTED 0x0A
-#define AVC1394_RESP_IN_TRANSITION 0x0B
-#define AVC1394_RESP_IMPLEMENTED 0x0C
-#define AVC1394_RESP_STABLE 0x0C
-#define AVC1394_RESP_CHANGED 0x0D
-#define AVC1394_RESP_INTERIM 0x0F
-
-/* AV/C Mask macros */
-#define AVC1394_MASK_START(x) ((x) & 0xF0000000)
-#define AVC1394_MASK_CTYPE(x) ((x) & 0x0F000000)
-#define AVC1394_MASK_RESPONSE(x) ((x) & 0x0F000000)
-#define AVC1394_MASK_SUBUNIT_TYPE(x) ((x) & 0x00F80000)
-#define AVC1394_MASK_SUBUNIT_ID(x) ((x) & 0x00070000)
-#define AVC1394_MASK_OPCODE(x) ((x) & 0x0000FF00)
-#define AVC1394_MASK_OPERAND0(x) ((x) & 0x000000FF)
-#define AVC1394_MASK_OPERAND(x, n) ((x) & (0xFF000000 >> ((((n)-1)%4)*8)))
-#define AVC1394_MASK_RESPONSE_OPERAND(x, n) ((x) & (0xFF000000 >> (((n)%4)*8)))
-
-/* AV/C Mask and shift macros */
-#define AVC1394_GET_CTYPE(x) (((x) & 0x0F000000) >> 24)
-#define AVC1394_GET_RESPONSE(x) (((x) & 0x0F000000) >> 24)
-#define AVC1394_GET_SUBUNIT_TYPE(x) (((x) & 0x00F80000) >> 19)
-#define AVC1394_GET_SUBUNIT_ID(x) (((x) & 0x00070000) >> 16)
-#define AVC1394_GET_OPCODE(x) (((x) & 0x0000FF00) >> 8)
-#define AVC1394_GET_OPERAND0(x) ((x) & 0x000000FF)
-#define AVC1394_GET_OPERAND(x, n) (((x) & (0xFF000000 >> ((((n)-1)%4)*8))) >> ((((n)-1)%4)*8))
-#define AVC1394_GET_RESPONSE_OPERAND(x, n) (((x) & (0xFF000000 >> (((n)%4)*8))) >> (((3-(n))%4)*8))
-
-/* AV/C command types */
-#define AVC1394_CTYPE_CONTROL 0x00000000
-#define AVC1394_CTYPE_STATUS 0x01000000
-#define AVC1394_CTYPE_SPECIFIC_INQUIRY 0x02000000
-#define AVC1394_CTYPE_NOTIFY 0x03000000
-#define AVC1394_CTYPE_GENERAL_INQUIRY 0x04000000
-
-#define AVC1394_CTYP_CONTROL 0
-#define AVC1394_CTYP_STATUS 1
-#define AVC1394_CTYP_SPECIFIC_INQUIRY 2
-#define AVC1394_CTYP_NOTIFY 3
-#define AVC1394_CTYP_GENERAL_INQUIRY 4
-
-/* AV/C subunit types */
-#define AVC1394_SUBUNIT_TYPE_VIDEO_MONITOR (0 <<19)
-#define AVC1394_SUBUNIT_TYPE_AUDIO (1 <<19)
-#define AVC1394_SUBUNIT_TYPE_PRINTER (2 <<19)
-#define AVC1394_SUBUNIT_TYPE_DISC_RECORDER (3 <<19)
-#define AVC1394_SUBUNIT_TYPE_TAPE_RECORDER (4 <<19)
-#define AVC1394_SUBUNIT_TYPE_VCR (4 <<19)
-#define AVC1394_SUBUNIT_TYPE_TUNER (5 <<19)
-#define AVC1394_SUBUNIT_TYPE_CA (6 <<19)
-#define AVC1394_SUBUNIT_TYPE_VIDEO_CAMERA (7 <<19)
-#define AVC1394_SUBUNIT_TYPE_PANEL (9 <<19)
-#define AVC1394_SUBUNIT_TYPE_BULLETIN_BOARD (0xA <<19)
-#define AVC1394_SUBUNIT_TYPE_CAMERA_STORAGE (0xB <<19)
-#define AVC1394_SUBUNIT_TYPE_MUSIC (0xC <<19)
-#define AVC1394_SUBUNIT_TYPE_VENDOR_UNIQUE (0x1C <<19)
-#define AVC1394_SUBUNIT_TYPE_EXTENDED (0x1E <<19)	/* Not implemented */
-#define AVC1394_SUBUNIT_TYPE_UNIT (0x1F <<19)
-
-/* variants */
-#define AVC1394_SUBUNIT_VIDEO_MONITOR 0
-#define AVC1394_SUBUNIT_DISC_RECORDER 3
-#define AVC1394_SUBUNIT_TAPE_RECORDER 4
-#define AVC1394_SUBUNIT_VCR 4
-#define AVC1394_SUBUNIT_TUNER 5
-#define AVC1394_SUBUNIT_VIDEO_CAMERA 7
-#define AVC1394_SUBUNIT_VENDOR_UNIQUE 0x1C
-#define AVC1394_SUBUNIT_EXTENDED 0x1E	/* Not implemented */
-#define AVC1394_SUBUNIT_UNIT 0x1F
-
-/* AV/C subunit IDs */
-#define AVC1394_SUBUNIT_ID_0 (0 << 16)
-#define AVC1394_SUBUNIT_ID_1 (1 << 16)
-#define AVC1394_SUBUNIT_ID_2 (2 << 16)
-#define AVC1394_SUBUNIT_ID_3 (3 << 16)
-#define AVC1394_SUBUNIT_ID_4 (4 << 16)
-#define AVC1394_SUBUNIT_ID_EXTENDED (5 <<16)	/* Not implemented */
-#define AVC1394_SUBUNIT_ID_IGNORE (7 << 16)
-
-/* AV/C subunit capabilities */
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_GENERAL (1<<0)
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_AUDIO (1<<1)
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_MIDI (1<<2)
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_SMPTE (1<<3)
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_SAMPLECOUNT (1<<4)
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_AUDIOSYNC (1<<5)
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_RESERVED (1<<6)
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_MORE (1<<7)
-
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_NONBLOCKING (1<<0)
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_BLOCKING (1<<1)
-
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_AUDIOSYNC_BUS (1<<0)
-#define AVC1394_SUBUNIT_MUSIC_CAPABILITY_AUDIOSYNC_EXTERNAL (1<<0)
-
-/* AV/C Unit commands */
-#define AVC1394_COMMAND_CHANNEL_USAGE 0x00001200
-#define AVC1394_COMMAND_CONNECT 0x00002400
-#define AVC1394_COMMAND_CONNECT_AV 0x00002000
-#define AVC1394_COMMAND_CONNECTIONS 0x00002200
-#define AVC1394_COMMAND_DIGITAL_INPUT 0x00001100
-#define AVC1394_COMMAND_DIGITAL_OUTPUT 0x00001000
-#define AVC1394_COMMAND_DISCONNECT 0x00002500
-#define AVC1394_COMMAND_DISCONNECT_AV 0x00002100
-#define AVC1394_COMMAND_INPUT_PLUG_SIGNAL_FORMAT 0x00001900
-#define AVC1394_COMMAND_OUTPUT_PLUG_SIGNAL_FORMAT 0x00001800
-#define AVC1394_COMMAND_SUBUNIT_INFO 0x00003100
-#define AVC1394_COMMAND_UNIT_INFO 0x00003000
-
-/* variants */
-#define AVC1394_CMD_CHANNEL_USAGE 0x12
-#define AVC1394_CMD_CONNECT 0x24
-#define AVC1394_CMD_CONNECT_AV 0x20
-#define AVC1394_CMD_CONNECTIONS 0x22
-#define AVC1394_CMD_DIGITAL_INPUT 0x11
-#define AVC1394_CMD_DIGITAL_OUTPUT 0x10
-#define AVC1394_CMD_DISCONNECT 0x25
-#define AVC1394_CMD_DISCONNECT_AV 0x21
-#define AVC1394_CMD_INPUT_PLUG_SIGNAL_FORMAT 0x19
-#define AVC1394_CMD_OUTPUT_PLUG_SIGNAL_FORMAT 0x18
-#define AVC1394_CMD_SUBUNIT_INFO 0x31
-#define AVC1394_CMD_UNIT_INFO 0x30
-
-/* AV/C Common unit and subunit commands */
-#define AVC1394_COMMAND_OPEN_DESCRIPTOR 0x00000800
-#define AVC1394_COMMAND_READ_DESCRIPTOR 0x00000900
-#define AVC1394_COMMAND_WRITE_DESCRIPTOR 0x00000A00
-#define AVC1394_COMMAND_SEARCH_DESCRIPTOR 0x00000B00
-#define AVC1394_COMMAND_OBJECT_NUMBER_SELECT 0x00000D00
-#define AVC1394_COMMAND_POWER 0x0000B200
-#define AVC1394_COMMAND_RESERVE 0x00000100
-#define AVC1394_COMMAND_PLUG_INFO 0x00000200
-#define AVC1394_COMMAND_VENDOR_DEPENDENT 0x00000000
-
-/* variants */
-#define AVC1394_CMD_OPEN_DESCRIPTOR 0x08
-#define AVC1394_CMD_READ_DESCRIPTOR 0x09
-#define AVC1394_CMD_WRITE_DESCRIPTOR 0x0A
-#define AVC1394_CMD_SEARCH_DESCRIPTOR 0x0B
-#define AVC1394_CMD_OBJECT_NUMBER_SELECT 0x0D
-#define AVC1394_CMD_POWER 0xB2
-#define AVC1394_CMD_RESERVE 0x01
-#define AVC1394_CMD_PLUG_INFO 0x02
-#define AVC1394_CMD_VENDOR_DEPENDENT 0x00
-
-/* power operands */
-#define AVC1394_CMD_OPERAND_POWER_ON 0x70
-#define AVC1394_CMD_OPERAND_POWER_OFF 0x60
-
-#define AVC1394_OPERAND_UNIT_INFO_EXTENSION_CODE 7
-
-/* AV/C Common unit and subunit command operands */
-#define AVC1394_OPERAND_DESCRIPTOR_TYPE_SUBUNIT_IDENTIFIER_DESCRIPTOR 0x00
-#define AVC1394_OPERAND_DESCRIPTOR_TYPE_OBJECT_LIST_DESCRIPTOR_ID 0x10
-#define AVC1394_OPERAND_DESCRIPTOR_TYPE_OBJECT_LIST_DESCRIPTOR_TYPE 0x11
-#define AVC1394_OPERAND_DESCRIPTOR_TYPE_OBJECT_ENTRY_DESCRIPTOR_POSITION 0x20
-#define AVC1394_OPERAND_DESCRIPTOR_TYPE_OBJECT_ENTRY_DESCRIPTOR_ID 0x21
-#define AVC1394_OPERAND_DESCRIPTOR_SUBFUNCTION_CLOSE 0x00
-#define AVC1394_OPERAND_DESCRIPTOR_SUBFUNCTION_READ_OPEN 0x01
-#define AVC1394_OPERAND_DESCRIPTOR_SUBFUNCTION_WRITE_OPEN 0x03
-
-/* VCR subunit commands (Alphabetically) */
-#define AVC1394_VCR_COMMAND_ANALOG_AUDIO_OUTPUT_MODE 0x000007000
-#define AVC1394_VCR_COMMAND_AREA_MODE 0x000007200
-#define AVC1394_VCR_COMMAND_ABSOLUTE_TRACK_NUMBER 0x000005200
-#define AVC1394_VCR_COMMAND_AUDIO_MODE 0x000007100
-#define AVC1394_VCR_COMMAND_BACKWARD 0x000005600
-#define AVC1394_VCR_COMMAND_BINARY_GROUP 0x000005A00
-#define AVC1394_VCR_COMMAND_EDIT_MODE 0x000004000
-#define AVC1394_VCR_COMMAND_FORWARD 0x000005500
-#define AVC1394_VCR_COMMAND_INPUT_SIGNAL_MODE 0x000007900
-#define AVC1394_VCR_COMMAND_LOAD_MEDIUM 0x00000C100
-#define AVC1394_VCR_COMMAND_MARKER 0x00000CA00
-#define AVC1394_VCR_COMMAND_MEDIUM_INFO 0x00000DA00
-#define AVC1394_VCR_COMMAND_OPEN_MIC 0x000006000
-#define AVC1394_VCR_COMMAND_OUTPUT_SIGNAL_MODE 0x000007800
-#define AVC1394_VCR_COMMAND_PLAY 0x00000C300
-#define AVC1394_VCR_COMMAND_PRESET 0x000004500
-#define AVC1394_VCR_COMMAND_READ_MIC 0x000006100
-#define AVC1394_VCR_COMMAND_RECORD 0x00000C200
-#define AVC1394_VCR_COMMAND_RECORDING_DATE 0x000005300
-#define AVC1394_VCR_COMMAND_RECORDING_SPEED 0x00000DB00
-#define AVC1394_VCR_COMMAND_RECORDING_TIME 0x000005400
-#define AVC1394_VCR_COMMAND_RELATIVE_TIME_COUNTER 0x000005700
-#define AVC1394_VCR_COMMAND_SEARCH_MODE 0x000005000
-#define AVC1394_VCR_COMMAND_SMPTE_EBU_RECORDING_TIME 0x000005C00
-#define AVC1394_VCR_COMMAND_SMPTE_EBU_TIME_CODE 0x000005900
-#define AVC1394_VCR_COMMAND_TAPE_PLAYBACK_FORMAT 0x00000D300
-#define AVC1394_VCR_COMMAND_TAPE_RECORDING_FORMAT 0x00000D200
-#define AVC1394_VCR_COMMAND_TIME_CODE 0x000005100
-#define AVC1394_VCR_COMMAND_TRANSPORT_STATE 0x00000D000
-#define AVC1394_VCR_COMMAND_WIND 0x00000C400
-#define AVC1394_VCR_COMMAND_WRITE_MIC 0x000006200
-
-/* variants */
-#define AVC1394_VCR_CMD_ANALOG_AUDIO_OUTPUT_MODE 0x70
-#define AVC1394_VCR_CMD_AREA_MODE 0x72
-#define AVC1394_VCR_CMD_ABSOLUTE_TRACK_NUMBER 0x52
-#define AVC1394_VCR_CMD_AUDIO_MODE 0x71
-#define AVC1394_VCR_CMD_BACKWARD 0x56
-#define AVC1394_VCR_CMD_BINARY_GROUP 0x5A
-#define AVC1394_VCR_CMD_EDIT_MODE 0x40
-#define AVC1394_VCR_CMD_FORWARD 0x55
-#define AVC1394_VCR_CMD_INPUT_SIGNAL_MODE 0x79
-#define AVC1394_VCR_CMD_LOAD_MEDIUM 0xC1
-#define AVC1394_VCR_CMD_MARKER 0xCA
-#define AVC1394_VCR_CMD_MEDIUM_INFO 0xDA
-#define AVC1394_VCR_CMD_OPEN_MIC 0x60
-#define AVC1394_VCR_CMD_OUTPUT_SIGNAL_MODE 0x78
-#define AVC1394_VCR_CMD_PLAY 0xC3
-#define AVC1394_VCR_CMD_PRESET 0x45
-#define AVC1394_VCR_CMD_READ_MIC 0x61
-#define AVC1394_VCR_CMD_RECORD 0xC2
-#define AVC1394_VCR_CMD_RECORDING_DATE 0x53
-#define AVC1394_VCR_CMD_RECORDING_SPEED 0xDB
-#define AVC1394_VCR_CMD_RECORDING_TIME 0x54
-#define AVC1394_VCR_CMD_RELATIVE_TIME_COUNTER 0x57
-#define AVC1394_VCR_CMD_SEARCH_MODE 0x50
-#define AVC1394_VCR_CMD_SMPTE_EBU_RECORDING_TIME 0x5C
-#define AVC1394_VCR_CMD_SMPTE_EBU_TIME_CODE 0x59
-#define AVC1394_VCR_CMD_TAPE_PLAYBACK_FORMAT 0xD3
-#define AVC1394_VCR_CMD_TAPE_RECORDING_FORMAT 0xD2
-#define AVC1394_VCR_CMD_TIME_CODE 0x51
-#define AVC1394_VCR_CMD_TRANSPORT_STATE 0xD0
-#define AVC1394_VCR_CMD_WIND 0xC4
-#define AVC1394_VCR_CMD_WRITE_MIC 0x62
-
-/* VCR subunit command operands */
-#define AVC1394_VCR_OPERAND_LOAD_MEDIUM_EJECT 0x60
-#define AVC1394_VCR_OPERAND_LOAD_MEDIUM_OPEN_TRAY 0x31
-#define AVC1394_VCR_OPERAND_LOAD_MEDIUM_CLOSE_TRAY 0x32
-#define AVC1394_VCR_OPERAND_PLAY_NEXT_FRAME 0x30
-#define AVC1394_VCR_OPERAND_PLAY_SLOWEST_FORWARD 0x31
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_FORWARD_6 0x32
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_FORWARD_5 0x33
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_FORWARD_4 0x34
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_FORWARD_3 0x35
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_FORWARD_2 0x36
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_FORWARD_1 0x37
-#define AVC1394_VCR_OPERAND_PLAY_X1_FORWARD     0x38
-#define AVC1394_VCR_OPERAND_PLAY_FAST_FORWARD_1 0x39
-#define AVC1394_VCR_OPERAND_PLAY_FAST_FORWARD_2 0x3A
-#define AVC1394_VCR_OPERAND_PLAY_FAST_FORWARD_3 0x3B
-#define AVC1394_VCR_OPERAND_PLAY_FAST_FORWARD_4 0x3C
-#define AVC1394_VCR_OPERAND_PLAY_FAST_FORWARD_5 0x3D
-#define AVC1394_VCR_OPERAND_PLAY_FAST_FORWARD_6 0x3E
-#define AVC1394_VCR_OPERAND_PLAY_FASTEST_FORWARD 0x3F
-#define AVC1394_VCR_OPERAND_PLAY_PREVIOUS_FRAME 0x40
-#define AVC1394_VCR_OPERAND_PLAY_SLOWEST_REVERSE 0x41
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_REVERSE_6 0x42
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_REVERSE_5 0x43
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_REVERSE_4 0x44
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_REVERSE_3 0x45
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_REVERSE_2 0x46
-#define AVC1394_VCR_OPERAND_PLAY_SLOW_REVERSE_1 0x47
-#define AVC1394_VCR_OPERAND_PLAY_X1_REVERSE 0x48
-#define AVC1394_VCR_OPERAND_PLAY_FAST_REVERSE_1 0x49
-#define AVC1394_VCR_OPERAND_PLAY_FAST_REVERSE_2 0x4A
-#define AVC1394_VCR_OPERAND_PLAY_FAST_REVERSE_3 0x4B
-#define AVC1394_VCR_OPERAND_PLAY_FAST_REVERSE_4 0x4C
-#define AVC1394_VCR_OPERAND_PLAY_FAST_REVERSE_5 0x4D
-#define AVC1394_VCR_OPERAND_PLAY_FAST_REVERSE_6 0x4E
-#define AVC1394_VCR_OPERAND_PLAY_FASTEST_REVERSE 0x4F
-#define AVC1394_VCR_OPERAND_PLAY_REVERSE 0x65
-#define AVC1394_VCR_OPERAND_PLAY_REVERSE_PAUSE 0x6D
-#define AVC1394_VCR_OPERAND_PLAY_FORWARD 0x75
-#define AVC1394_VCR_OPERAND_PLAY_FORWARD_PAUSE 0x7D
-
-#define AVC1394_VCR_OPERAND_RECORD_UNSPEC_INSERTED 0x30
-#define AVC1394_VCR_OPERAND_RECORD_AREA_23_INSERTED 0x31
-#define AVC1394_VCR_OPERAND_RECORD_AREA_1_INSERTED 0x32
-#define AVC1394_VCR_OPERAND_RECORD_AREA_123_INSERTED 0x33
-#define AVC1394_VCR_OPERAND_RECORD_UNSPEC_INSERTED_PAUSE 0x40
-#define AVC1394_VCR_OPERAND_RECORD_AREA_23_INSERTED_PAUSE 0x41
-#define AVC1394_VCR_OPERAND_RECORD_AREA_1_INSERTED_PAUSE 0x42
-#define AVC1394_VCR_OPERAND_RECORD_AREA_123_INSERTED_PAUSE 0x43
-#define AVC1394_VCR_OPERAND_RECORD_RECORD 0x75
-#define AVC1394_VCR_OPERAND_RECORD_PAUSE 0x7D
-
-#define AVC1394_VCR_OPERAND_TRANSPORT_STATE 0x7F
-#define AVC1394_VCR_OPERAND_WIND_HIGH_SPEED_REWIND 0x45
-#define AVC1394_VCR_OPERAND_WIND_STOP 0x60
-#define AVC1394_VCR_OPERAND_WIND_REWIND 0x65
-#define AVC1394_VCR_OPERAND_WIND_FAST_FORWARD 0x75
-#define AVC1394_VCR_OPERAND_TIME_CODE_CONTROL 0x20
-#define AVC1394_VCR_OPERAND_TIME_CODE_STATUS 0x71
-#define AVC1394_VCR_OPERAND_RELATIVE_TIME_COUNTER_CONTROL 0x20
-#define AVC1394_VCR_OPERAND_RELATIVE_TIME_COUNTER_STATUS 0x71
-#define AVC1394_VCR_OPERAND_TRANSPORT_STATE 0x7F
-#define AVC1394_VCR_OPERAND_RECORDING_TIME_STATUS 0x71
-
-/* recording speed */
-#define AVC1394_VCR_OPERAND_RECORDING_SPEED_STANDARD 0x6F
-
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_DVCR_STD 0x31
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_DVCR_SMALL 0x32
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_DVCR_MEDIUM 0x33
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_VHS 0x22
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_VHSC 0x23
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_8MM 0x12
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_MICROMV 0x41
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_NONE 0x60
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_UNKNOWN 0x7E
-
-/* tape grade and write protect status */
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_VHS_OK 0x30
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_VHS_WP 0x31
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_SVHS_OK 0x40
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_SVHS_WP 0x41
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_DVHS_OK 0x50
-#define AVC1394_VCR_OPERAND_MEDIUM_INFO_DVHS_WP 0x51
-
-#define AVC1394_VCR_RESPONSE_TRANSPORT_STATE_LOAD_MEDIUM 0x0000C100
-#define AVC1394_VCR_RESPONSE_TRANSPORT_STATE_RECORD 0x0000C200
-#define AVC1394_VCR_RESPONSE_TRANSPORT_STATE_PLAY 0x0000C300
-#define AVC1394_VCR_RESPONSE_TRANSPORT_STATE_WIND 0x0000C400
-
-/* Tuner subunit commands (Alphabetically) */
-#define AVC1394_TUNER_COMMAND_DIRECT_SELECT_INFORMATION_TYPE 0xC8
-#define AVC1394_TUNER_COMMAND_DIRECT_SELECT_DATA 0xCB
-#define AVC1394_TUNER_COMMAND_CA_ENABLE 0xCC
-#define AVC1394_TUNER_COMMAND_AVC1394_TUNER_STATUS 0xCD
-
-/* Tuner subunit commands operands (Alphabetically) */
-#define AVC1394_TUNER_COMMAND_DIRECT_SELECT_INFORMATION_TYPE 0xC8
-#define AVC1394_TUNER_COMMAND_DIRECT_SELECT_DATA 0xCB
-#define AVC1394_TUNER_COMMAND_CA_ENABLE 0xCC
-#define AVC1394_TUNER_COMMAND_AVC1394_TUNER_STATUS 0xCD
-
-/* Panel subunit indirect mode commands and operands */
-#define AVC1394_PANEL_COMMAND_PASS_THROUGH 0x000007C00
-#define AVC1394_PANEL_CMD_PASS_THROUGH 0x7C
-#define AVC1394_PANEL_OPERAND_PRESS 0x00
-#define AVC1394_PANEL_OPERAND_RELEASE 0x80
-
-#define AVC1394_PANEL_OPERATION_SELECT 0x00
-#define AVC1394_PANEL_OPERATION_UP 0x01
-#define AVC1394_PANEL_OPERATION_DOWN 0x02
-#define AVC1394_PANEL_OPERATION_LEFT 0x03
-#define AVC1394_PANEL_OPERATION_RIGHT 0x04
-#define AVC1394_PANEL_OPERATION_RIGHT_UP 0x05
-#define AVC1394_PANEL_OPERATION_RIGHT_DOWN 0x06
-#define AVC1394_PANEL_OPERATION_LEFT_UP 0x07
-#define AVC1394_PANEL_OPERATION_LEFT_DOWN 0x08
-#define AVC1394_PANEL_OPERATION_ROOT_MENU 0x09
-#define AVC1394_PANEL_OPERATION_SETUP_MENU 0x0A
-#define AVC1394_PANEL_OPERATION_CONTENTS_MENU 0x0B
-#define AVC1394_PANEL_OPERATION_FAVORITE_MENU 0x0C
-#define AVC1394_PANEL_OPERATION_EXIT 0x0D
-#define AVC1394_PANEL_OPERATION_0 0x20
-#define AVC1394_PANEL_OPERATION_1 0x21
-#define AVC1394_PANEL_OPERATION_2 0x22
-#define AVC1394_PANEL_OPERATION_3 0x23
-#define AVC1394_PANEL_OPERATION_4 0x24
-#define AVC1394_PANEL_OPERATION_5 0x25
-#define AVC1394_PANEL_OPERATION_6 0x26
-#define AVC1394_PANEL_OPERATION_7 0x27
-#define AVC1394_PANEL_OPERATION_8 0x28
-#define AVC1394_PANEL_OPERATION_9 0x29
-#define AVC1394_PANEL_OPERATION_DOT 0x2A
-#define AVC1394_PANEL_OPERATION_ENTER 0x2B
-#define AVC1394_PANEL_OPERATION_CLEAR 0x2C
-#define AVC1394_PANEL_OPERATION_CHANNEL_UP 0x30
-#define AVC1394_PANEL_OPERATION_CHANNEL_DOWN 0x31
-#define AVC1394_PANEL_OPERATION_PREVIOUS_CHANNEL 0x32
-#define AVC1394_PANEL_OPERATION_SOUND_SELECT 0x33
-#define AVC1394_PANEL_OPERATION_INPUT_SELECT 0x34
-#define AVC1394_PANEL_OPERATION_DISPLAY_INFO 0x35
-#define AVC1394_PANEL_OPERATION_HELP 0x36
-#define AVC1394_PANEL_OPERATION_PAGE_UP 0x37
-#define AVC1394_PANEL_OPERATION_PAGE_DOWN 0x38
-#define AVC1394_PANEL_OPERATION_POWER 0x40
-#define AVC1394_PANEL_OPERATION_VOLUME_UP 0x41
-#define AVC1394_PANEL_OPERATION_VOLUME_DOWN 0x42
-#define AVC1394_PANEL_OPERATION_MUTE 0x43
-#define AVC1394_PANEL_OPERATION_PLAY 0x44
-#define AVC1394_PANEL_OPERATION_STOP 0x45
-#define AVC1394_PANEL_OPERATION_PAUSE 0x46
-#define AVC1394_PANEL_OPERATION_RECORD 0x47
-#define AVC1394_PANEL_OPERATION_REWIND 0x48
-#define AVC1394_PANEL_OPERATION_FASTFORWARD 0x49
-#define AVC1394_PANEL_OPERATION_EJECT 0x4A
-#define AVC1394_PANEL_OPERATION_FORWARD 0x4B
-#define AVC1394_PANEL_OPERATION_BACKWARD 0x49
-#define AVC1394_PANEL_OPERATION_ANGLE 0x50
-#define AVC1394_PANEL_OPERATION_SUBPICTURE 0x51
-
-
-enum avc1394_measurement_unit {
-    AVC1394_VCR_MEASUREMENT_VIDEO_FRAME = 0,
-    AVC1394_VCR_MEASUREMENT_VIDEO_SCENE,
-    AVC1394_VCR_MEASUREMENT_VISS,
-    AVC1394_VCR_MEASUREMENT_GOP,
-    AVC1394_VCR_MEASUREMENT_INDEX,
-    AVC1394_VCR_MEASUREMENT_SKIP,
-    AVC1394_VCR_MEASUREMENT_PHOTO
-};
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int
-avc1394_send_command(raw1394handle_t handle, nodeid_t node, quadlet_t command);
-
-int 
-avc1394_send_command_block(raw1394handle_t handle, nodeid_t node,
-	quadlet_t *command, int command_len);
-
-quadlet_t 
-avc1394_transaction(raw1394handle_t handle, nodeid_t node,
-	quadlet_t quadlet, int retry);
-
-quadlet_t *
-avc1394_transaction_block2(raw1394handle_t handle, nodeid_t node,
-	quadlet_t *request, int len, unsigned int *response_len, int retry);
-
-quadlet_t *
-avc1394_transaction_block(raw1394handle_t handle, nodeid_t node,
-	quadlet_t *request, int len, int retry);
-
-void 
-avc1394_transaction_block_close(raw1394handle_t handle);
-
-int 
-avc1394_open_descriptor(raw1394handle_t handle, nodeid_t node,
-	quadlet_t ctype, quadlet_t subunit,
-	unsigned char *descriptor_identifier, int len_descriptor_identifier,
-	unsigned char readwrite);
-
-int 
-avc1394_close_descriptor(raw1394handle_t handle, nodeid_t node,
-	quadlet_t ctype, quadlet_t subunit,
-	unsigned char *descriptor_identifier, int len_descriptor_identifier);
-
-int
-avc1394_subunit_info(raw1394handle_t handle, nodeid_t node, quadlet_t *table);
-
-/* supply one of the AVC1394_SUBUNIT_TYPE_... to see of node supports that 
-   subunit type. Returns 1 for true, 0 for false. */
-int
-avc1394_check_subunit_type(raw1394handle_t handle, nodeid_t node, int subunit_type);
-
-quadlet_t *
-avc1394_unit_info(raw1394handle_t handle, nodeid_t node);
-
-
-/************************ TARGET STUFF *****************************************/
-
-/* your callback will receive this struct */
-struct avc1394_command_response {
-	byte_t status:4;
-	byte_t reserved:4;
-	byte_t subunit_id:3;
-	byte_t subunit_type:5;
-	byte_t opcode:8;
-	byte_t operand[9];
-};
-typedef struct avc1394_command_response avc1394_cmd_rsp;
-
-/* command callback prototype */
-typedef int (*avc1394_command_handler_t)(struct avc1394_command_response*);
-
-/* set the handler using this function */
-int
-avc1394_init_target( raw1394handle_t handle, avc1394_command_handler_t );
-
-int
-avc1394_close_target( raw1394handle_t handle );
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
diff -pruN /usr/include/ffmpeg/libavc1394/avc1394_vcr.h csrc/libavc1394/avc1394_vcr.h
--- /usr/include/ffmpeg/libavc1394/avc1394_vcr.h	2013-09-28 02:18:27.000000000 +0200
+++ csrc/libavc1394/avc1394_vcr.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,121 +0,0 @@
-/*
- * libavc1394 - GNU/Linux IEEE 1394 AV/C Library
- *
- * Originally written by Andreas Micklei <andreas.micklei@ivistar.de>
- * Currently maintained by Dan Dennedy <dan@dennedy.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef AVC1394_VCR_H
-#define AVC1394_VCR_H 1
-
-#include <libraw1394/raw1394.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* ##### Check to see if device is playing ##### */
-int 
-avc1394_vcr_is_playing(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Check to see if the device is recording ##### */
-int
-avc1394_vcr_is_recording(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device to PLAY FORWARD ##### */
-/* issue twice in a row to play forward at the slowest rate */
-void
-avc1394_vcr_play(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device to PLAY in REVERSE ##### */
-/* issue twice in a row to play in reverse at the slowest rate */
-void
-avc1394_vcr_reverse(raw1394handle_t handle, nodeid_t node);
-
-/* ##### exercise the trick play modes! ##### */
-/* speed is a signed percentage value from -14 to +14 */
-void
-avc1394_vcr_trick_play(raw1394handle_t handle, nodeid_t node, int speed);
-
-/* ##### Tell the device to STOP ##### */
-void
-avc1394_vcr_stop(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device to REWIND ##### */
-void
-avc1394_vcr_rewind(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device to PAUSE ##### */
-void
-avc1394_vcr_pause(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device to FAST FORWARD ##### */
-void 
-avc1394_vcr_forward(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device goto NEXT frame ##### */
-void
-avc1394_vcr_next(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device goto NEXT index point ##### */
-void
-avc1394_vcr_next_index(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device goto PREVIOUS frame ##### */
-void 
-avc1394_vcr_previous(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device goto PREVIOUS index point ##### */
-void 
-avc1394_vcr_previous_index(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device to EJECT (usually not supported) ##### */
-void 
-avc1394_vcr_eject(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Tell the device to RECORD ##### */
-void 
-avc1394_vcr_record(raw1394handle_t handle, nodeid_t node);
-
-/* ##### Ask the device for the status ##### */
-quadlet_t 
-avc1394_vcr_status(raw1394handle_t handle, nodeid_t node);
-
-/* Get a textual description of the status */
-char *
-avc1394_vcr_decode_status(quadlet_t response);
-
-/* Get the time code on tape in format HH:MM:SS:FF */
-/* This version allocates memory for the string, and 
-   the caller is required to free it. */
-char *
-avc1394_vcr_get_timecode(raw1394handle_t handle, nodeid_t node)
-__attribute__ ((deprecated));
-/* This version requires a pre-allocated output string of at least 12 
-   characters. */
-int
-avc1394_vcr_get_timecode2(raw1394handle_t handle, nodeid_t node, char *output);
-
-/* Go to the time code on tape in format HH:MM:SS:FF */
-void
-avc1394_vcr_seek_timecode(raw1394handle_t handle, nodeid_t node, char *timecode);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -pruN /usr/include/ffmpeg/libavc1394/rom1394.h csrc/libavc1394/rom1394.h
--- /usr/include/ffmpeg/libavc1394/rom1394.h	2013-09-28 02:18:27.000000000 +0200
+++ csrc/libavc1394/rom1394.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-/*
- * librom1394 - GNU/Linux IEEE 1394 CSR Config ROM Library
- *
- * Originally written by Andreas Micklei <andreas.micklei@ivistar.de>
- * Better directory and textual leaf processing provided by Stefan Lucke
- * Libtoolize-d and modifications by Dan Dennedy <dan@dennedy.org>
- * ROM manipulation routines by Dan Dennedy
- * Currently maintained by Dan Dennedy
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef ROM1394_H
-#define ROM1394_H
-#include <libraw1394/raw1394.h>
-
-// #define ROM1394_DEBUG 1
-
-/* define standard offsets into config rom address space */
-#define ROM1394_HEADER 0x00
-#define ROM1394_BUS_ID 0x04
-#define ROM1394_BUS_OPTIONS 0x08
-#define ROM1394_GUID_HI 0x0C
-#define ROM1394_GUID_LO 0x10
-#define ROM1394_ROOT_DIRECTORY 0x14
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef enum rom1394_node_types_enum {
-    ROM1394_NODE_TYPE_UNKNOWN,
-    ROM1394_NODE_TYPE_DC,
-    ROM1394_NODE_TYPE_AVC,
-    ROM1394_NODE_TYPE_SBP2,
-    ROM1394_NODE_TYPE_CPU
-} rom1394_node_types;
-
-typedef struct rom1394_bus_options_struct {
-	char		irmc;
-	char		cmc;
-	char		isc;
-	char		bmc;
-	unsigned char	cyc_clk_acc;
-	int		max_rec;
-} rom1394_bus_options;
-
-typedef struct rom1394_directory_struct {
-	quadlet_t	node_capabilities;
-	quadlet_t	vendor_id;
-	quadlet_t	unit_spec_id;
-	quadlet_t	unit_sw_version;
-	quadlet_t	model_id;
-	int         nr_textual_leafs;
-	int         max_textual_leafs;
-	char      **textual_leafs;
-	char       *label;	/* aggregated from textual leaves */
-} rom1394_directory;
-
-int
-rom1394_get_bus_info_block_length(raw1394handle_t handle, nodeid_t node);
-
-quadlet_t
-rom1394_get_bus_id(raw1394handle_t handle, nodeid_t node);
-
-int
-rom1394_get_bus_options(raw1394handle_t handle, nodeid_t node, rom1394_bus_options* bus_options);
-
-octlet_t
-rom1394_get_guid(raw1394handle_t handle, nodeid_t node);
-
-int
-rom1394_get_directory(raw1394handle_t handle, nodeid_t node, rom1394_directory *dir);
-
-rom1394_node_types
-rom1394_get_node_type(rom1394_directory *dir);
-
-void
-rom1394_free_directory(rom1394_directory *dir);
-
-
-/* supply null value to skip update of a particular field */
-
-int
-rom1394_get_size(quadlet_t *buffer);
-
-int
-rom1394_set_directory(quadlet_t *buffer, rom1394_directory *dir);
-
-int
-rom1394_add_unit(quadlet_t *buffer, rom1394_directory *dir);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
-
diff -pruN /usr/include/ffmpeg/libavcodec/avcodec.h csrc/libavcodec/avcodec.h
--- /usr/include/ffmpeg/libavcodec/avcodec.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/avcodec.h	2014-10-20 16:54:53.148780645 +0200
@@ -1,39 +1,10 @@
-/*
- * copyright (c) 2001 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
 
 #ifndef AVCODEC_AVCODEC_H
 #define AVCODEC_AVCODEC_H
 
-/**
- * @file
- * @ingroup libavc
- * Libavcodec external API header
- */
-
-#include <errno.h>
 #include "libavutil/samplefmt.h"
-#include "libavutil/attributes.h"
 #include "libavutil/avutil.h"
 #include "libavutil/buffer.h"
-#include "libavutil/cpu.h"
-#include "libavutil/channel_layout.h"
 #include "libavutil/dict.h"
 #include "libavutil/frame.h"
 #include "libavutil/log.h"
@@ -41,612 +12,13 @@
 #include "libavutil/rational.h"
 
 #include "version.h"
+#include "avcodecid.h"
 
-#if FF_API_FAST_MALLOC
-// to provide fast_*alloc
-#include "libavutil/mem.h"
-#endif
-
-/**
- * @defgroup libavc Encoding/Decoding Library
- * @{
- *
- * @defgroup lavc_decoding Decoding
- * @{
- * @}
- *
- * @defgroup lavc_encoding Encoding
- * @{
- * @}
- *
- * @defgroup lavc_codec Codecs
- * @{
- * @defgroup lavc_codec_native Native Codecs
- * @{
- * @}
- * @defgroup lavc_codec_wrappers External library wrappers
- * @{
- * @}
- * @defgroup lavc_codec_hwaccel Hardware Accelerators bridge
- * @{
- * @}
- * @}
- * @defgroup lavc_internal Internal
- * @{
- * @}
- * @}
- *
- */
-
-/**
- * @defgroup lavc_core Core functions/structures.
- * @ingroup libavc
- *
- * Basic definitions, functions for querying libavcodec capabilities,
- * allocating core structures, etc.
- * @{
- */
-
-
-/**
- * Identify the syntax and semantics of the bitstream.
- * The principle is roughly:
- * Two decoders with the same ID can decode the same streams.
- * Two encoders with the same ID can encode compatible streams.
- * There may be slight deviations from the principle due to implementation
- * details.
- *
- * If you add a codec ID to this list, add it so that
- * 1. no value of a existing codec ID changes (that would break ABI),
- * 2. Give it a value which when taken as ASCII is recognized uniquely by a human as this specific codec.
- *    This ensures that 2 forks can independently add AVCodecIDs without producing conflicts.
- *
- * After adding new codec IDs, do not forget to add an entry to the codec
- * descriptor list and bump libavcodec minor version.
- */
-enum AVCodecID {
-    AV_CODEC_ID_NONE,
-
-    /* video codecs */
-    AV_CODEC_ID_MPEG1VIDEO,
-    AV_CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
-#if FF_API_XVMC
-    AV_CODEC_ID_MPEG2VIDEO_XVMC,
-#endif /* FF_API_XVMC */
-    AV_CODEC_ID_H261,
-    AV_CODEC_ID_H263,
-    AV_CODEC_ID_RV10,
-    AV_CODEC_ID_RV20,
-    AV_CODEC_ID_MJPEG,
-    AV_CODEC_ID_MJPEGB,
-    AV_CODEC_ID_LJPEG,
-    AV_CODEC_ID_SP5X,
-    AV_CODEC_ID_JPEGLS,
-    AV_CODEC_ID_MPEG4,
-    AV_CODEC_ID_RAWVIDEO,
-    AV_CODEC_ID_MSMPEG4V1,
-    AV_CODEC_ID_MSMPEG4V2,
-    AV_CODEC_ID_MSMPEG4V3,
-    AV_CODEC_ID_WMV1,
-    AV_CODEC_ID_WMV2,
-    AV_CODEC_ID_H263P,
-    AV_CODEC_ID_H263I,
-    AV_CODEC_ID_FLV1,
-    AV_CODEC_ID_SVQ1,
-    AV_CODEC_ID_SVQ3,
-    AV_CODEC_ID_DVVIDEO,
-    AV_CODEC_ID_HUFFYUV,
-    AV_CODEC_ID_CYUV,
-    AV_CODEC_ID_H264,
-    AV_CODEC_ID_INDEO3,
-    AV_CODEC_ID_VP3,
-    AV_CODEC_ID_THEORA,
-    AV_CODEC_ID_ASV1,
-    AV_CODEC_ID_ASV2,
-    AV_CODEC_ID_FFV1,
-    AV_CODEC_ID_4XM,
-    AV_CODEC_ID_VCR1,
-    AV_CODEC_ID_CLJR,
-    AV_CODEC_ID_MDEC,
-    AV_CODEC_ID_ROQ,
-    AV_CODEC_ID_INTERPLAY_VIDEO,
-    AV_CODEC_ID_XAN_WC3,
-    AV_CODEC_ID_XAN_WC4,
-    AV_CODEC_ID_RPZA,
-    AV_CODEC_ID_CINEPAK,
-    AV_CODEC_ID_WS_VQA,
-    AV_CODEC_ID_MSRLE,
-    AV_CODEC_ID_MSVIDEO1,
-    AV_CODEC_ID_IDCIN,
-    AV_CODEC_ID_8BPS,
-    AV_CODEC_ID_SMC,
-    AV_CODEC_ID_FLIC,
-    AV_CODEC_ID_TRUEMOTION1,
-    AV_CODEC_ID_VMDVIDEO,
-    AV_CODEC_ID_MSZH,
-    AV_CODEC_ID_ZLIB,
-    AV_CODEC_ID_QTRLE,
-    AV_CODEC_ID_TSCC,
-    AV_CODEC_ID_ULTI,
-    AV_CODEC_ID_QDRAW,
-    AV_CODEC_ID_VIXL,
-    AV_CODEC_ID_QPEG,
-    AV_CODEC_ID_PNG,
-    AV_CODEC_ID_PPM,
-    AV_CODEC_ID_PBM,
-    AV_CODEC_ID_PGM,
-    AV_CODEC_ID_PGMYUV,
-    AV_CODEC_ID_PAM,
-    AV_CODEC_ID_FFVHUFF,
-    AV_CODEC_ID_RV30,
-    AV_CODEC_ID_RV40,
-    AV_CODEC_ID_VC1,
-    AV_CODEC_ID_WMV3,
-    AV_CODEC_ID_LOCO,
-    AV_CODEC_ID_WNV1,
-    AV_CODEC_ID_AASC,
-    AV_CODEC_ID_INDEO2,
-    AV_CODEC_ID_FRAPS,
-    AV_CODEC_ID_TRUEMOTION2,
-    AV_CODEC_ID_BMP,
-    AV_CODEC_ID_CSCD,
-    AV_CODEC_ID_MMVIDEO,
-    AV_CODEC_ID_ZMBV,
-    AV_CODEC_ID_AVS,
-    AV_CODEC_ID_SMACKVIDEO,
-    AV_CODEC_ID_NUV,
-    AV_CODEC_ID_KMVC,
-    AV_CODEC_ID_FLASHSV,
-    AV_CODEC_ID_CAVS,
-    AV_CODEC_ID_JPEG2000,
-    AV_CODEC_ID_VMNC,
-    AV_CODEC_ID_VP5,
-    AV_CODEC_ID_VP6,
-    AV_CODEC_ID_VP6F,
-    AV_CODEC_ID_TARGA,
-    AV_CODEC_ID_DSICINVIDEO,
-    AV_CODEC_ID_TIERTEXSEQVIDEO,
-    AV_CODEC_ID_TIFF,
-    AV_CODEC_ID_GIF,
-    AV_CODEC_ID_DXA,
-    AV_CODEC_ID_DNXHD,
-    AV_CODEC_ID_THP,
-    AV_CODEC_ID_SGI,
-    AV_CODEC_ID_C93,
-    AV_CODEC_ID_BETHSOFTVID,
-    AV_CODEC_ID_PTX,
-    AV_CODEC_ID_TXD,
-    AV_CODEC_ID_VP6A,
-    AV_CODEC_ID_AMV,
-    AV_CODEC_ID_VB,
-    AV_CODEC_ID_PCX,
-    AV_CODEC_ID_SUNRAST,
-    AV_CODEC_ID_INDEO4,
-    AV_CODEC_ID_INDEO5,
-    AV_CODEC_ID_MIMIC,
-    AV_CODEC_ID_RL2,
-    AV_CODEC_ID_ESCAPE124,
-    AV_CODEC_ID_DIRAC,
-    AV_CODEC_ID_BFI,
-    AV_CODEC_ID_CMV,
-    AV_CODEC_ID_MOTIONPIXELS,
-    AV_CODEC_ID_TGV,
-    AV_CODEC_ID_TGQ,
-    AV_CODEC_ID_TQI,
-    AV_CODEC_ID_AURA,
-    AV_CODEC_ID_AURA2,
-    AV_CODEC_ID_V210X,
-    AV_CODEC_ID_TMV,
-    AV_CODEC_ID_V210,
-    AV_CODEC_ID_DPX,
-    AV_CODEC_ID_MAD,
-    AV_CODEC_ID_FRWU,
-    AV_CODEC_ID_FLASHSV2,
-    AV_CODEC_ID_CDGRAPHICS,
-    AV_CODEC_ID_R210,
-    AV_CODEC_ID_ANM,
-    AV_CODEC_ID_BINKVIDEO,
-    AV_CODEC_ID_IFF_ILBM,
-    AV_CODEC_ID_IFF_BYTERUN1,
-    AV_CODEC_ID_KGV1,
-    AV_CODEC_ID_YOP,
-    AV_CODEC_ID_VP8,
-    AV_CODEC_ID_PICTOR,
-    AV_CODEC_ID_ANSI,
-    AV_CODEC_ID_A64_MULTI,
-    AV_CODEC_ID_A64_MULTI5,
-    AV_CODEC_ID_R10K,
-    AV_CODEC_ID_MXPEG,
-    AV_CODEC_ID_LAGARITH,
-    AV_CODEC_ID_PRORES,
-    AV_CODEC_ID_JV,
-    AV_CODEC_ID_DFA,
-    AV_CODEC_ID_WMV3IMAGE,
-    AV_CODEC_ID_VC1IMAGE,
-    AV_CODEC_ID_UTVIDEO,
-    AV_CODEC_ID_BMV_VIDEO,
-    AV_CODEC_ID_VBLE,
-    AV_CODEC_ID_DXTORY,
-    AV_CODEC_ID_V410,
-    AV_CODEC_ID_XWD,
-    AV_CODEC_ID_CDXL,
-    AV_CODEC_ID_XBM,
-    AV_CODEC_ID_ZEROCODEC,
-    AV_CODEC_ID_MSS1,
-    AV_CODEC_ID_MSA1,
-    AV_CODEC_ID_TSCC2,
-    AV_CODEC_ID_MTS2,
-    AV_CODEC_ID_CLLC,
-    AV_CODEC_ID_MSS2,
-    AV_CODEC_ID_VP9,
-    AV_CODEC_ID_AIC,
-    AV_CODEC_ID_ESCAPE130_DEPRECATED,
-    AV_CODEC_ID_G2M_DEPRECATED,
-    AV_CODEC_ID_WEBP_DEPRECATED,
-    AV_CODEC_ID_HNM4_VIDEO,
-    AV_CODEC_ID_HEVC_DEPRECATED,
-    AV_CODEC_ID_FIC,
-    AV_CODEC_ID_ALIAS_PIX,
-    AV_CODEC_ID_BRENDER_PIX_DEPRECATED,
-    AV_CODEC_ID_PAF_VIDEO_DEPRECATED,
-    AV_CODEC_ID_EXR_DEPRECATED,
-    AV_CODEC_ID_VP7_DEPRECATED,
-    AV_CODEC_ID_SANM_DEPRECATED,
-    AV_CODEC_ID_SGIRLE_DEPRECATED,
-    AV_CODEC_ID_MVC1_DEPRECATED,
-    AV_CODEC_ID_MVC2_DEPRECATED,
-
-    AV_CODEC_ID_BRENDER_PIX= MKBETAG('B','P','I','X'),
-    AV_CODEC_ID_Y41P       = MKBETAG('Y','4','1','P'),
-    AV_CODEC_ID_ESCAPE130  = MKBETAG('E','1','3','0'),
-    AV_CODEC_ID_EXR        = MKBETAG('0','E','X','R'),
-    AV_CODEC_ID_AVRP       = MKBETAG('A','V','R','P'),
-
-    AV_CODEC_ID_012V       = MKBETAG('0','1','2','V'),
-    AV_CODEC_ID_G2M        = MKBETAG( 0 ,'G','2','M'),
-    AV_CODEC_ID_AVUI       = MKBETAG('A','V','U','I'),
-    AV_CODEC_ID_AYUV       = MKBETAG('A','Y','U','V'),
-    AV_CODEC_ID_TARGA_Y216 = MKBETAG('T','2','1','6'),
-    AV_CODEC_ID_V308       = MKBETAG('V','3','0','8'),
-    AV_CODEC_ID_V408       = MKBETAG('V','4','0','8'),
-    AV_CODEC_ID_YUV4       = MKBETAG('Y','U','V','4'),
-    AV_CODEC_ID_SANM       = MKBETAG('S','A','N','M'),
-    AV_CODEC_ID_PAF_VIDEO  = MKBETAG('P','A','F','V'),
-    AV_CODEC_ID_AVRN       = MKBETAG('A','V','R','n'),
-    AV_CODEC_ID_CPIA       = MKBETAG('C','P','I','A'),
-    AV_CODEC_ID_XFACE      = MKBETAG('X','F','A','C'),
-    AV_CODEC_ID_SGIRLE     = MKBETAG('S','G','I','R'),
-    AV_CODEC_ID_MVC1       = MKBETAG('M','V','C','1'),
-    AV_CODEC_ID_MVC2       = MKBETAG('M','V','C','2'),
-    AV_CODEC_ID_SNOW       = MKBETAG('S','N','O','W'),
-    AV_CODEC_ID_WEBP       = MKBETAG('W','E','B','P'),
-    AV_CODEC_ID_SMVJPEG    = MKBETAG('S','M','V','J'),
-    AV_CODEC_ID_HEVC       = MKBETAG('H','2','6','5'),
-#define AV_CODEC_ID_H265 AV_CODEC_ID_HEVC
-    AV_CODEC_ID_VP7        = MKBETAG('V','P','7','0'),
-
-    /* various PCM "codecs" */
-    AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
-    AV_CODEC_ID_PCM_S16LE = 0x10000,
-    AV_CODEC_ID_PCM_S16BE,
-    AV_CODEC_ID_PCM_U16LE,
-    AV_CODEC_ID_PCM_U16BE,
-    AV_CODEC_ID_PCM_S8,
-    AV_CODEC_ID_PCM_U8,
-    AV_CODEC_ID_PCM_MULAW,
-    AV_CODEC_ID_PCM_ALAW,
-    AV_CODEC_ID_PCM_S32LE,
-    AV_CODEC_ID_PCM_S32BE,
-    AV_CODEC_ID_PCM_U32LE,
-    AV_CODEC_ID_PCM_U32BE,
-    AV_CODEC_ID_PCM_S24LE,
-    AV_CODEC_ID_PCM_S24BE,
-    AV_CODEC_ID_PCM_U24LE,
-    AV_CODEC_ID_PCM_U24BE,
-    AV_CODEC_ID_PCM_S24DAUD,
-    AV_CODEC_ID_PCM_ZORK,
-    AV_CODEC_ID_PCM_S16LE_PLANAR,
-    AV_CODEC_ID_PCM_DVD,
-    AV_CODEC_ID_PCM_F32BE,
-    AV_CODEC_ID_PCM_F32LE,
-    AV_CODEC_ID_PCM_F64BE,
-    AV_CODEC_ID_PCM_F64LE,
-    AV_CODEC_ID_PCM_BLURAY,
-    AV_CODEC_ID_PCM_LXF,
-    AV_CODEC_ID_S302M,
-    AV_CODEC_ID_PCM_S8_PLANAR,
-    AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED,
-    AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED,
-    AV_CODEC_ID_PCM_S24LE_PLANAR = MKBETAG(24,'P','S','P'),
-    AV_CODEC_ID_PCM_S32LE_PLANAR = MKBETAG(32,'P','S','P'),
-    AV_CODEC_ID_PCM_S16BE_PLANAR = MKBETAG('P','S','P',16),
-
-    /* various ADPCM codecs */
-    AV_CODEC_ID_ADPCM_IMA_QT = 0x11000,
-    AV_CODEC_ID_ADPCM_IMA_WAV,
-    AV_CODEC_ID_ADPCM_IMA_DK3,
-    AV_CODEC_ID_ADPCM_IMA_DK4,
-    AV_CODEC_ID_ADPCM_IMA_WS,
-    AV_CODEC_ID_ADPCM_IMA_SMJPEG,
-    AV_CODEC_ID_ADPCM_MS,
-    AV_CODEC_ID_ADPCM_4XM,
-    AV_CODEC_ID_ADPCM_XA,
-    AV_CODEC_ID_ADPCM_ADX,
-    AV_CODEC_ID_ADPCM_EA,
-    AV_CODEC_ID_ADPCM_G726,
-    AV_CODEC_ID_ADPCM_CT,
-    AV_CODEC_ID_ADPCM_SWF,
-    AV_CODEC_ID_ADPCM_YAMAHA,
-    AV_CODEC_ID_ADPCM_SBPRO_4,
-    AV_CODEC_ID_ADPCM_SBPRO_3,
-    AV_CODEC_ID_ADPCM_SBPRO_2,
-    AV_CODEC_ID_ADPCM_THP,
-    AV_CODEC_ID_ADPCM_IMA_AMV,
-    AV_CODEC_ID_ADPCM_EA_R1,
-    AV_CODEC_ID_ADPCM_EA_R3,
-    AV_CODEC_ID_ADPCM_EA_R2,
-    AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
-    AV_CODEC_ID_ADPCM_IMA_EA_EACS,
-    AV_CODEC_ID_ADPCM_EA_XAS,
-    AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
-    AV_CODEC_ID_ADPCM_IMA_ISS,
-    AV_CODEC_ID_ADPCM_G722,
-    AV_CODEC_ID_ADPCM_IMA_APC,
-    AV_CODEC_ID_ADPCM_VIMA_DEPRECATED,
-    AV_CODEC_ID_ADPCM_VIMA = MKBETAG('V','I','M','A'),
-    AV_CODEC_ID_VIMA       = MKBETAG('V','I','M','A'),
-    AV_CODEC_ID_ADPCM_AFC  = MKBETAG('A','F','C',' '),
-    AV_CODEC_ID_ADPCM_IMA_OKI = MKBETAG('O','K','I',' '),
-    AV_CODEC_ID_ADPCM_DTK  = MKBETAG('D','T','K',' '),
-    AV_CODEC_ID_ADPCM_IMA_RAD = MKBETAG('R','A','D',' '),
-    AV_CODEC_ID_ADPCM_G726LE = MKBETAG('6','2','7','G'),
-
-    /* AMR */
-    AV_CODEC_ID_AMR_NB = 0x12000,
-    AV_CODEC_ID_AMR_WB,
-
-    /* RealAudio codecs*/
-    AV_CODEC_ID_RA_144 = 0x13000,
-    AV_CODEC_ID_RA_288,
-
-    /* various DPCM codecs */
-    AV_CODEC_ID_ROQ_DPCM = 0x14000,
-    AV_CODEC_ID_INTERPLAY_DPCM,
-    AV_CODEC_ID_XAN_DPCM,
-    AV_CODEC_ID_SOL_DPCM,
-
-    /* audio codecs */
-    AV_CODEC_ID_MP2 = 0x15000,
-    AV_CODEC_ID_MP3, ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
-    AV_CODEC_ID_AAC,
-    AV_CODEC_ID_AC3,
-    AV_CODEC_ID_DTS,
-    AV_CODEC_ID_VORBIS,
-    AV_CODEC_ID_DVAUDIO,
-    AV_CODEC_ID_WMAV1,
-    AV_CODEC_ID_WMAV2,
-    AV_CODEC_ID_MACE3,
-    AV_CODEC_ID_MACE6,
-    AV_CODEC_ID_VMDAUDIO,
-    AV_CODEC_ID_FLAC,
-    AV_CODEC_ID_MP3ADU,
-    AV_CODEC_ID_MP3ON4,
-    AV_CODEC_ID_SHORTEN,
-    AV_CODEC_ID_ALAC,
-    AV_CODEC_ID_WESTWOOD_SND1,
-    AV_CODEC_ID_GSM, ///< as in Berlin toast format
-    AV_CODEC_ID_QDM2,
-    AV_CODEC_ID_COOK,
-    AV_CODEC_ID_TRUESPEECH,
-    AV_CODEC_ID_TTA,
-    AV_CODEC_ID_SMACKAUDIO,
-    AV_CODEC_ID_QCELP,
-    AV_CODEC_ID_WAVPACK,
-    AV_CODEC_ID_DSICINAUDIO,
-    AV_CODEC_ID_IMC,
-    AV_CODEC_ID_MUSEPACK7,
-    AV_CODEC_ID_MLP,
-    AV_CODEC_ID_GSM_MS, /* as found in WAV */
-    AV_CODEC_ID_ATRAC3,
-#if FF_API_VOXWARE
-    AV_CODEC_ID_VOXWARE,
-#endif
-    AV_CODEC_ID_APE,
-    AV_CODEC_ID_NELLYMOSER,
-    AV_CODEC_ID_MUSEPACK8,
-    AV_CODEC_ID_SPEEX,
-    AV_CODEC_ID_WMAVOICE,
-    AV_CODEC_ID_WMAPRO,
-    AV_CODEC_ID_WMALOSSLESS,
-    AV_CODEC_ID_ATRAC3P,
-    AV_CODEC_ID_EAC3,
-    AV_CODEC_ID_SIPR,
-    AV_CODEC_ID_MP1,
-    AV_CODEC_ID_TWINVQ,
-    AV_CODEC_ID_TRUEHD,
-    AV_CODEC_ID_MP4ALS,
-    AV_CODEC_ID_ATRAC1,
-    AV_CODEC_ID_BINKAUDIO_RDFT,
-    AV_CODEC_ID_BINKAUDIO_DCT,
-    AV_CODEC_ID_AAC_LATM,
-    AV_CODEC_ID_QDMC,
-    AV_CODEC_ID_CELT,
-    AV_CODEC_ID_G723_1,
-    AV_CODEC_ID_G729,
-    AV_CODEC_ID_8SVX_EXP,
-    AV_CODEC_ID_8SVX_FIB,
-    AV_CODEC_ID_BMV_AUDIO,
-    AV_CODEC_ID_RALF,
-    AV_CODEC_ID_IAC,
-    AV_CODEC_ID_ILBC,
-    AV_CODEC_ID_OPUS_DEPRECATED,
-    AV_CODEC_ID_COMFORT_NOISE,
-    AV_CODEC_ID_TAK_DEPRECATED,
-    AV_CODEC_ID_METASOUND,
-    AV_CODEC_ID_PAF_AUDIO_DEPRECATED,
-    AV_CODEC_ID_ON2AVC,
-    AV_CODEC_ID_FFWAVESYNTH = MKBETAG('F','F','W','S'),
-    AV_CODEC_ID_SONIC       = MKBETAG('S','O','N','C'),
-    AV_CODEC_ID_SONIC_LS    = MKBETAG('S','O','N','L'),
-    AV_CODEC_ID_PAF_AUDIO   = MKBETAG('P','A','F','A'),
-    AV_CODEC_ID_OPUS        = MKBETAG('O','P','U','S'),
-    AV_CODEC_ID_TAK         = MKBETAG('t','B','a','K'),
-    AV_CODEC_ID_EVRC        = MKBETAG('s','e','v','c'),
-    AV_CODEC_ID_SMV         = MKBETAG('s','s','m','v'),
-    AV_CODEC_ID_DSD_LSBF    = MKBETAG('D','S','D','L'),
-    AV_CODEC_ID_DSD_MSBF    = MKBETAG('D','S','D','M'),
-    AV_CODEC_ID_DSD_LSBF_PLANAR = MKBETAG('D','S','D','1'),
-    AV_CODEC_ID_DSD_MSBF_PLANAR = MKBETAG('D','S','D','8'),
-
-    /* subtitle codecs */
-    AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
-    AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
-    AV_CODEC_ID_DVB_SUBTITLE,
-    AV_CODEC_ID_TEXT,  ///< raw UTF-8 text
-    AV_CODEC_ID_XSUB,
-    AV_CODEC_ID_SSA,
-    AV_CODEC_ID_MOV_TEXT,
-    AV_CODEC_ID_HDMV_PGS_SUBTITLE,
-    AV_CODEC_ID_DVB_TELETEXT,
-    AV_CODEC_ID_SRT,
-    AV_CODEC_ID_MICRODVD   = MKBETAG('m','D','V','D'),
-    AV_CODEC_ID_EIA_608    = MKBETAG('c','6','0','8'),
-    AV_CODEC_ID_JACOSUB    = MKBETAG('J','S','U','B'),
-    AV_CODEC_ID_SAMI       = MKBETAG('S','A','M','I'),
-    AV_CODEC_ID_REALTEXT   = MKBETAG('R','T','X','T'),
-    AV_CODEC_ID_SUBVIEWER1 = MKBETAG('S','b','V','1'),
-    AV_CODEC_ID_SUBVIEWER  = MKBETAG('S','u','b','V'),
-    AV_CODEC_ID_SUBRIP     = MKBETAG('S','R','i','p'),
-    AV_CODEC_ID_WEBVTT     = MKBETAG('W','V','T','T'),
-    AV_CODEC_ID_MPL2       = MKBETAG('M','P','L','2'),
-    AV_CODEC_ID_VPLAYER    = MKBETAG('V','P','l','r'),
-    AV_CODEC_ID_PJS        = MKBETAG('P','h','J','S'),
-    AV_CODEC_ID_ASS        = MKBETAG('A','S','S',' '),  ///< ASS as defined in Matroska
-
-    /* other specific kind of codecs (generally used for attachments) */
-    AV_CODEC_ID_FIRST_UNKNOWN = 0x18000,           ///< A dummy ID pointing at the start of various fake codecs.
-    AV_CODEC_ID_TTF = 0x18000,
-    AV_CODEC_ID_BINTEXT    = MKBETAG('B','T','X','T'),
-    AV_CODEC_ID_XBIN       = MKBETAG('X','B','I','N'),
-    AV_CODEC_ID_IDF        = MKBETAG( 0 ,'I','D','F'),
-    AV_CODEC_ID_OTF        = MKBETAG( 0 ,'O','T','F'),
-    AV_CODEC_ID_SMPTE_KLV  = MKBETAG('K','L','V','A'),
-    AV_CODEC_ID_DVD_NAV    = MKBETAG('D','N','A','V'),
-    AV_CODEC_ID_TIMED_ID3  = MKBETAG('T','I','D','3'),
-    AV_CODEC_ID_BIN_DATA   = MKBETAG('D','A','T','A'),
-
-
-    AV_CODEC_ID_PROBE = 0x19000, ///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
-
-    AV_CODEC_ID_MPEG2TS = 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
-                                * stream (only used by libavformat) */
-    AV_CODEC_ID_MPEG4SYSTEMS = 0x20001, /**< _FAKE_ codec to indicate a MPEG-4 Systems
-                                * stream (only used by libavformat) */
-    AV_CODEC_ID_FFMETADATA = 0x21000,   ///< Dummy codec for streams containing only metadata information.
-
-#if FF_API_CODEC_ID
-#include "old_codec_ids.h"
-#endif
-};
-
-/**
- * This struct describes the properties of a single codec described by an
- * AVCodecID.
- * @see avcodec_get_descriptor()
- */
-typedef struct AVCodecDescriptor {
-    enum AVCodecID     id;
-    enum AVMediaType type;
-    /**
-     * Name of the codec described by this descriptor. It is non-empty and
-     * unique for each codec descriptor. It should contain alphanumeric
-     * characters and '_' only.
-     */
-    const char      *name;
-    /**
-     * A more descriptive name for this codec. May be NULL.
-     */
-    const char *long_name;
-    /**
-     * Codec properties, a combination of AV_CODEC_PROP_* flags.
-     */
-    int             props;
-
-    /**
-     * MIME type(s) associated with the codec.
-     * May be NULL; if not, a NULL-terminated array of MIME types.
-     * The first item is always non-NULL and is the preferred MIME type.
-     */
-    const char *const *mime_types;
-} AVCodecDescriptor;
-
-/**
- * Codec uses only intra compression.
- * Video codecs only.
- */
-#define AV_CODEC_PROP_INTRA_ONLY    (1 << 0)
-/**
- * Codec supports lossy compression. Audio and video codecs only.
- * @note a codec may support both lossy and lossless
- * compression modes
- */
-#define AV_CODEC_PROP_LOSSY         (1 << 1)
-/**
- * Codec supports lossless compression. Audio and video codecs only.
- */
-#define AV_CODEC_PROP_LOSSLESS      (1 << 2)
-/**
- * Subtitle codec is bitmap based
- * Decoded AVSubtitle data can be read from the AVSubtitleRect->pict field.
- */
-#define AV_CODEC_PROP_BITMAP_SUB    (1 << 16)
-/**
- * Subtitle codec is text based.
- * Decoded AVSubtitle data can be read from the AVSubtitleRect->ass field.
- */
-#define AV_CODEC_PROP_TEXT_SUB      (1 << 17)
-
-/**
- * @ingroup lavc_decoding
- * Required number of additionally allocated bytes at the end of the input bitstream for decoding.
- * This is mainly needed because some optimized bitstream readers read
- * 32 or 64 bit at once and could read over the end.<br>
- * Note: If the first 23 bits of the additional bytes are not 0, then damaged
- * MPEG bitstreams could cause overread and segfault.
- */
-#define FF_INPUT_BUFFER_PADDING_SIZE 32
-
-/**
- * @ingroup lavc_encoding
- * minimum encoding buffer size
- * Used to avoid some checks during header writing.
- */
-#define FF_MIN_BUFFER_SIZE 16384
-
-
-/**
- * @ingroup lavc_encoding
- * motion estimation type.
- */
-enum Motion_Est_ID {
-    ME_ZERO = 1,    ///< no search, that is use 0,0 vector whenever one is needed
-    ME_FULL,
-    ME_LOG,
-    ME_PHODS,
-    ME_EPZS,        ///< enhanced predictive zonal search
-    ME_X1,          ///< reserved for experiments
-    ME_HEX,         ///< hexagon based search
-    ME_UMH,         ///< uneven multi-hexagon search
-    ME_TESA,        ///< transformed exhaustive search algorithm
-    ME_ITER=50,     ///< iterative search
-};
-
-/**
- * @ingroup lavc_decoding
- */
+ typedef struct AVCodecDescriptor {
+    int dummy;
+ } AVCodecDescriptor;
+ 
 enum AVDiscard{
-    /* We leave some space between them for extensions (drop some
-     * keyframes for intra-only or drop just some bidir frames). */
     AVDISCARD_NONE    =-16, ///< discard nothing
     AVDISCARD_DEFAULT =  0, ///< discard useless packets like 0 size packets in avi
     AVDISCARD_NONREF  =  8, ///< discard all non reference
@@ -669,75 +41,34 @@ enum AVAudioServiceType {
     AV_AUDIO_SERVICE_TYPE_NB                   , ///< Not part of ABI
 };
 
-/**
- * @ingroup lavc_encoding
- */
-typedef struct RcOverride{
-    int start_frame;
-    int end_frame;
-    int qscale; // If this is 0 then quality_factor will be used instead.
-    float quality_factor;
+typedef struct RcOverride {
+    int dummy;
 } RcOverride;
 
-#if FF_API_MAX_BFRAMES
-/**
- * @deprecated there is no libavcodec-wide limit on the number of B-frames
- */
-#define FF_MAX_B_FRAMES 16
-#endif
-
-/* encoding support
-   These flags can be passed in AVCodecContext.flags before initialization.
-   Note: Not everything is supported yet.
-*/
-
-/**
- * Allow decoders to produce frames with data planes that are not aligned
- * to CPU requirements (e.g. due to cropping).
- */
 #define CODEC_FLAG_UNALIGNED 0x0001
 #define CODEC_FLAG_QSCALE 0x0002  ///< Use fixed qscale.
 #define CODEC_FLAG_4MV    0x0004  ///< 4 MV per MB allowed / advanced prediction for H.263.
 #define CODEC_FLAG_OUTPUT_CORRUPT 0x0008 ///< Output even those frames that might be corrupted
 #define CODEC_FLAG_QPEL   0x0010  ///< Use qpel MC.
 #if FF_API_GMC
-/**
- * @deprecated use the "gmc" private option of the libxvid encoder
- */
 #define CODEC_FLAG_GMC    0x0020  ///< Use GMC.
 #endif
 #if FF_API_MV0
-/**
- * @deprecated use the flag "mv0" in the "mpv_flags" private option of the
- * mpegvideo encoders
- */
 #define CODEC_FLAG_MV0    0x0040
 #endif
 #if FF_API_INPUT_PRESERVED
-/**
- * @deprecated passing reference-counted frames to the encoders replaces this
- * flag
- */
 #define CODEC_FLAG_INPUT_PRESERVED 0x0100
 #endif
 #define CODEC_FLAG_PASS1           0x0200   ///< Use internal 2pass ratecontrol in first pass mode.
 #define CODEC_FLAG_PASS2           0x0400   ///< Use internal 2pass ratecontrol in second pass mode.
 #define CODEC_FLAG_GRAY            0x2000   ///< Only decode/encode grayscale.
 #if FF_API_EMU_EDGE
-/**
- * @deprecated edges are not used/required anymore. I.e. this flag is now always
- * set.
- */
 #define CODEC_FLAG_EMU_EDGE        0x4000
 #endif
 #define CODEC_FLAG_PSNR            0x8000   ///< error[?] variables will be set during encoding.
 #define CODEC_FLAG_TRUNCATED       0x00010000 /** Input bitstream might be truncated at a random
                                                   location instead of only at frame boundaries. */
 #if FF_API_NORMALIZE_AQP
-/**
- * @deprecated use the flag "naq" in the "mpv_flags" private option of the
- * mpegvideo encoders
- */
 #define CODEC_FLAG_NORMALIZE_AQP  0x00020000
 #endif
 #define CODEC_FLAG_INTERLACED_DCT 0x00040000 ///< Use interlaced DCT.
@@ -758,124 +89,31 @@ typedef struct RcOverride{
 #define CODEC_FLAG2_CHUNKS        0x00008000 ///< Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
 #define CODEC_FLAG2_SHOW_ALL      0x00400000 ///< Show all frames before the first keyframe
 
-/* Unsupported options :
- *              Syntax Arithmetic coding (SAC)
- *              Reference Picture Selection
- *              Independent Segment Decoding */
-/* /Fx */
-/* codec capabilities */
-
 #define CODEC_CAP_DRAW_HORIZ_BAND 0x0001 ///< Decoder can use draw_horiz_band callback.
-/**
- * Codec uses get_buffer() for allocating buffers and supports custom allocators.
- * If not set, it might not use get_buffer() at all or use operations that
- * assume the buffer was allocated by avcodec_default_get_buffer.
- */
 #define CODEC_CAP_DR1             0x0002
 #define CODEC_CAP_TRUNCATED       0x0008
 #if FF_API_XVMC
-/* Codec can export data for HW decoding. This flag indicates that
- * the codec would call get_format() with list that might contain HW accelerated
- * pixel formats (XvMC, VDPAU, VAAPI, etc). The application can pick any of them
- * including raw image format.
- * The application can use the passed context to determine bitstream version,
- * chroma format, resolution etc.
- */
 #define CODEC_CAP_HWACCEL         0x0010
-#endif /* FF_API_XVMC */
-/**
- * Encoder or decoder requires flushing with NULL input at the end in order to
- * give the complete and correct output.
- *
- * NOTE: If this flag is not set, the codec is guaranteed to never be fed with
- *       with NULL data. The user can still send NULL data to the public encode
- *       or decode function, but libavcodec will not pass it along to the codec
- *       unless this flag is set.
- *
- * Decoders:
- * The decoder has a non-zero delay and needs to be fed with avpkt->data=NULL,
- * avpkt->size=0 at the end to get the delayed data until the decoder no longer
- * returns frames.
- *
- * Encoders:
- * The encoder needs to be fed with NULL data at the end of encoding until the
- * encoder no longer returns data.
- *
- * NOTE: For encoders implementing the AVCodec.encode2() function, setting this
- *       flag also means that the encoder must set the pts and duration for
- *       each output packet. If this flag is not set, the pts and duration will
- *       be determined by libavcodec from the input frame.
- */
+#endif
 #define CODEC_CAP_DELAY           0x0020
-/**
- * Codec can be fed a final frame with a smaller size.
- * This can be used to prevent truncation of the last audio samples.
- */
 #define CODEC_CAP_SMALL_LAST_FRAME 0x0040
 #if FF_API_CAP_VDPAU
-/**
- * Codec can export data for HW decoding (VDPAU).
- */
 #define CODEC_CAP_HWACCEL_VDPAU    0x0080
 #endif
-/**
- * Codec can output multiple frames per AVPacket
- * Normally demuxers return one frame at a time, demuxers which do not do
- * are connected to a parser to split what they return into proper frames.
- * This flag is reserved to the very rare category of codecs which have a
- * bitstream that cannot be split into frames without timeconsuming
- * operations like full decoding. Demuxers carring such bitstreams thus
- * may return multiple frames in a packet. This has many disadvantages like
- * prohibiting stream copy in many cases thus it should only be considered
- * as a last resort.
- */
 #define CODEC_CAP_SUBFRAMES        0x0100
-/**
- * Codec is experimental and is thus avoided in favor of non experimental
- * encoders
- */
 #define CODEC_CAP_EXPERIMENTAL     0x0200
-/**
- * Codec should fill in channel configuration and samplerate instead of container
- */
 #define CODEC_CAP_CHANNEL_CONF     0x0400
 #if FF_API_NEG_LINESIZES
-/**
- * @deprecated no codecs use this capability
- */
 #define CODEC_CAP_NEG_LINESIZES    0x0800
 #endif
-/**
- * Codec supports frame-level multithreading.
- */
 #define CODEC_CAP_FRAME_THREADS    0x1000
-/**
- * Codec supports slice-based (or partition-based) multithreading.
- */
 #define CODEC_CAP_SLICE_THREADS    0x2000
-/**
- * Codec supports changed parameters at any point.
- */
 #define CODEC_CAP_PARAM_CHANGE     0x4000
-/**
- * Codec supports avctx->thread_count == 0 (auto).
- */
 #define CODEC_CAP_AUTO_THREADS     0x8000
-/**
- * Audio encoder supports receiving a different number of samples in each call.
- */
 #define CODEC_CAP_VARIABLE_FRAME_SIZE 0x10000
-/**
- * Codec is intra only.
- */
 #define CODEC_CAP_INTRA_ONLY       0x40000000
-/**
- * Codec is lossless.
- */
 #define CODEC_CAP_LOSSLESS         0x80000000
-
 #if FF_API_MB_TYPE
-//The following defines may change, don't expect compatibility if you use them.
 #define MB_TYPE_INTRA4x4   0x0001
 #define MB_TYPE_INTRA16x16 0x0002 //FIXME H.264-specific
 #define MB_TYPE_INTRA_PCM  0x0004 //FIXME H.264-specific
@@ -897,36 +135,10 @@ typedef struct RcOverride{
 #define MB_TYPE_L0L1       (MB_TYPE_L0   | MB_TYPE_L1)
 #define MB_TYPE_QUANT      0x00010000
 #define MB_TYPE_CBP        0x00020000
-//Note bits 24-31 are reserved for codec specific use (h264 ref0, mpeg1 0mv, ...)
 #endif
 
-/**
- * Pan Scan area.
- * This specifies the area which should be displayed.
- * Note there may be multiple such areas for one frame.
- */
 typedef struct AVPanScan{
-    /**
-     * id
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
-    int id;
-
-    /**
-     * width and height in 1/16 pel
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
-    int width;
-    int height;
-
-    /**
-     * position of the top left corner in 1/16 pel for up to 3 fields/frames
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
-    int16_t position[3][2];
+    int dummy;
 }AVPanScan;
 
 #if FF_API_QSCALE_TYPE
@@ -935,7 +147,6 @@ typedef struct AVPanScan{
 #define FF_QSCALE_TYPE_H264  2
 #define FF_QSCALE_TYPE_VP56  3
 #endif
-
 #if FF_API_GET_BUFFER
 #define FF_BUFFER_TYPE_INTERNAL 1
 #define FF_BUFFER_TYPE_USER     2 ///< direct rendering buffers (image is (de)allocated by user)
@@ -948,136 +159,22 @@ typedef struct AVPanScan{
 #define FF_BUFFER_HINTS_REUSABLE 0x08 // Codec will reuse the buffer (update).
 #endif
 
-/**
- * The decoder will keep a reference to the frame and may reuse it later.
- */
 #define AV_GET_BUFFER_FLAG_REF (1 << 0)
 
-/**
- * @defgroup lavc_packet AVPacket
- *
- * Types and functions for working with AVPacket.
- * @{
- */
 enum AVPacketSideDataType {
     AV_PKT_DATA_PALETTE,
     AV_PKT_DATA_NEW_EXTRADATA,
-
-    /**
-     * An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:
-     * @code
-     * u32le param_flags
-     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)
-     *     s32le channel_count
-     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)
-     *     u64le channel_layout
-     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
-     *     s32le sample_rate
-     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
-     *     s32le width
-     *     s32le height
-     * @endcode
-     */
     AV_PKT_DATA_PARAM_CHANGE,
-
-    /**
-     * An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of
-     * structures with info about macroblocks relevant to splitting the
-     * packet into smaller packets on macroblock edges (e.g. as for RFC 2190).
-     * That is, it does not necessarily contain info about all macroblocks,
-     * as long as the distance between macroblocks in the info is smaller
-     * than the target payload size.
-     * Each MB info structure is 12 bytes, and is laid out as follows:
-     * @code
-     * u32le bit offset from the start of the packet
-     * u8    current quantizer at the start of the macroblock
-     * u8    GOB number
-     * u16le macroblock address within the GOB
-     * u8    horizontal MV predictor
-     * u8    vertical MV predictor
-     * u8    horizontal MV predictor for block number 3
-     * u8    vertical MV predictor for block number 3
-     * @endcode
-     */
     AV_PKT_DATA_H263_MB_INFO,
-
-    /**
-     * This side data should be associated with an audio stream and contains
-     * ReplayGain information in form of the AVReplayGain struct.
-     */
     AV_PKT_DATA_REPLAYGAIN,
-
-    /**
-     * This side data contains a 3x3 transformation matrix describing an affine
-     * transformation that needs to be applied to the decoded video frames for
-     * correct presentation.
-     *
-     * See libavutil/display.h for a detailed description of the data.
-     */
     AV_PKT_DATA_DISPLAYMATRIX,
-
-    /**
-     * Recommmends skipping the specified number of samples
-     * @code
-     * u32le number of samples to skip from start of this packet
-     * u32le number of samples to skip from end of this packet
-     * u8    reason for start skip
-     * u8    reason for end   skip (0=padding silence, 1=convergence)
-     * @endcode
-     */
     AV_PKT_DATA_SKIP_SAMPLES=70,
-
-    /**
-     * An AV_PKT_DATA_JP_DUALMONO side data packet indicates that
-     * the packet may contain "dual mono" audio specific to Japanese DTV
-     * and if it is true, recommends only the selected channel to be used.
-     * @code
-     * u8    selected channels (0=mail/left, 1=sub/right, 2=both)
-     * @endcode
-     */
     AV_PKT_DATA_JP_DUALMONO,
-
-    /**
-     * A list of zero terminated key/value strings. There is no end marker for
-     * the list, so it is required to rely on the side data size to stop.
-     */
     AV_PKT_DATA_STRINGS_METADATA,
-
-    /**
-     * Subtitle event position
-     * @code
-     * u32le x1
-     * u32le y1
-     * u32le x2
-     * u32le y2
-     * @endcode
-     */
     AV_PKT_DATA_SUBTITLE_POSITION,
-
-    /**
-     * Data found in BlockAdditional element of matroska container. There is
-     * no end marker for the data, so it is required to rely on the side data
-     * size to recognize the end. 8 byte id (as found in BlockAddId) followed
-     * by data.
-     */
     AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,
-
-    /**
-     * The optional first identifier line of a WebVTT cue.
-     */
     AV_PKT_DATA_WEBVTT_IDENTIFIER,
-
-    /**
-     * The optional settings (rendering instructions) that immediately
-     * follow the timestamp specifier of a WebVTT cue.
-     */
     AV_PKT_DATA_WEBVTT_SETTINGS,
-
-    /**
-     * A list of zero terminated key/value strings. There is no end marker for
-     * the list, so it is required to rely on the side data size to stop. This
-     * side data includes updated metadata which appeared in the stream.
-     */
     AV_PKT_DATA_METADATA_UPDATE,
 };
 
@@ -1087,111 +184,31 @@ typedef struct AVPacketSideData {
     enum AVPacketSideDataType type;
 } AVPacketSideData;
 
-/**
- * This structure stores compressed data. It is typically exported by demuxers
- * and then passed as input to decoders, or received as output from encoders and
- * then passed to muxers.
- *
- * For video, it should typically contain one compressed frame. For audio it may
- * contain several compressed frames.
- *
- * AVPacket is one of the few structs in FFmpeg, whose size is a part of public
- * ABI. Thus it may be allocated on stack and no new fields can be added to it
- * without libavcodec and libavformat major bump.
- *
- * The semantics of data ownership depends on the buf or destruct (deprecated)
- * fields. If either is set, the packet data is dynamically allocated and is
- * valid indefinitely until av_free_packet() is called (which in turn calls
- * av_buffer_unref()/the destruct callback to free the data). If neither is set,
- * the packet data is typically backed by some static buffer somewhere and is
- * only valid for a limited time (e.g. until the next read call when demuxing).
- *
- * The side data is always allocated with av_malloc() and is freed in
- * av_free_packet().
- */
 typedef struct AVPacket {
-    /**
-     * A reference to the reference-counted buffer where the packet data is
-     * stored.
-     * May be NULL, then the packet data is not reference-counted.
-     */
     AVBufferRef *buf;
-    /**
-     * Presentation timestamp in AVStream->time_base units; the time at which
-     * the decompressed packet will be presented to the user.
-     * Can be AV_NOPTS_VALUE if it is not stored in the file.
-     * pts MUST be larger or equal to dts as presentation cannot happen before
-     * decompression, unless one wants to view hex dumps. Some formats misuse
-     * the terms dts and pts/cts to mean something different. Such timestamps
-     * must be converted to true pts/dts before they are stored in AVPacket.
-     */
     int64_t pts;
-    /**
-     * Decompression timestamp in AVStream->time_base units; the time at which
-     * the packet is decompressed.
-     * Can be AV_NOPTS_VALUE if it is not stored in the file.
-     */
     int64_t dts;
     uint8_t *data;
     int   size;
     int   stream_index;
-    /**
-     * A combination of AV_PKT_FLAG values
-     */
     int   flags;
-    /**
-     * Additional packet data that can be provided by the container.
-     * Packet can contain several types of side information.
-     */
     AVPacketSideData *side_data;
     int side_data_elems;
 
-    /**
-     * Duration of this packet in AVStream->time_base units, 0 if unknown.
-     * Equals next_pts - this_pts in presentation order.
-     */
     int   duration;
 #if FF_API_DESTRUCT_PACKET
-    attribute_deprecated
-    void  (*destruct)(struct AVPacket *);
-    attribute_deprecated
+    void  *destruct;
     void  *priv;
 #endif
     int64_t pos;                            ///< byte position in stream, -1 if unknown
-
-    /**
-     * Time difference in AVStream->time_base units from the pts of this
-     * packet to the point at which the output from the decoder has converged
-     * independent from the availability of previous frames. That is, the
-     * frames are virtually identical no matter if decoding started from
-     * the very first frame or from this keyframe.
-     * Is AV_NOPTS_VALUE if unknown.
-     * This field is not the display duration of the current packet.
-     * This field has no meaning if the packet does not have AV_PKT_FLAG_KEY
-     * set.
-     *
-     * The purpose of this field is to allow seeking in streams that have no
-     * keyframes in the conventional sense. It corresponds to the
-     * recovery point SEI in H.264 and match_time_delta in NUT. It is also
-     * essential for some types of subtitle streams to ensure that all
-     * subtitles are correctly displayed after seeking.
-     */
     int64_t convergence_duration;
 } AVPacket;
 #define AV_PKT_FLAG_KEY     0x0001 ///< The packet contains a keyframe
 #define AV_PKT_FLAG_CORRUPT 0x0002 ///< The packet content is corrupted
 
-enum AVSideDataParamChangeFlags {
-    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT  = 0x0001,
-    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 0x0002,
-    AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE    = 0x0004,
-    AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS     = 0x0008,
-};
-/**
- * @}
- */
-
-struct AVCodecInternal;
+typedef struct AVCodecInternal {
+    int dummy;
+} AVCodecInternal;
 
 enum AVFieldOrder {
     AV_FIELD_UNKNOWN,
@@ -1199,427 +216,70 @@ enum AVFieldOrder {
     AV_FIELD_TT,          //< Top coded_first, top displayed first
     AV_FIELD_BB,          //< Bottom coded first, bottom displayed first
     AV_FIELD_TB,          //< Top coded first, bottom displayed first
-    AV_FIELD_BT,          //< Bottom coded first, top displayed first
+    AV_FIELD_BT          //< Bottom coded first, top displayed first
 };
 
-/**
- * main external API structure.
- * New fields can be added to the end with minor version bumps.
- * Removal, reordering and changes to existing fields require a major
- * version bump.
- * Please use AVOptions (av_opt* / av_set/get*()) to access these fields from user
- * applications.
- * sizeof(AVCodecContext) must not be used outside libav*.
- */
 typedef struct AVCodecContext {
-    /**
-     * information on struct for av_log
-     * - set by avcodec_alloc_context3
-     */
     const AVClass *av_class;
     int log_level_offset;
-
     enum AVMediaType codec_type; /* see AVMEDIA_TYPE_xxx */
     const struct AVCodec  *codec;
-#if FF_API_CODEC_NAME
-    /**
-     * @deprecated this field is not used for anything in libavcodec
-     */
-    attribute_deprecated
     char             codec_name[32];
-#endif
     enum AVCodecID     codec_id; /* see AV_CODEC_ID_xxx */
-
-    /**
-     * fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
-     * This is used to work around some encoder bugs.
-     * A demuxer should set this to what is stored in the field used to identify the codec.
-     * If there are multiple such fields in a container then the demuxer should choose the one
-     * which maximizes the information about the used codec.
-     * If the codec tag field in a container is larger than 32 bits then the demuxer should
-     * remap the longer ID to 32 bits with a table or other structure. Alternatively a new
-     * extra_codec_tag + size could be added but for this a clear advantage must be demonstrated
-     * first.
-     * - encoding: Set by user, if not then the default based on codec_id will be used.
-     * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
-     */
     unsigned int codec_tag;
-
-    /**
-     * fourcc from the AVI stream header (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
-     * This is used to work around some encoder bugs.
-     * - encoding: unused
-     * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
-     */
     unsigned int stream_codec_tag;
-
     void *priv_data;
-
-    /**
-     * Private context used for internal data.
-     *
-     * Unlike priv_data, this is not codec-specific. It is used in general
-     * libavcodec functions.
-     */
     struct AVCodecInternal *internal;
-
-    /**
-     * Private data of the user, can be used to carry app specific stuff.
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     */
     void *opaque;
-
-    /**
-     * the average bitrate
-     * - encoding: Set by user; unused for constant quantizer encoding.
-     * - decoding: Set by libavcodec. 0 or some bitrate if this info is available in the stream.
-     */
     int bit_rate;
-
-    /**
-     * number of bits the bitstream is allowed to diverge from the reference.
-     *           the reference can be CBR (for CBR pass1) or VBR (for pass2)
-     * - encoding: Set by user; unused for constant quantizer encoding.
-     * - decoding: unused
-     */
     int bit_rate_tolerance;
-
-    /**
-     * Global quality for codecs which cannot change it per frame.
-     * This should be proportional to MPEG-1/2/4 qscale.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int global_quality;
-
-    /**
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int compression_level;
 #define FF_COMPRESSION_DEFAULT -1
-
-    /**
-     * CODEC_FLAG_*.
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     */
     int flags;
-
-    /**
-     * CODEC_FLAG2_*
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     */
     int flags2;
-
-    /**
-     * some codecs need / can use extradata like Huffman tables.
-     * mjpeg: Huffman tables
-     * rv10: additional flags
-     * mpeg4: global headers (they can be in the bitstream or here)
-     * The allocated memory should be FF_INPUT_BUFFER_PADDING_SIZE bytes larger
-     * than extradata_size to avoid problems if it is read with the bitstream reader.
-     * The bytewise contents of extradata must not depend on the architecture or CPU endianness.
-     * - encoding: Set/allocated/freed by libavcodec.
-     * - decoding: Set/allocated/freed by user.
-     */
     uint8_t *extradata;
     int extradata_size;
-
-    /**
-     * This is the fundamental unit of time (in seconds) in terms
-     * of which frame timestamps are represented. For fixed-fps content,
-     * timebase should be 1/framerate and timestamp increments should be
-     * identically 1.
-     * - encoding: MUST be set by user.
-     * - decoding: Set by libavcodec.
-     */
     AVRational time_base;
-
-    /**
-     * For some codecs, the time base is closer to the field rate than the frame rate.
-     * Most notably, H.264 and MPEG-2 specify time_base as half of frame duration
-     * if no telecine is used ...
-     *
-     * Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
-     */
     int ticks_per_frame;
-
-    /**
-     * Codec delay.
-     *
-     * Encoding: Number of frames delay there will be from the encoder input to
-     *           the decoder output. (we assume the decoder matches the spec)
-     * Decoding: Number of frames delay in addition to what a standard decoder
-     *           as specified in the spec would produce.
-     *
-     * Video:
-     *   Number of frames the decoded output will be delayed relative to the
-     *   encoded input.
-     *
-     * Audio:
-     *   For encoding, this is the number of "priming" samples added by the
-     *   encoder to the beginning of the stream. The decoded output will be
-     *   delayed by this many samples relative to the input to the encoder (or
-     *   more, if the decoder adds its own padding).
-     *   The timestamps on the output packets are adjusted by the encoder so
-     *   that they always refer to the first sample of the data actually
-     *   contained in the packet, including any added padding.
-     *   E.g. if the timebase is 1/samplerate and the timestamp of the first
-     *   input sample is 0, the timestamp of the first output packet will be
-     *   -delay.
-     *
-     *   For decoding, this is the number of samples the decoder needs to
-     *   output before the decoder's output is valid. When seeking, you should
-     *   start decoding this many samples prior to your desired seek point.
-     *
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     */
     int delay;
-
-
-    /* video only */
-    /**
-     * picture width / height.
-     * - encoding: MUST be set by user.
-     * - decoding: May be set by the user before opening the decoder if known e.g.
-     *             from the container. Some decoders will require the dimensions
-     *             to be set by the caller. During decoding, the decoder may
-     *             overwrite those values as required.
-     */
     int width, height;
-
-    /**
-     * Bitstream width / height, may be different from width/height e.g. when
-     * the decoded frame is cropped before being output or lowres is enabled.
-     * - encoding: unused
-     * - decoding: May be set by the user before opening the decoder if known
-     *             e.g. from the container. During decoding, the decoder may
-     *             overwrite those values as required.
-     */
     int coded_width, coded_height;
-
 #if FF_API_ASPECT_EXTENDED
 #define FF_ASPECT_EXTENDED 15
 #endif
-
-    /**
-     * the number of pictures in a group of pictures, or 0 for intra_only
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int gop_size;
-
-    /**
-     * Pixel format, see AV_PIX_FMT_xxx.
-     * May be set by the demuxer if known from headers.
-     * May be overridden by the decoder if it knows better.
-     * - encoding: Set by user.
-     * - decoding: Set by user if known, overridden by libavcodec if known
-     */
     enum AVPixelFormat pix_fmt;
-
-    /**
-     * Motion estimation algorithm used for video coding.
-     * 1 (zero), 2 (full), 3 (log), 4 (phods), 5 (epzs), 6 (x1), 7 (hex),
-     * 8 (umh), 9 (iter), 10 (tesa) [7, 8, 10 are x264 specific, 9 is snow specific]
-     * - encoding: MUST be set by user.
-     * - decoding: unused
-     */
     int me_method;
-
-    /**
-     * If non NULL, 'draw_horiz_band' is called by the libavcodec
-     * decoder to draw a horizontal band. It improves cache usage. Not
-     * all codecs can do that. You must check the codec capabilities
-     * beforehand.
-     * When multithreading is used, it may be called from multiple threads
-     * at the same time; threads might draw different parts of the same AVFrame,
-     * or multiple AVFrames, and there is no guarantee that slices will be drawn
-     * in order.
-     * The function is also used by hardware acceleration APIs.
-     * It is called at least once during frame decoding to pass
-     * the data needed for hardware render.
-     * In that mode instead of pixel data, AVFrame points to
-     * a structure specific to the acceleration API. The application
-     * reads the structure and can change some fields to indicate progress
-     * or mark state.
-     * - encoding: unused
-     * - decoding: Set by user.
-     * @param height the height of the slice
-     * @param y the y position of the slice
-     * @param type 1->top field, 2->bottom field, 3->frame
-     * @param offset offset into the AVFrame.data from which the slice should be read
-     */
     void (*draw_horiz_band)(struct AVCodecContext *s,
                             const AVFrame *src, int offset[AV_NUM_DATA_POINTERS],
                             int y, int type, int height);
-
-    /**
-     * callback to negotiate the pixelFormat
-     * @param fmt is the list of formats which are supported by the codec,
-     * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
-     * The first is always the native one.
-     * @return the chosen format
-     * - encoding: unused
-     * - decoding: Set by user, if not set the native format will be chosen.
-     */
-    enum AVPixelFormat (*get_format)(struct AVCodecContext *s, const enum AVPixelFormat * fmt);
-
-    /**
-     * maximum number of B-frames between non-B-frames
-     * Note: The output will be delayed by max_b_frames+1 relative to the input.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
+    void *get_format;
     int max_b_frames;
-
-    /**
-     * qscale factor between IP and B-frames
-     * If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).
-     * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float b_quant_factor;
-
-    /** obsolete FIXME remove */
     int rc_strategy;
 #define FF_RC_STRATEGY_XVID 1
-
     int b_frame_strategy;
-
-    /**
-     * qscale offset between IP and B-frames
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float b_quant_offset;
-
-    /**
-     * Size of the frame reordering buffer in the decoder.
-     * For MPEG-2 it is 1 IPB or 0 low delay IP.
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     */
     int has_b_frames;
-
-    /**
-     * 0-> h263 quant 1-> mpeg quant
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int mpeg_quant;
-
-    /**
-     * qscale factor between P and I-frames
-     * If > 0 then the last p frame quantizer will be used (q= lastp_q*factor+offset).
-     * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float i_quant_factor;
-
-    /**
-     * qscale offset between P and I-frames
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float i_quant_offset;
-
-    /**
-     * luminance masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float lumi_masking;
-
-    /**
-     * temporary complexity masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float temporal_cplx_masking;
-
-    /**
-     * spatial complexity masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float spatial_cplx_masking;
-
-    /**
-     * p block masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float p_masking;
-
-    /**
-     * darkness masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float dark_masking;
-
-    /**
-     * slice count
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by user (or 0).
-     */
     int slice_count;
-    /**
-     * prediction method (needed for huffyuv)
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
      int prediction_method;
 #define FF_PRED_LEFT   0
 #define FF_PRED_PLANE  1
 #define FF_PRED_MEDIAN 2
-
-    /**
-     * slice offsets in the frame in bytes
-     * - encoding: Set/allocated by libavcodec.
-     * - decoding: Set/allocated by user (or NULL).
-     */
     int *slice_offset;
-
-    /**
-     * sample aspect ratio (0 if unknown)
-     * That is the width of a pixel divided by the height of the pixel.
-     * Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
     AVRational sample_aspect_ratio;
-
-    /**
-     * motion estimation comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int me_cmp;
-    /**
-     * subpixel motion estimation comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int me_sub_cmp;
-    /**
-     * macroblock comparison function (not supported yet)
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int mb_cmp;
-    /**
-     * interlaced DCT comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int ildct_cmp;
 #define FF_CMP_SAD    0
 #define FF_CMP_SSE    1
@@ -1637,57 +297,12 @@ typedef struct AVCodecContext {
 #define FF_CMP_DCTMAX 13
 #define FF_CMP_DCT264 14
 #define FF_CMP_CHROMA 256
-
-    /**
-     * ME diamond size & shape
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int dia_size;
-
-    /**
-     * amount of previous MV predictors (2a+1 x 2a+1 square)
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int last_predictor_count;
-
-    /**
-     * prepass for motion estimation
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int pre_me;
-
-    /**
-     * motion estimation prepass comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int me_pre_cmp;
-
-    /**
-     * ME prepass diamond size & shape
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int pre_dia_size;
-
-    /**
-     * subpel ME quality
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int me_subpel_quality;
-
-    /**
-     * DTG active format information (additional aspect ratio
-     * information only used in DVB MPEG-2 transport streams)
-     * 0 if not set.
-     *
-     * - encoding: unused
-     * - decoding: Set by decoder.
-     */
     int dtg_active_format;
 #define FF_DTG_AFD_SAME         8
 #define FF_DTG_AFD_4_3          9
@@ -1696,745 +311,108 @@ typedef struct AVCodecContext {
 #define FF_DTG_AFD_4_3_SP_14_9  13
 #define FF_DTG_AFD_16_9_SP_14_9 14
 #define FF_DTG_AFD_SP_4_3       15
-
-    /**
-     * maximum motion estimation search range in subpel units
-     * If 0 then no limit.
-     *
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int me_range;
-
-    /**
-     * intra quantizer bias
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int intra_quant_bias;
 #define FF_DEFAULT_QUANT_BIAS 999999
-
-    /**
-     * inter quantizer bias
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int inter_quant_bias;
-
-    /**
-     * slice flags
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     int slice_flags;
 #define SLICE_FLAG_CODED_ORDER    0x0001 ///< draw_horiz_band() is called in coded order instead of display
 #define SLICE_FLAG_ALLOW_FIELD    0x0002 ///< allow draw_horiz_band() with field slices (MPEG2 field pics)
 #define SLICE_FLAG_ALLOW_PLANE    0x0004 ///< allow draw_horiz_band() with 1 component at a time (SVQ1)
-
 #if FF_API_XVMC
-    /**
-     * XVideo Motion Acceleration
-     * - encoding: forbidden
-     * - decoding: set by decoder
-     * @deprecated XvMC doesn't need it anymore.
-     */
-    attribute_deprecated int xvmc_acceleration;
+    int xvmc_acceleration;
 #endif /* FF_API_XVMC */
-
-    /**
-     * macroblock decision mode
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int mb_decision;
 #define FF_MB_DECISION_SIMPLE 0        ///< uses mb_cmp
 #define FF_MB_DECISION_BITS   1        ///< chooses the one which needs the fewest bits
 #define FF_MB_DECISION_RD     2        ///< rate distortion
-
-    /**
-     * custom intra quantization matrix
-     * - encoding: Set by user, can be NULL.
-     * - decoding: Set by libavcodec.
-     */
     uint16_t *intra_matrix;
-
-    /**
-     * custom inter quantization matrix
-     * - encoding: Set by user, can be NULL.
-     * - decoding: Set by libavcodec.
-     */
     uint16_t *inter_matrix;
-
-    /**
-     * scene change detection threshold
-     * 0 is default, larger means fewer detected scene changes.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int scenechange_threshold;
-
-    /**
-     * noise reduction strength
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int noise_reduction;
-
-    /**
-     * Motion estimation threshold below which no motion estimation is
-     * performed, but instead the user specified motion vectors are used.
-     *
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int me_threshold;
-
-    /**
-     * Macroblock threshold below which the user specified macroblock types will be used.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int mb_threshold;
-
-    /**
-     * precision of the intra DC coefficient - 8
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int intra_dc_precision;
-
-    /**
-     * Number of macroblock rows at the top which are skipped.
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     int skip_top;
-
-    /**
-     * Number of macroblock rows at the bottom which are skipped.
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     int skip_bottom;
-
-    /**
-     * Border processing masking, raises the quantizer for mbs on the borders
-     * of the picture.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float border_masking;
-
-    /**
-     * minimum MB lagrange multipler
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int mb_lmin;
-
-    /**
-     * maximum MB lagrange multipler
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int mb_lmax;
-
-    /**
-     *
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int me_penalty_compensation;
-
-    /**
-     *
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int bidir_refine;
-
-    /**
-     *
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int brd_scale;
-
-    /**
-     * minimum GOP size
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int keyint_min;
-
-    /**
-     * number of reference frames
-     * - encoding: Set by user.
-     * - decoding: Set by lavc.
-     */
     int refs;
-
-    /**
-     * chroma qp offset from luma
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int chromaoffset;
-
-    /**
-     * Multiplied by qscale for each frame and added to scene_change_score.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int scenechange_factor;
-
-    /**
-     *
-     * Note: Value depends upon the compare function used for fullpel ME.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int mv0_threshold;
-
-    /**
-     * Adjust sensitivity of b_frame_strategy 1.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int b_sensitivity;
-
-    /**
-     * Chromaticity coordinates of the source primaries.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     */
     enum AVColorPrimaries color_primaries;
-
-    /**
-     * Color Transfer Characteristic.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     */
     enum AVColorTransferCharacteristic color_trc;
-
-    /**
-     * YUV colorspace type.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     */
     enum AVColorSpace colorspace;
-
-    /**
-     * MPEG vs JPEG YUV range.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     */
     enum AVColorRange color_range;
-
-    /**
-     * This defines the location of chroma samples.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     */
     enum AVChromaLocation chroma_sample_location;
-
-    /**
-     * Number of slices.
-     * Indicates number of picture subdivisions. Used for parallelized
-     * decoding.
-     * - encoding: Set by user
-     * - decoding: unused
-     */
     int slices;
-
-    /** Field order
-     * - encoding: set by libavcodec
-     * - decoding: Set by user.
-     */
     enum AVFieldOrder field_order;
-
-    /* audio only */
     int sample_rate; ///< samples per second
     int channels;    ///< number of audio channels
-
-    /**
-     * audio sample format
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
     enum AVSampleFormat sample_fmt;  ///< sample format
-
-    /* The following data should not be initialized. */
-    /**
-     * Number of samples per channel in an audio frame.
-     *
-     * - encoding: set by libavcodec in avcodec_open2(). Each submitted frame
-     *   except the last must contain exactly frame_size samples per channel.
-     *   May be 0 when the codec has CODEC_CAP_VARIABLE_FRAME_SIZE set, then the
-     *   frame size is not restricted.
-     * - decoding: may be set by some decoders to indicate constant frame size
-     */
     int frame_size;
-
-    /**
-     * Frame counter, set by libavcodec.
-     *
-     * - decoding: total number of frames returned from the decoder so far.
-     * - encoding: total number of frames passed to the encoder so far.
-     *
-     *   @note the counter is not incremented if encoding/decoding resulted in
-     *   an error.
-     */
     int frame_number;
-
-    /**
-     * number of bytes per packet if constant and known or 0
-     * Used by some WAV based audio codecs.
-     */
     int block_align;
-
-    /**
-     * Audio cutoff bandwidth (0 means "automatic")
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int cutoff;
-
 #if FF_API_REQUEST_CHANNELS
-    /**
-     * Decoder should decode to this many channels if it can (0 for default)
-     * - encoding: unused
-     * - decoding: Set by user.
-     * @deprecated Deprecated in favor of request_channel_layout.
-     */
-    attribute_deprecated int request_channels;
+    int request_channels;
 #endif
-
-    /**
-     * Audio channel layout.
-     * - encoding: set by user.
-     * - decoding: set by user, may be overwritten by libavcodec.
-     */
     uint64_t channel_layout;
-
-    /**
-     * Request decoder to use this channel layout if it can (0 for default)
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     uint64_t request_channel_layout;
-
-    /**
-     * Type of service that the audio stream conveys.
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
     enum AVAudioServiceType audio_service_type;
-
-    /**
-     * desired sample format
-     * - encoding: Not used.
-     * - decoding: Set by user.
-     * Decoder will decode to this format if it can.
-     */
     enum AVSampleFormat request_sample_fmt;
-
 #if FF_API_GET_BUFFER
-    /**
-     * Called at the beginning of each frame to get a buffer for it.
-     *
-     * The function will set AVFrame.data[], AVFrame.linesize[].
-     * AVFrame.extended_data[] must also be set, but it should be the same as
-     * AVFrame.data[] except for planar audio with more channels than can fit
-     * in AVFrame.data[]. In that case, AVFrame.data[] shall still contain as
-     * many data pointers as it can hold.
-     *
-     * if CODEC_CAP_DR1 is not set then get_buffer() must call
-     * avcodec_default_get_buffer() instead of providing buffers allocated by
-     * some other means.
-     *
-     * AVFrame.data[] should be 32- or 16-byte-aligned unless the CPU doesn't
-     * need it. avcodec_default_get_buffer() aligns the output buffer properly,
-     * but if get_buffer() is overridden then alignment considerations should
-     * be taken into account.
-     *
-     * @see avcodec_default_get_buffer()
-     *
-     * Video:
-     *
-     * If pic.reference is set then the frame will be read later by libavcodec.
-     * avcodec_align_dimensions2() should be used to find the required width and
-     * height, as they normally need to be rounded up to the next multiple of 16.
-     *
-     * If frame multithreading is used and thread_safe_callbacks is set,
-     * it may be called from a different thread, but not from more than one at
-     * once. Does not need to be reentrant.
-     *
-     * @see release_buffer(), reget_buffer()
-     * @see avcodec_align_dimensions2()
-     *
-     * Audio:
-     *
-     * Decoders request a buffer of a particular size by setting
-     * AVFrame.nb_samples prior to calling get_buffer(). The decoder may,
-     * however, utilize only part of the buffer by setting AVFrame.nb_samples
-     * to a smaller value in the output frame.
-     *
-     * Decoders cannot use the buffer after returning from
-     * avcodec_decode_audio4(), so they will not call release_buffer(), as it
-     * is assumed to be released immediately upon return. In some rare cases,
-     * a decoder may need to call get_buffer() more than once in a single
-     * call to avcodec_decode_audio4(). In that case, when get_buffer() is
-     * called again after it has already been called once, the previously
-     * acquired buffer is assumed to be released at that time and may not be
-     * reused by the decoder.
-     *
-     * As a convenience, av_samples_get_buffer_size() and
-     * av_samples_fill_arrays() in libavutil may be used by custom get_buffer()
-     * functions to find the required data size and to fill data pointers and
-     * linesize. In AVFrame.linesize, only linesize[0] may be set for audio
-     * since all planes must be the same size.
-     *
-     * @see av_samples_get_buffer_size(), av_samples_fill_arrays()
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec, user can override.
-     *
-     * @deprecated use get_buffer2()
-     */
-    attribute_deprecated
     int (*get_buffer)(struct AVCodecContext *c, AVFrame *pic);
-
-    /**
-     * Called to release buffers which were allocated with get_buffer.
-     * A released buffer can be reused in get_buffer().
-     * pic.data[*] must be set to NULL.
-     * May be called from a different thread if frame multithreading is used,
-     * but not by more than one thread at once, so does not need to be reentrant.
-     * - encoding: unused
-     * - decoding: Set by libavcodec, user can override.
-     *
-     * @deprecated custom freeing callbacks should be set from get_buffer2()
-     */
-    attribute_deprecated
     void (*release_buffer)(struct AVCodecContext *c, AVFrame *pic);
-
-    /**
-     * Called at the beginning of a frame to get cr buffer for it.
-     * Buffer type (size, hints) must be the same. libavcodec won't check it.
-     * libavcodec will pass previous buffer in pic, function should return
-     * same buffer or new buffer with old frame "painted" into it.
-     * If pic.data[0] == NULL must behave like get_buffer().
-     * if CODEC_CAP_DR1 is not set then reget_buffer() must call
-     * avcodec_default_reget_buffer() instead of providing buffers allocated by
-     * some other means.
-     * - encoding: unused
-     * - decoding: Set by libavcodec, user can override.
-     */
-    attribute_deprecated
     int (*reget_buffer)(struct AVCodecContext *c, AVFrame *pic);
 #endif
-
-    /**
-     * This callback is called at the beginning of each frame to get data
-     * buffer(s) for it. There may be one contiguous buffer for all the data or
-     * there may be a buffer per each data plane or anything in between. What
-     * this means is, you may set however many entries in buf[] you feel necessary.
-     * Each buffer must be reference-counted using the AVBuffer API (see description
-     * of buf[] below).
-     *
-     * The following fields will be set in the frame before this callback is
-     * called:
-     * - format
-     * - width, height (video only)
-     * - sample_rate, channel_layout, nb_samples (audio only)
-     * Their values may differ from the corresponding values in
-     * AVCodecContext. This callback must use the frame values, not the codec
-     * context values, to calculate the required buffer size.
-     *
-     * This callback must fill the following fields in the frame:
-     * - data[]
-     * - linesize[]
-     * - extended_data:
-     *   * if the data is planar audio with more than 8 channels, then this
-     *     callback must allocate and fill extended_data to contain all pointers
-     *     to all data planes. data[] must hold as many pointers as it can.
-     *     extended_data must be allocated with av_malloc() and will be freed in
-     *     av_frame_unref().
-     *   * otherwise exended_data must point to data
-     * - buf[] must contain one or more pointers to AVBufferRef structures. Each of
-     *   the frame's data and extended_data pointers must be contained in these. That
-     *   is, one AVBufferRef for each allocated chunk of memory, not necessarily one
-     *   AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),
-     *   and av_buffer_ref().
-     * - extended_buf and nb_extended_buf must be allocated with av_malloc() by
-     *   this callback and filled with the extra buffers if there are more
-     *   buffers than buf[] can hold. extended_buf will be freed in
-     *   av_frame_unref().
-     *
-     * If CODEC_CAP_DR1 is not set then get_buffer2() must call
-     * avcodec_default_get_buffer2() instead of providing buffers allocated by
-     * some other means.
-     *
-     * Each data plane must be aligned to the maximum required by the target
-     * CPU.
-     *
-     * @see avcodec_default_get_buffer2()
-     *
-     * Video:
-     *
-     * If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
-     * (read and/or written to if it is writable) later by libavcodec.
-     *
-     * avcodec_align_dimensions2() should be used to find the required width and
-     * height, as they normally need to be rounded up to the next multiple of 16.
-     *
-     * Some decoders do not support linesizes changing between frames.
-     *
-     * If frame multithreading is used and thread_safe_callbacks is set,
-     * this callback may be called from a different thread, but not from more
-     * than one at once. Does not need to be reentrant.
-     *
-     * @see avcodec_align_dimensions2()
-     *
-     * Audio:
-     *
-     * Decoders request a buffer of a particular size by setting
-     * AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
-     * however, utilize only part of the buffer by setting AVFrame.nb_samples
-     * to a smaller value in the output frame.
-     *
-     * As a convenience, av_samples_get_buffer_size() and
-     * av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
-     * functions to find the required data size and to fill data pointers and
-     * linesize. In AVFrame.linesize, only linesize[0] may be set for audio
-     * since all planes must be the same size.
-     *
-     * @see av_samples_get_buffer_size(), av_samples_fill_arrays()
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec, user can override.
-     */
     int (*get_buffer2)(struct AVCodecContext *s, AVFrame *frame, int flags);
-
-    /**
-     * If non-zero, the decoded audio and video frames returned from
-     * avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted
-     * and are valid indefinitely. The caller must free them with
-     * av_frame_unref() when they are not needed anymore.
-     * Otherwise, the decoded frames must not be freed by the caller and are
-     * only valid until the next decode call.
-     *
-     * - encoding: unused
-     * - decoding: set by the caller before avcodec_open2().
-     */
     int refcounted_frames;
-
-    /* - encoding parameters */
     float qcompress;  ///< amount of qscale change between easy & hard scenes (0.0-1.0)
     float qblur;      ///< amount of qscale smoothing over time (0.0-1.0)
-
-    /**
-     * minimum quantizer
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int qmin;
-
-    /**
-     * maximum quantizer
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int qmax;
-
-    /**
-     * maximum quantizer difference between frames
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int max_qdiff;
-
-    /**
-     * ratecontrol qmin qmax limiting method
-     * 0-> clipping, 1-> use a nice continuous function to limit qscale within qmin/qmax.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float rc_qsquish;
-
     float rc_qmod_amp;
     int rc_qmod_freq;
-
-    /**
-     * decoder bitstream buffer size
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int rc_buffer_size;
-
-    /**
-     * ratecontrol override, see RcOverride
-     * - encoding: Allocated/set/freed by user.
-     * - decoding: unused
-     */
     int rc_override_count;
     RcOverride *rc_override;
-
-    /**
-     * rate control equation
-     * - encoding: Set by user
-     * - decoding: unused
-     */
     const char *rc_eq;
-
-    /**
-     * maximum bitrate
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
     int rc_max_rate;
-
-    /**
-     * minimum bitrate
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int rc_min_rate;
-
     float rc_buffer_aggressivity;
-
-    /**
-     * initial complexity for pass1 ratecontrol
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     float rc_initial_cplx;
-
-    /**
-     * Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.
-     * - encoding: Set by user.
-     * - decoding: unused.
-     */
     float rc_max_available_vbv_use;
-
-    /**
-     * Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.
-     * - encoding: Set by user.
-     * - decoding: unused.
-     */
     float rc_min_vbv_overflow_use;
-
-    /**
-     * Number of bits which should be loaded into the rc buffer before decoding starts.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int rc_initial_buffer_occupancy;
-
 #define FF_CODER_TYPE_VLC       0
 #define FF_CODER_TYPE_AC        1
 #define FF_CODER_TYPE_RAW       2
 #define FF_CODER_TYPE_RLE       3
 #define FF_CODER_TYPE_DEFLATE   4
-    /**
-     * coder type
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int coder_type;
-
-    /**
-     * context model
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int context_model;
-
-    /**
-     * minimum Lagrange multiplier
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int lmin;
-
-    /**
-     * maximum Lagrange multiplier
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int lmax;
-
-    /**
-     * frame skip threshold
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int frame_skip_threshold;
-
-    /**
-     * frame skip factor
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int frame_skip_factor;
-
-    /**
-     * frame skip exponent
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int frame_skip_exp;
-
-    /**
-     * frame skip comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int frame_skip_cmp;
-
-    /**
-     * trellis RD quantization
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int trellis;
-
-    /**
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int min_prediction_order;
-
-    /**
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int max_prediction_order;
-
-    /**
-     * GOP timecode frame start number
-     * - encoding: Set by user, in non drop frame format
-     * - decoding: Set by libavcodec (timecode in the 25 bits format, -1 if unset)
-     */
     int64_t timecode_frame_start;
-
-    /* The RTP callback: This function is called    */
-    /* every time the encoder has a packet to send. */
-    /* It depends on the encoder if the data starts */
-    /* with a Start Code (it should). H.263 does.   */
-    /* mb_nb contains the number of macroblocks     */
-    /* encoded in the RTP payload.                  */
     void (*rtp_callback)(struct AVCodecContext *avctx, void *data, int size, int mb_nb);
-
     int rtp_payload_size;   /* The size of the RTP payload: the coder will  */
-                            /* do its best to deliver a chunk with size     */
-                            /* below rtp_payload_size, the chunk will start */
-                            /* with a start code on some codecs like H.263. */
-                            /* This doesn't take account of any particular  */
-                            /* headers inside the transmitted RTP payload.  */
-
-    /* statistics, used for 2-pass encoding */
     int mv_bits;
     int header_bits;
     int i_tex_bits;
@@ -2443,34 +421,9 @@ typedef struct AVCodecContext {
     int p_count;
     int skip_count;
     int misc_bits;
-
-    /**
-     * number of bits used for the previously encoded frame
-     * - encoding: Set by libavcodec.
-     * - decoding: unused
-     */
     int frame_bits;
-
-    /**
-     * pass1 encoding statistics output buffer
-     * - encoding: Set by libavcodec.
-     * - decoding: unused
-     */
     char *stats_out;
-
-    /**
-     * pass2 encoding statistics input buffer
-     * Concatenated stuff from stats_out of pass1 should be placed here.
-     * - encoding: Allocated/set/freed by user.
-     * - decoding: unused
-     */
     char *stats_in;
-
-    /**
-     * Work around bugs in encoders which sometimes cannot be detected automatically.
-     * - encoding: Set by user
-     * - decoding: Set by user
-     */
     int workaround_bugs;
 #define FF_BUG_AUTODETECT       1  ///< autodetection
 #if FF_API_OLD_MSMPEG4
@@ -2492,41 +445,15 @@ typedef struct AVCodecContext {
 #define FF_BUG_DC_CLIP          4096
 #define FF_BUG_MS               8192 ///< Work around various bugs in Microsoft's broken decoders.
 #define FF_BUG_TRUNCATED       16384
-
-    /**
-     * strictly follow the standard (MPEG4, ...).
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     * Setting this to STRICT or higher means the encoder and decoder will
-     * generally do stupid things, whereas setting it to unofficial or lower
-     * will mean the encoder might produce output that is not supported by all
-     * spec-compliant decoders. Decoders don't differentiate between normal,
-     * unofficial and experimental (that is, they always try to decode things
-     * when they can) unless they are explicitly asked to behave stupidly
-     * (=strictly conform to the specs)
-     */
     int strict_std_compliance;
 #define FF_COMPLIANCE_VERY_STRICT   2 ///< Strictly conform to an older more strict version of the spec or reference software.
 #define FF_COMPLIANCE_STRICT        1 ///< Strictly conform to all the things in the spec no matter what consequences.
 #define FF_COMPLIANCE_NORMAL        0
 #define FF_COMPLIANCE_UNOFFICIAL   -1 ///< Allow unofficial extensions
 #define FF_COMPLIANCE_EXPERIMENTAL -2 ///< Allow nonstandardized experimental things.
-
-    /**
-     * error concealment flags
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     int error_concealment;
 #define FF_EC_GUESS_MVS   1
 #define FF_EC_DEBLOCK     2
-#define FF_EC_FAVOR_INTER 256
-
-    /**
-     * debug
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     */
     int debug;
 #define FF_DEBUG_PICT_INFO   1
 #define FF_DEBUG_RC          2
@@ -2534,9 +461,6 @@ typedef struct AVCodecContext {
 #define FF_DEBUG_MB_TYPE     8
 #define FF_DEBUG_QP          16
 #if FF_API_DEBUG_MV
-/**
- * @deprecated this option does nothing
- */
 #define FF_DEBUG_MV          32
 #endif
 #define FF_DEBUG_DCT_COEFF   0x00000040
@@ -2552,85 +476,24 @@ typedef struct AVCodecContext {
 #endif
 #define FF_DEBUG_BUFFERS     0x00008000
 #define FF_DEBUG_THREADS     0x00010000
-#define FF_DEBUG_NOMC        0x01000000
-
 #if FF_API_DEBUG_MV
-    /**
-     * debug
-     * Code outside libavcodec should access this field using AVOptions
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     */
     int debug_mv;
 #define FF_DEBUG_VIS_MV_P_FOR  0x00000001 //visualize forward predicted MVs of P frames
 #define FF_DEBUG_VIS_MV_B_FOR  0x00000002 //visualize forward predicted MVs of B frames
 #define FF_DEBUG_VIS_MV_B_BACK 0x00000004 //visualize backward predicted MVs of B frames
 #endif
-
-    /**
-     * Error recognition; may misdetect some more or less valid parts as errors.
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     int err_recognition;
-
-/**
- * Verify checksums embedded in the bitstream (could be of either encoded or
- * decoded data, depending on the codec) and print an error message on mismatch.
- * If AV_EF_EXPLODE is also set, a mismatching checksum will result in the
- * decoder returning an error.
- */
 #define AV_EF_CRCCHECK  (1<<0)
 #define AV_EF_BITSTREAM (1<<1)          ///< detect bitstream specification deviations
 #define AV_EF_BUFFER    (1<<2)          ///< detect improper bitstream length
 #define AV_EF_EXPLODE   (1<<3)          ///< abort decoding on minor error detection
-
-#define AV_EF_IGNORE_ERR (1<<15)        ///< ignore errors and continue
 #define AV_EF_CAREFUL    (1<<16)        ///< consider things that violate the spec, are fast to calculate and have not been seen in the wild as errors
-#define AV_EF_COMPLIANT  (1<<17)        ///< consider all spec non compliances as errors
+#define AV_EF_COMPLIANT  (1<<17)        ///< consider all spec non compliancies as errors
 #define AV_EF_AGGRESSIVE (1<<18)        ///< consider things that a sane encoder should not do as an error
-
-
-    /**
-     * opaque 64bit number (generally a PTS) that will be reordered and
-     * output in AVFrame.reordered_opaque
-     * @deprecated in favor of pkt_pts
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     int64_t reordered_opaque;
-
-    /**
-     * Hardware accelerator in use
-     * - encoding: unused.
-     * - decoding: Set by libavcodec
-     */
     struct AVHWAccel *hwaccel;
-
-    /**
-     * Hardware accelerator context.
-     * For some hardware accelerators, a global context needs to be
-     * provided by the user. In that case, this holds display-dependent
-     * data FFmpeg cannot instantiate itself. Please refer to the
-     * FFmpeg HW accelerator documentation to know how to fill this
-     * is. e.g. for VA API, this is a struct vaapi_context.
-     * - encoding: unused
-     * - decoding: Set by user
-     */
     void *hwaccel_context;
-
-    /**
-     * error
-     * - encoding: Set by libavcodec if flags&CODEC_FLAG_PSNR.
-     * - decoding: unused
-     */
     uint64_t error[AV_NUM_DATA_POINTERS];
-
-    /**
-     * DCT algorithm, see FF_DCT_* below
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
     int dct_algo;
 #define FF_DCT_AUTO    0
 #define FF_DCT_FASTINT 1
@@ -2638,12 +501,6 @@ typedef struct AVCodecContext {
 #define FF_DCT_MMX     3
 #define FF_DCT_ALTIVEC 5
 #define FF_DCT_FAAN    6
-
-    /**
-     * IDCT algorithm, see FF_IDCT_* below.
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     */
     int idct_algo;
 #define FF_IDCT_AUTO          0
 #define FF_IDCT_INT           1
@@ -2651,144 +508,36 @@ typedef struct AVCodecContext {
 #define FF_IDCT_SIMPLEMMX     3
 #define FF_IDCT_ARM           7
 #define FF_IDCT_ALTIVEC       8
-#if FF_API_ARCH_SH4
 #define FF_IDCT_SH4           9
-#endif
 #define FF_IDCT_SIMPLEARM     10
 #define FF_IDCT_IPP           13
 #define FF_IDCT_XVIDMMX       14
 #define FF_IDCT_SIMPLEARMV5TE 16
 #define FF_IDCT_SIMPLEARMV6   17
-#if FF_API_ARCH_SPARC
 #define FF_IDCT_SIMPLEVIS     18
-#endif
 #define FF_IDCT_FAAN          20
 #define FF_IDCT_SIMPLENEON    22
 #if FF_API_ARCH_ALPHA
 #define FF_IDCT_SIMPLEALPHA   23
 #endif
-#define FF_IDCT_SIMPLEAUTO    128
-
-    /**
-     * bits per sample/pixel from the demuxer (needed for huffyuv).
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by user.
-     */
      int bits_per_coded_sample;
-
-    /**
-     * Bits per sample/pixel of internal libavcodec pixel/sample format.
-     * - encoding: set by user.
-     * - decoding: set by libavcodec.
-     */
     int bits_per_raw_sample;
-
 #if FF_API_LOWRES
-    /**
-     * low resolution decoding, 1-> 1/2 size, 2->1/4 size
-     * - encoding: unused
-     * - decoding: Set by user.
-     * Code outside libavcodec should access this field using:
-     * av_codec_{get,set}_lowres(avctx)
-     */
      int lowres;
 #endif
-
-    /**
-     * the picture in the bitstream
-     * - encoding: Set by libavcodec.
-     * - decoding: unused
-     */
     AVFrame *coded_frame;
-
-    /**
-     * thread count
-     * is used to decide how many independent tasks should be passed to execute()
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     */
     int thread_count;
-
-    /**
-     * Which multithreading methods to use.
-     * Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,
-     * so clients which cannot provide future frames should not use it.
-     *
-     * - encoding: Set by user, otherwise the default is used.
-     * - decoding: Set by user, otherwise the default is used.
-     */
     int thread_type;
 #define FF_THREAD_FRAME   1 ///< Decode more than one frame at once
 #define FF_THREAD_SLICE   2 ///< Decode more than one part of a single frame at once
-
-    /**
-     * Which multithreading methods are in use by the codec.
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     */
     int active_thread_type;
-
-    /**
-     * Set by the client if its custom get_buffer() callback can be called
-     * synchronously from another thread, which allows faster multithreaded decoding.
-     * draw_horiz_band() will be called from other threads regardless of this setting.
-     * Ignored if the default get_buffer() is used.
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     */
     int thread_safe_callbacks;
-
-    /**
-     * The codec may call this to execute several independent things.
-     * It will return only after finishing all tasks.
-     * The user may replace this with some multithreaded implementation,
-     * the default implementation will execute the parts serially.
-     * @param count the number of things to execute
-     * - encoding: Set by libavcodec, user can override.
-     * - decoding: Set by libavcodec, user can override.
-     */
     int (*execute)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg), void *arg2, int *ret, int count, int size);
-
-    /**
-     * The codec may call this to execute several independent things.
-     * It will return only after finishing all tasks.
-     * The user may replace this with some multithreaded implementation,
-     * the default implementation will execute the parts serially.
-     * Also see avcodec_thread_init and e.g. the --enable-pthread configure option.
-     * @param c context passed also to func
-     * @param count the number of things to execute
-     * @param arg2 argument passed unchanged to func
-     * @param ret return values of executed functions, must have space for "count" values. May be NULL.
-     * @param func function that will be called count times, with jobnr from 0 to count-1.
-     *             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no
-     *             two instances of func executing at the same time will have the same threadnr.
-     * @return always 0 currently, but code should handle a future improvement where when any call to func
-     *         returns < 0 no further calls to func may be done and < 0 is returned.
-     * - encoding: Set by libavcodec, user can override.
-     * - decoding: Set by libavcodec, user can override.
-     */
     int (*execute2)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg, int jobnr, int threadnr), void *arg2, int *ret, int count);
-
 #if FF_API_THREAD_OPAQUE
-    /**
-     * @deprecated this field should not be used from outside of lavc
-     */
-    attribute_deprecated
     void *thread_opaque;
 #endif
-
-    /**
-     * noise vs. sse weight for the nsse comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
      int nsse_weight;
-
-    /**
-     * profile
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
      int profile;
 #define FF_PROFILE_UNKNOWN -99
 #define FF_PROFILE_RESERVED -100
@@ -2866,213 +615,52 @@ typedef struct AVCodecContext {
 #define FF_PROFILE_HEVC_MAIN                        1
 #define FF_PROFILE_HEVC_MAIN_10                     2
 #define FF_PROFILE_HEVC_MAIN_STILL_PICTURE          3
-#define FF_PROFILE_HEVC_REXT                        4
-
-    /**
-     * level
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
      int level;
 #define FF_LEVEL_UNKNOWN -99
-
-    /**
-     * Skip loop filtering for selected frames.
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     enum AVDiscard skip_loop_filter;
-
-    /**
-     * Skip IDCT/dequantization for selected frames.
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     enum AVDiscard skip_idct;
-
-    /**
-     * Skip decoding for selected frames.
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
     enum AVDiscard skip_frame;
-
-    /**
-     * Header containing style information for text subtitles.
-     * For SUBTITLE_ASS subtitle type, it should contain the whole ASS
-     * [Script Info] and [V4+ Styles] section, plus the [Events] line and
-     * the Format line following. It shouldn't include any Dialogue line.
-     * - encoding: Set/allocated/freed by user (before avcodec_open2())
-     * - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
-     */
     uint8_t *subtitle_header;
     int subtitle_header_size;
-
 #if FF_API_ERROR_RATE
-    /**
-     * @deprecated use the 'error_rate' private AVOption of the mpegvideo
-     * encoders
-     */
-    attribute_deprecated
     int error_rate;
 #endif
 
 #if FF_API_CODEC_PKT
-    /**
-     * @deprecated this field is not supposed to be accessed from outside lavc
-     */
-    attribute_deprecated
     AVPacket *pkt;
 #endif
-
-    /**
-     * VBV delay coded in the last frame (in periods of a 27 MHz clock).
-     * Used for compliant TS muxing.
-     * - encoding: Set by libavcodec.
-     * - decoding: unused.
-     */
     uint64_t vbv_delay;
-
-    /**
-     * Encoding only. Allow encoders to output packets that do not contain any
-     * encoded data, only side data.
-     *
-     * Some encoders need to output such packets, e.g. to update some stream
-     * parameters at the end of encoding.
-     *
-     * All callers are strongly recommended to set this option to 1 and update
-     * their code to deal with such packets, since this behaviour may become
-     * always enabled in the future (then this option will be deprecated and
-     * later removed). To avoid ABI issues when this happens, the callers should
-     * use AVOptions to set this field.
-     */
-    int side_data_only_packets;
-
-    /**
-     * Timebase in which pkt_dts/pts and AVPacket.dts/pts are.
-     * Code outside libavcodec should access this field using:
-     * av_codec_{get,set}_pkt_timebase(avctx)
-     * - encoding unused.
-     * - decoding set by user.
-     */
     AVRational pkt_timebase;
-
-    /**
-     * AVCodecDescriptor
-     * Code outside libavcodec should access this field using:
-     * av_codec_{get,set}_codec_descriptor(avctx)
-     * - encoding: unused.
-     * - decoding: set by libavcodec.
-     */
     const AVCodecDescriptor *codec_descriptor;
-
 #if !FF_API_LOWRES
-    /**
-     * low resolution decoding, 1-> 1/2 size, 2->1/4 size
-     * - encoding: unused
-     * - decoding: Set by user.
-     * Code outside libavcodec should access this field using:
-     * av_codec_{get,set}_lowres(avctx)
-     */
      int lowres;
 #endif
-
-    /**
-     * Current statistics for PTS correction.
-     * - decoding: maintained and used by libavcodec, not intended to be used by user apps
-     * - encoding: unused
-     */
     int64_t pts_correction_num_faulty_pts; /// Number of incorrect PTS values so far
     int64_t pts_correction_num_faulty_dts; /// Number of incorrect DTS values so far
     int64_t pts_correction_last_pts;       /// PTS of the last frame
     int64_t pts_correction_last_dts;       /// DTS of the last frame
-
-    /**
-     * Character encoding of the input subtitles file.
-     * - decoding: set by user
-     * - encoding: unused
-     */
     char *sub_charenc;
-
-    /**
-     * Subtitles character encoding mode. Formats or codecs might be adjusting
-     * this setting (if they are doing the conversion themselves for instance).
-     * - decoding: set by libavcodec
-     * - encoding: unused
-     */
     int sub_charenc_mode;
 #define FF_SUB_CHARENC_MODE_DO_NOTHING  -1  ///< do nothing (demuxer outputs a stream supposed to be already in UTF-8, or the codec is bitmap for instance)
 #define FF_SUB_CHARENC_MODE_AUTOMATIC    0  ///< libavcodec will select the mode itself
 #define FF_SUB_CHARENC_MODE_PRE_DECODER  1  ///< the AVPacket data needs to be recoded to UTF-8 before being fed to the decoder, requires iconv
-
-    /**
-     * Skip processing alpha if supported by codec.
-     * Note that if the format uses pre-multiplied alpha (common with VP6,
-     * and recommended due to better video quality/compression)
-     * the image will look as if alpha-blended onto a black background.
-     * However for formats that do not use pre-multiplied alpha
-     * there might be serious artefacts (though e.g. libswscale currently
-     * assumes pre-multiplied alpha anyway).
-     * Code outside libavcodec should access this field using AVOptions
-     *
-     * - decoding: set by user
-     * - encoding: unused
-     */
     int skip_alpha;
-
-    /**
-     * Number of samples to skip after a discontinuity
-     * - decoding: unused
-     * - encoding: set by libavcodec
-     */
     int seek_preroll;
-
 #if !FF_API_DEBUG_MV
-    /**
-     * debug motion vectors
-     * Code outside libavcodec should access this field using AVOptions
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     */
     int debug_mv;
 #define FF_DEBUG_VIS_MV_P_FOR  0x00000001 //visualize forward predicted MVs of P frames
 #define FF_DEBUG_VIS_MV_B_FOR  0x00000002 //visualize forward predicted MVs of B frames
 #define FF_DEBUG_VIS_MV_B_BACK 0x00000004 //visualize backward predicted MVs of B frames
 #endif
-
-    /**
-     * custom intra quantization matrix
-     * Code outside libavcodec should access this field using av_codec_g/set_chroma_intra_matrix()
-     * - encoding: Set by user, can be NULL.
-     * - decoding: unused.
-     */
     uint16_t *chroma_intra_matrix;
 } AVCodecContext;
 
-AVRational av_codec_get_pkt_timebase         (const AVCodecContext *avctx);
-void       av_codec_set_pkt_timebase         (AVCodecContext *avctx, AVRational val);
-
-const AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *avctx);
-void                     av_codec_set_codec_descriptor(AVCodecContext *avctx, const AVCodecDescriptor *desc);
-
-int  av_codec_get_lowres(const AVCodecContext *avctx);
-void av_codec_set_lowres(AVCodecContext *avctx, int val);
-
-int  av_codec_get_seek_preroll(const AVCodecContext *avctx);
-void av_codec_set_seek_preroll(AVCodecContext *avctx, int val);
-
-uint16_t *av_codec_get_chroma_intra_matrix(const AVCodecContext *avctx);
-void av_codec_set_chroma_intra_matrix(AVCodecContext *avctx, uint16_t *val);
-
 /**
  * AVProfile.
  */
-typedef struct AVProfile {
-    int profile;
-    const char *name; ///< short name for the profile
-} AVProfile;
+typedef struct AVProfile;
 
-typedef struct AVCodecDefault AVCodecDefault;
+struct AVCodecDefault;
 
 struct AVSubtitle;
 
@@ -3080,323 +668,17 @@ struct AVSubtitle;
  * AVCodec.
  */
 typedef struct AVCodec {
-    /**
-     * Name of the codec implementation.
-     * The name is globally unique among encoders and among decoders (but an
-     * encoder and a decoder can share the same name).
-     * This is the primary way to find a codec from the user perspective.
-     */
-    const char *name;
-    /**
-     * Descriptive name for the codec, meant to be more human readable than name.
-     * You should use the NULL_IF_CONFIG_SMALL() macro to define it.
-     */
-    const char *long_name;
-    enum AVMediaType type;
-    enum AVCodecID id;
-    /**
-     * Codec capabilities.
-     * see CODEC_CAP_*
-     */
-    int capabilities;
-    const AVRational *supported_framerates; ///< array of supported framerates, or NULL if any, array is terminated by {0,0}
-    const enum AVPixelFormat *pix_fmts;     ///< array of supported pixel formats, or NULL if unknown, array is terminated by -1
-    const int *supported_samplerates;       ///< array of supported audio samplerates, or NULL if unknown, array is terminated by 0
-    const enum AVSampleFormat *sample_fmts; ///< array of supported sample formats, or NULL if unknown, array is terminated by -1
-    const uint64_t *channel_layouts;         ///< array of support channel layouts, or NULL if unknown. array is terminated by 0
-#if FF_API_LOWRES
-    uint8_t max_lowres;                     ///< maximum value for lowres supported by the decoder, no direct access, use av_codec_get_max_lowres()
-#endif
-    const AVClass *priv_class;              ///< AVClass for the private context
-    const AVProfile *profiles;              ///< array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
-
-    /*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavcodec and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     */
-    int priv_data_size;
-    struct AVCodec *next;
-    /**
-     * @name Frame-level threading support functions
-     * @{
-     */
-    /**
-     * If defined, called on thread contexts when they are created.
-     * If the codec allocates writable tables in init(), re-allocate them here.
-     * priv_data will be set to a copy of the original.
-     */
-    int (*init_thread_copy)(AVCodecContext *);
-    /**
-     * Copy necessary context variables from a previous thread context to the current one.
-     * If not defined, the next thread will start automatically; otherwise, the codec
-     * must call ff_thread_finish_setup().
-     *
-     * dst and src will (rarely) point to the same context, in which case memcpy should be skipped.
-     */
-    int (*update_thread_context)(AVCodecContext *dst, const AVCodecContext *src);
-    /** @} */
-
-    /**
-     * Private codec-specific defaults.
-     */
-    const AVCodecDefault *defaults;
-
-    /**
-     * Initialize codec static data, called from avcodec_register().
-     */
-    void (*init_static_data)(struct AVCodec *codec);
-
-    int (*init)(AVCodecContext *);
-    int (*encode_sub)(AVCodecContext *, uint8_t *buf, int buf_size,
-                      const struct AVSubtitle *sub);
-    /**
-     * Encode data to an AVPacket.
-     *
-     * @param      avctx          codec context
-     * @param      avpkt          output AVPacket (may contain a user-provided buffer)
-     * @param[in]  frame          AVFrame containing the raw data to be encoded
-     * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
-     *                            non-empty packet was returned in avpkt.
-     * @return 0 on success, negative error code on failure
-     */
-    int (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame,
-                   int *got_packet_ptr);
-    int (*decode)(AVCodecContext *, void *outdata, int *outdata_size, AVPacket *avpkt);
-    int (*close)(AVCodecContext *);
-    /**
-     * Flush buffers.
-     * Will be called when seeking
-     */
-    void (*flush)(AVCodecContext *);
+    int dummy;
 } AVCodec;
 
-int av_codec_get_max_lowres(const AVCodec *codec);
-
-struct MpegEncContext;
-
 /**
  * AVHWAccel.
  */
 typedef struct AVHWAccel {
-    /**
-     * Name of the hardware accelerated codec.
-     * The name is globally unique among encoders and among decoders (but an
-     * encoder and a decoder can share the same name).
-     */
-    const char *name;
-
-    /**
-     * Type of codec implemented by the hardware accelerator.
-     *
-     * See AVMEDIA_TYPE_xxx
-     */
-    enum AVMediaType type;
-
-    /**
-     * Codec implemented by the hardware accelerator.
-     *
-     * See AV_CODEC_ID_xxx
-     */
-    enum AVCodecID id;
-
-    /**
-     * Supported pixel format.
-     *
-     * Only hardware accelerated formats are supported here.
-     */
-    enum AVPixelFormat pix_fmt;
-
-    /**
-     * Hardware accelerated codec capabilities.
-     * see FF_HWACCEL_CODEC_CAP_*
-     */
-    int capabilities;
-
-    /*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavcodec and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     */
-    struct AVHWAccel *next;
-
-    /**
-     * Allocate a custom buffer
-     */
-    int (*alloc_frame)(AVCodecContext *avctx, AVFrame *frame);
-
-    /**
-     * Called at the beginning of each frame or field picture.
-     *
-     * Meaningful frame information (codec specific) is guaranteed to
-     * be parsed at this point. This function is mandatory.
-     *
-     * Note that buf can be NULL along with buf_size set to 0.
-     * Otherwise, this means the whole frame is available at this point.
-     *
-     * @param avctx the codec context
-     * @param buf the frame data buffer base
-     * @param buf_size the size of the frame in bytes
-     * @return zero if successful, a negative value otherwise
-     */
-    int (*start_frame)(AVCodecContext *avctx, const uint8_t *buf, uint32_t buf_size);
-
-    /**
-     * Callback for each slice.
-     *
-     * Meaningful slice information (codec specific) is guaranteed to
-     * be parsed at this point. This function is mandatory.
-     * The only exception is XvMC, that works on MB level.
-     *
-     * @param avctx the codec context
-     * @param buf the slice data buffer base
-     * @param buf_size the size of the slice in bytes
-     * @return zero if successful, a negative value otherwise
-     */
-    int (*decode_slice)(AVCodecContext *avctx, const uint8_t *buf, uint32_t buf_size);
-
-    /**
-     * Called at the end of each frame or field picture.
-     *
-     * The whole picture is parsed at this point and can now be sent
-     * to the hardware accelerator. This function is mandatory.
-     *
-     * @param avctx the codec context
-     * @return zero if successful, a negative value otherwise
-     */
-    int (*end_frame)(AVCodecContext *avctx);
-
-    /**
-     * Size of per-frame hardware accelerator private data.
-     *
-     * Private data is allocated with av_mallocz() before
-     * AVCodecContext.get_buffer() and deallocated after
-     * AVCodecContext.release_buffer().
-     */
-    int frame_priv_data_size;
-
-    /**
-     * Called for every Macroblock in a slice.
-     *
-     * XvMC uses it to replace the ff_MPV_decode_mb().
-     * Instead of decoding to raw picture, MB parameters are
-     * stored in an array provided by the video driver.
-     *
-     * @param s the mpeg context
-     */
-    void (*decode_mb)(struct MpegEncContext *s);
-
-    /**
-     * Initialize the hwaccel private data.
-     *
-     * This will be called from ff_get_format(), after hwaccel and
-     * hwaccel_context are set and the hwaccel private data in AVCodecInternal
-     * is allocated.
-     */
-    int (*init)(AVCodecContext *avctx);
-
-    /**
-     * Uninitialize the hwaccel private data.
-     *
-     * This will be called from get_format() or avcodec_close(), after hwaccel
-     * and hwaccel_context are already uninitialized.
-     */
-    int (*uninit)(AVCodecContext *avctx);
-
-    /**
-     * Size of the private data to allocate in
-     * AVCodecInternal.hwaccel_priv_data.
-     */
-    int priv_data_size;
+    int dummy;
 } AVHWAccel;
 
-/**
- * @defgroup lavc_picture AVPicture
- *
- * Functions for working with AVPicture
- * @{
- */
-
-/**
- * Picture data structure.
- *
- * Up to four components can be stored into it, the last component is
- * alpha.
- */
-typedef struct AVPicture {
-    uint8_t *data[AV_NUM_DATA_POINTERS];    ///< pointers to the image data planes
-    int linesize[AV_NUM_DATA_POINTERS];     ///< number of bytes per line
-} AVPicture;
-
-/**
- * @}
- */
-
-enum AVSubtitleType {
-    SUBTITLE_NONE,
-
-    SUBTITLE_BITMAP,                ///< A bitmap, pict will be set
-
-    /**
-     * Plain text, the text field must be set by the decoder and is
-     * authoritative. ass and pict fields may contain approximations.
-     */
-    SUBTITLE_TEXT,
-
-    /**
-     * Formatted text, the ass field must be set by the decoder and is
-     * authoritative. pict and text fields may contain approximations.
-     */
-    SUBTITLE_ASS,
-};
-
-#define AV_SUBTITLE_FLAG_FORCED 0x00000001
-
-typedef struct AVSubtitleRect {
-    int x;         ///< top left corner  of pict, undefined when pict is not set
-    int y;         ///< top left corner  of pict, undefined when pict is not set
-    int w;         ///< width            of pict, undefined when pict is not set
-    int h;         ///< height           of pict, undefined when pict is not set
-    int nb_colors; ///< number of colors in pict, undefined when pict is not set
-
-    /**
-     * data+linesize for the bitmap of this subtitle.
-     * can be set for text/ass as well once they where rendered
-     */
-    AVPicture pict;
-    enum AVSubtitleType type;
-
-    char *text;                     ///< 0 terminated plain UTF-8 text
-
-    /**
-     * 0 terminated ASS/SSA compatible event line.
-     * The presentation of this is unaffected by the other values in this
-     * struct.
-     */
-    char *ass;
-
-    int flags;
-} AVSubtitleRect;
-
-typedef struct AVSubtitle {
-    uint16_t format; /* 0 = graphics */
-    uint32_t start_display_time; /* relative to packet pts, in ms */
-    uint32_t end_display_time; /* relative to packet pts, in ms */
-    unsigned num_rects;
-    AVSubtitleRect **rects;
-    int64_t pts;    ///< Same as packet pts, in AV_TIME_BASE
-} AVSubtitle;
-
-/**
- * If c is NULL, returns the first registered codec,
- * if c is non-NULL, returns the next registered codec after c,
- * or NULL if c is the last one.
- */
-AVCodec *av_codec_next(const AVCodec *c);
+typedef struct AVPicture;
 
 /**
  * Return the LIBAVCODEC_VERSION_INT constant.
@@ -3404,38 +686,6 @@ AVCodec *av_codec_next(const AVCodec *c)
 unsigned avcodec_version(void);
 
 /**
- * Return the libavcodec build-time configuration.
- */
-const char *avcodec_configuration(void);
-
-/**
- * Return the libavcodec license.
- */
-const char *avcodec_license(void);
-
-/**
- * Register the codec codec and initialize libavcodec.
- *
- * @warning either this function or avcodec_register_all() must be called
- * before any other libavcodec functions.
- *
- * @see avcodec_register_all()
- */
-void avcodec_register(AVCodec *codec);
-
-/**
- * Register all the codecs, parsers and bitstream filters which were enabled at
- * configuration time. If you do not call this function you can select exactly
- * which formats you want to support, by using the individual registration
- * functions.
- *
- * @see avcodec_register
- * @see av_register_codec_parser
- * @see av_register_bitstream_filter
- */
-void avcodec_register_all(void);
-
-/**
  * Allocate an AVCodecContext and set its fields to default values. The
  * resulting struct should be freed with avcodec_free_context().
  *
@@ -3468,74 +718,9 @@ void avcodec_free_context(AVCodecContext
  */
 int avcodec_get_context_defaults3(AVCodecContext *s, const AVCodec *codec);
 
-/**
- * Get the AVClass for AVCodecContext. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- */
-const AVClass *avcodec_get_class(void);
-
-/**
- * Get the AVClass for AVFrame. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- */
-const AVClass *avcodec_get_frame_class(void);
-
-/**
- * Get the AVClass for AVSubtitleRect. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- */
-const AVClass *avcodec_get_subtitle_rect_class(void);
-
-/**
- * Copy the settings of the source AVCodecContext into the destination
- * AVCodecContext. The resulting destination codec context will be
- * unopened, i.e. you are required to call avcodec_open2() before you
- * can use this AVCodecContext to decode/encode video/audio data.
- *
- * @param dest target codec context, should be initialized with
- *             avcodec_alloc_context3(NULL), but otherwise uninitialized
- * @param src source codec context
- * @return AVERROR() on error (e.g. memory allocation error), 0 on success
- */
-int avcodec_copy_context(AVCodecContext *dest, const AVCodecContext *src);
-
 #if FF_API_AVFRAME_LAVC
-/**
- * @deprecated use av_frame_alloc()
- */
-attribute_deprecated
 AVFrame *avcodec_alloc_frame(void);
 
-/**
- * Set the fields of the given AVFrame to default values.
- *
- * @param frame The AVFrame of which the fields should be set to default values.
- *
- * @deprecated use av_frame_unref()
- */
-attribute_deprecated
-void avcodec_get_frame_defaults(AVFrame *frame);
-
-/**
- * Free the frame and any dynamically allocated objects in it,
- * e.g. extended_data.
- *
- * @param frame frame to be freed. The pointer will be set to NULL.
- *
- * @warning this function does NOT free the data buffers themselves
- * (it does not know how, since they might have been allocated with
- *  a custom get_buffer()).
- *
- * @deprecated use av_frame_free()
- */
-attribute_deprecated
-void avcodec_free_frame(AVFrame **frame);
 #endif
 
 /**
@@ -3588,31 +773,6 @@ int avcodec_open2(AVCodecContext *avctx,
 int avcodec_close(AVCodecContext *avctx);
 
 /**
- * Free all allocated data in the given subtitle struct.
- *
- * @param sub AVSubtitle to free.
- */
-void avsubtitle_free(AVSubtitle *sub);
-
-/**
- * @}
- */
-
-/**
- * @addtogroup lavc_packet
- * @{
- */
-
-#if FF_API_DESTRUCT_PACKET
-/**
- * Default packet destructor.
- * @deprecated use the AVBuffer API instead
- */
-attribute_deprecated
-void av_destruct_packet(AVPacket *pkt);
-#endif
-
-/**
  * Initialize optional fields of a packet with default values.
  *
  * Note, this does not touch the data and size members, which have to be
@@ -3623,411 +783,75 @@ void av_destruct_packet(AVPacket *pkt);
 void av_init_packet(AVPacket *pkt);
 
 /**
- * Allocate the payload of a packet and initialize its fields with
- * default values.
- *
- * @param pkt packet
- * @param size wanted payload size
- * @return 0 if OK, AVERROR_xxx otherwise
- */
-int av_new_packet(AVPacket *pkt, int size);
-
-/**
- * Reduce packet size, correctly zeroing padding
+ * Free a packet.
  *
- * @param pkt packet
- * @param size new size
+ * @param pkt packet to free
  */
-void av_shrink_packet(AVPacket *pkt, int size);
+void av_free_packet(AVPacket *pkt);
 
 /**
- * Increase packet size, correctly zeroing padding
+ * Find a registered decoder with a matching codec ID.
  *
- * @param pkt packet
- * @param grow_by number of bytes by which to increase the size of the packet
+ * @param id AVCodecID of the requested decoder
+ * @return A decoder if one was found, NULL otherwise.
  */
-int av_grow_packet(AVPacket *pkt, int grow_by);
+AVCodec *avcodec_find_decoder(enum AVCodecID id);
 
 /**
- * Initialize a reference-counted packet from av_malloc()ed data.
+ * Decode the audio frame of size avpkt->size from avpkt->data into frame.
  *
- * @param pkt packet to be initialized. This function will set the data, size,
- *        buf and destruct fields, all others are left untouched.
- * @param data Data allocated by av_malloc() to be used as packet data. If this
- *        function returns successfully, the data is owned by the underlying AVBuffer.
- *        The caller may not access the data through other means.
- * @param size size of data in bytes, without the padding. I.e. the full buffer
- *        size is assumed to be size + FF_INPUT_BUFFER_PADDING_SIZE.
+ * Some decoders may support multiple frames in a single AVPacket. Such
+ * decoders would then just decode the first frame and the return value would be
+ * less than the packet size. In this case, avcodec_decode_audio4 has to be
+ * called again with an AVPacket containing the remaining data in order to
+ * decode the second frame, etc...  Even if no frames are returned, the packet
+ * needs to be fed to the decoder with remaining data until it is completely
+ * consumed or an error occurs.
  *
- * @return 0 on success, a negative AVERROR on error
- */
-int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size);
-
-/**
- * @warning This is a hack - the packet memory allocation stuff is broken. The
- * packet is allocated if it was not really allocated.
- */
-int av_dup_packet(AVPacket *pkt);
-
-/**
- * Copy packet, including contents
+ * Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input
+ * and output. This means that for some packets they will not immediately
+ * produce decoded output and need to be flushed at the end of decoding to get
+ * all the decoded data. Flushing is done by calling this function with packets
+ * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
+ * returning samples. It is safe to flush even those decoders that are not
+ * marked with CODEC_CAP_DELAY, then no samples will be returned.
  *
- * @return 0 on success, negative AVERROR on fail
- */
-int av_copy_packet(AVPacket *dst, const AVPacket *src);
-
-/**
- * Copy packet side data
+ * @warning The input buffer, avpkt->data must be FF_INPUT_BUFFER_PADDING_SIZE
+ *          larger than the actual read bytes because some optimized bitstream
+ *          readers read 32 or 64 bits at once and could read over the end.
  *
- * @return 0 on success, negative AVERROR on fail
+ * @param      avctx the codec context
+ * @param[out] frame The AVFrame in which to store decoded audio samples.
+ *                   The decoder will allocate a buffer for the decoded frame by
+ *                   calling the AVCodecContext.get_buffer2() callback.
+ *                   When AVCodecContext.refcounted_frames is set to 1, the frame is
+ *                   reference counted and the returned reference belongs to the
+ *                   caller. The caller must release the frame using av_frame_unref()
+ *                   when the frame is no longer needed. The caller may safely write
+ *                   to the frame if av_frame_is_writable() returns 1.
+ *                   When AVCodecContext.refcounted_frames is set to 0, the returned
+ *                   reference belongs to the decoder and is valid only until the
+ *                   next call to this function or until closing or flushing the
+ *                   decoder. The caller may not write to it.
+ * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is
+ *                           non-zero. Note that this field being set to zero
+ *                           does not mean that an error has occurred. For
+ *                           decoders with CODEC_CAP_DELAY set, no given decode
+ *                           call is guaranteed to produce a frame.
+ * @param[in]  avpkt The input AVPacket containing the input buffer.
+ *                   At least avpkt->data and avpkt->size should be set. Some
+ *                   decoders might also require additional fields to be set.
+ * @return A negative error code is returned if an error occurred during
+ *         decoding, otherwise the number of bytes consumed from the input
+ *         AVPacket is returned.
  */
-int av_copy_packet_side_data(AVPacket *dst, const AVPacket *src);
+int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame,
+                          int *got_frame_ptr, const AVPacket *avpkt);
 
 /**
- * Free a packet.
- *
- * @param pkt packet to free
- */
-void av_free_packet(AVPacket *pkt);
-
-/**
- * Allocate new information of a packet.
- *
- * @param pkt packet
- * @param type side information type
- * @param size side information size
- * @return pointer to fresh allocated data or NULL otherwise
- */
-uint8_t* av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
-                                 int size);
-
-/**
- * Shrink the already allocated side data buffer
- *
- * @param pkt packet
- * @param type side information type
- * @param size new side information size
- * @return 0 on success, < 0 on failure
- */
-int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
-                               int size);
-
-/**
- * Get side information from packet.
- *
- * @param pkt packet
- * @param type desired side information type
- * @param size pointer for side information size to store (optional)
- * @return pointer to data if present or NULL otherwise
- */
-uint8_t* av_packet_get_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
-                                 int *size);
-
-int av_packet_merge_side_data(AVPacket *pkt);
-
-int av_packet_split_side_data(AVPacket *pkt);
-
-/**
- * Pack a dictionary for use in side_data.
- *
- * @param dict The dictionary to pack.
- * @param size pointer to store the size of the returned data
- * @return pointer to data if successful, NULL otherwise
- */
-uint8_t *av_packet_pack_dictionary(AVDictionary *dict, int *size);
-/**
- * Unpack a dictionary from side_data.
- *
- * @param data data from side_data
- * @param size size of the data
- * @param dict the metadata storage dictionary
- * @return 0 on success, < 0 on failure
- */
-int av_packet_unpack_dictionary(const uint8_t *data, int size, AVDictionary **dict);
-
-
-/**
- * Convenience function to free all the side data stored.
- * All the other fields stay untouched.
- *
- * @param pkt packet
- */
-void av_packet_free_side_data(AVPacket *pkt);
-
-/**
- * Setup a new reference to the data described by a given packet
- *
- * If src is reference-counted, setup dst as a new reference to the
- * buffer in src. Otherwise allocate a new buffer in dst and copy the
- * data from src into it.
- *
- * All the other fields are copied from src.
- *
- * @see av_packet_unref
- *
- * @param dst Destination packet
- * @param src Source packet
- *
- * @return 0 on success, a negative AVERROR on error.
- */
-int av_packet_ref(AVPacket *dst, const AVPacket *src);
-
-/**
- * Wipe the packet.
- *
- * Unreference the buffer referenced by the packet and reset the
- * remaining packet fields to their default values.
- *
- * @param pkt The packet to be unreferenced.
- */
-void av_packet_unref(AVPacket *pkt);
-
-/**
- * Move every field in src to dst and reset src.
- *
- * @see av_packet_unref
- *
- * @param src Source packet, will be reset
- * @param dst Destination packet
- */
-void av_packet_move_ref(AVPacket *dst, AVPacket *src);
-
-/**
- * Copy only "properties" fields from src to dst.
- *
- * Properties for the purpose of this function are all the fields
- * beside those related to the packet data (buf, data, size)
- *
- * @param dst Destination packet
- * @param src Source packet
- *
- * @return 0 on success AVERROR on failure.
- *
- */
-int av_packet_copy_props(AVPacket *dst, const AVPacket *src);
-
-/**
- * Convert valid timing fields (timestamps / durations) in a packet from one
- * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be
- * ignored.
- *
- * @param pkt packet on which the conversion will be performed
- * @param tb_src source timebase, in which the timing fields in pkt are
- *               expressed
- * @param tb_dst destination timebase, to which the timing fields will be
- *               converted
- */
-void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst);
-
-/**
- * @}
- */
-
-/**
- * @addtogroup lavc_decoding
- * @{
- */
-
-/**
- * Find a registered decoder with a matching codec ID.
- *
- * @param id AVCodecID of the requested decoder
- * @return A decoder if one was found, NULL otherwise.
- */
-AVCodec *avcodec_find_decoder(enum AVCodecID id);
-
-/**
- * Find a registered decoder with the specified name.
- *
- * @param name name of the requested decoder
- * @return A decoder if one was found, NULL otherwise.
- */
-AVCodec *avcodec_find_decoder_by_name(const char *name);
-
-#if FF_API_GET_BUFFER
-attribute_deprecated int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic);
-attribute_deprecated void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic);
-attribute_deprecated int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic);
-#endif
-
-/**
- * The default callback for AVCodecContext.get_buffer2(). It is made public so
- * it can be called by custom get_buffer2() implementations for decoders without
- * CODEC_CAP_DR1 set.
- */
-int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags);
-
-#if FF_API_EMU_EDGE
-/**
- * Return the amount of padding in pixels which the get_buffer callback must
- * provide around the edge of the image for codecs which do not have the
- * CODEC_FLAG_EMU_EDGE flag.
- *
- * @return Required padding in pixels.
- *
- * @deprecated CODEC_FLAG_EMU_EDGE is deprecated, so this function is no longer
- * needed
- */
-attribute_deprecated
-unsigned avcodec_get_edge_width(void);
-#endif
-
-/**
- * Modify width and height values so that they will result in a memory
- * buffer that is acceptable for the codec if you do not use any horizontal
- * padding.
- *
- * May only be used if a codec with CODEC_CAP_DR1 has been opened.
- */
-void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height);
-
-/**
- * Modify width and height values so that they will result in a memory
- * buffer that is acceptable for the codec if you also ensure that all
- * line sizes are a multiple of the respective linesize_align[i].
- *
- * May only be used if a codec with CODEC_CAP_DR1 has been opened.
- */
-void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
-                               int linesize_align[AV_NUM_DATA_POINTERS]);
-
-/**
- * Converts AVChromaLocation to swscale x/y chroma position.
- *
- * The positions represent the chroma (0,0) position in a coordinates system
- * with luma (0,0) representing the origin and luma(1,1) representing 256,256
- *
- * @param xpos  horizontal chroma sample position
- * @param ypos  vertical   chroma sample position
- */
-int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos);
-
-/**
- * Converts swscale x/y chroma position to AVChromaLocation.
- *
- * The positions represent the chroma (0,0) position in a coordinates system
- * with luma (0,0) representing the origin and luma(1,1) representing 256,256
- *
- * @param xpos  horizontal chroma sample position
- * @param ypos  vertical   chroma sample position
- */
-enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos);
-
-#if FF_API_OLD_DECODE_AUDIO
-/**
- * Wrapper function which calls avcodec_decode_audio4.
- *
- * @deprecated Use avcodec_decode_audio4 instead.
- *
- * Decode the audio frame of size avpkt->size from avpkt->data into samples.
- * Some decoders may support multiple frames in a single AVPacket, such
- * decoders would then just decode the first frame. In this case,
- * avcodec_decode_audio3 has to be called again with an AVPacket that contains
- * the remaining data in order to decode the second frame etc.
- * If no frame
- * could be outputted, frame_size_ptr is zero. Otherwise, it is the
- * decompressed frame size in bytes.
- *
- * @warning You must set frame_size_ptr to the allocated size of the
- * output buffer before calling avcodec_decode_audio3().
- *
- * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than
- * the actual read bytes because some optimized bitstream readers read 32 or 64
- * bits at once and could read over the end.
- *
- * @warning The end of the input buffer avpkt->data should be set to 0 to ensure that
- * no overreading happens for damaged MPEG streams.
- *
- * @warning You must not provide a custom get_buffer() when using
- * avcodec_decode_audio3().  Doing so will override it with
- * avcodec_default_get_buffer.  Use avcodec_decode_audio4() instead,
- * which does allow the application to provide a custom get_buffer().
- *
- * @note You might have to align the input buffer avpkt->data and output buffer
- * samples. The alignment requirements depend on the CPU: On some CPUs it isn't
- * necessary at all, on others it won't work at all if not aligned and on others
- * it will work but it will have an impact on performance.
- *
- * In practice, avpkt->data should have 4 byte alignment at minimum and
- * samples should be 16 byte aligned unless the CPU doesn't need it
- * (AltiVec and SSE do).
- *
- * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay
- * between input and output, these need to be fed with avpkt->data=NULL,
- * avpkt->size=0 at the end to return the remaining frames.
- *
- * @param avctx the codec context
- * @param[out] samples the output buffer, sample type in avctx->sample_fmt
- *                     If the sample format is planar, each channel plane will
- *                     be the same size, with no padding between channels.
- * @param[in,out] frame_size_ptr the output buffer size in bytes
- * @param[in] avpkt The input AVPacket containing the input buffer.
- *            You can create such packet with av_init_packet() and by then setting
- *            data and size, some decoders might in addition need other fields.
- *            All decoders are designed to use the least fields possible though.
- * @return On error a negative value is returned, otherwise the number of bytes
- * used or zero if no frame data was decompressed (used) from the input AVPacket.
- */
-attribute_deprecated int avcodec_decode_audio3(AVCodecContext *avctx, int16_t *samples,
-                         int *frame_size_ptr,
-                         AVPacket *avpkt);
-#endif
-
-/**
- * Decode the audio frame of size avpkt->size from avpkt->data into frame.
- *
- * Some decoders may support multiple frames in a single AVPacket. Such
- * decoders would then just decode the first frame and the return value would be
- * less than the packet size. In this case, avcodec_decode_audio4 has to be
- * called again with an AVPacket containing the remaining data in order to
- * decode the second frame, etc...  Even if no frames are returned, the packet
- * needs to be fed to the decoder with remaining data until it is completely
- * consumed or an error occurs.
- *
- * Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input
- * and output. This means that for some packets they will not immediately
- * produce decoded output and need to be flushed at the end of decoding to get
- * all the decoded data. Flushing is done by calling this function with packets
- * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
- * returning samples. It is safe to flush even those decoders that are not
- * marked with CODEC_CAP_DELAY, then no samples will be returned.
- *
- * @warning The input buffer, avpkt->data must be FF_INPUT_BUFFER_PADDING_SIZE
- *          larger than the actual read bytes because some optimized bitstream
- *          readers read 32 or 64 bits at once and could read over the end.
- *
- * @param      avctx the codec context
- * @param[out] frame The AVFrame in which to store decoded audio samples.
- *                   The decoder will allocate a buffer for the decoded frame by
- *                   calling the AVCodecContext.get_buffer2() callback.
- *                   When AVCodecContext.refcounted_frames is set to 1, the frame is
- *                   reference counted and the returned reference belongs to the
- *                   caller. The caller must release the frame using av_frame_unref()
- *                   when the frame is no longer needed. The caller may safely write
- *                   to the frame if av_frame_is_writable() returns 1.
- *                   When AVCodecContext.refcounted_frames is set to 0, the returned
- *                   reference belongs to the decoder and is valid only until the
- *                   next call to this function or until closing or flushing the
- *                   decoder. The caller may not write to it.
- * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is
- *                           non-zero. Note that this field being set to zero
- *                           does not mean that an error has occurred. For
- *                           decoders with CODEC_CAP_DELAY set, no given decode
- *                           call is guaranteed to produce a frame.
- * @param[in]  avpkt The input AVPacket containing the input buffer.
- *                   At least avpkt->data and avpkt->size should be set. Some
- *                   decoders might also require additional fields to be set.
- * @return A negative error code is returned if an error occurred during
- *         decoding, otherwise the number of bytes consumed from the input
- *         AVPacket is returned.
- */
-int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame,
-                          int *got_frame_ptr, const AVPacket *avpkt);
-
-/**
- * Decode the video frame of size avpkt->size from avpkt->data into picture.
- * Some decoders may support multiple frames in a single AVPacket, such
- * decoders would then just decode the first frame.
+ * Decode the video frame of size avpkt->size from avpkt->data into picture.
+ * Some decoders may support multiple frames in a single AVPacket, such
+ * decoders would then just decode the first frame.
  *
  * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than
  * the actual read bytes because some optimized bitstream readers read 32 or 64
@@ -4069,34 +893,6 @@ int avcodec_decode_video2(AVCodecContext
                          const AVPacket *avpkt);
 
 /**
- * Decode a subtitle message.
- * Return a negative value on error, otherwise return the number of bytes used.
- * If no subtitle could be decompressed, got_sub_ptr is zero.
- * Otherwise, the subtitle is stored in *sub.
- * Note that CODEC_CAP_DR1 is not available for subtitle codecs. This is for
- * simplicity, because the performance difference is expect to be negligible
- * and reusing a get_buffer written for video codecs would probably perform badly
- * due to a potentially very different allocation pattern.
- *
- * Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input
- * and output. This means that for some packets they will not immediately
- * produce decoded output and need to be flushed at the end of decoding to get
- * all the decoded data. Flushing is done by calling this function with packets
- * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
- * returning subtitles. It is safe to flush even those decoders that are not
- * marked with CODEC_CAP_DELAY, then no subtitles will be returned.
- *
- * @param avctx the codec context
- * @param[out] sub The Preallocated AVSubtitle in which the decoded subtitle will be stored,
- *                 must be freed with avsubtitle_free if *got_sub_ptr is set.
- * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.
- * @param[in] avpkt The input AVPacket containing the input buffer.
- */
-int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
-                            int *got_sub_ptr,
-                            AVPacket *avpkt);
-
-/**
  * @defgroup lavc_parsing Frame parsing
  * @{
  */
@@ -4106,344 +902,21 @@ enum AVPictureStructure {
     AV_PICTURE_STRUCTURE_TOP_FIELD,    //< coded as top field
     AV_PICTURE_STRUCTURE_BOTTOM_FIELD, //< coded as bottom field
     AV_PICTURE_STRUCTURE_FRAME,        //< coded as frame
-};
-
-typedef struct AVCodecParserContext {
-    void *priv_data;
-    struct AVCodecParser *parser;
-    int64_t frame_offset; /* offset of the current frame */
-    int64_t cur_offset; /* current offset
-                           (incremented by each av_parser_parse()) */
-    int64_t next_frame_offset; /* offset of the next frame */
-    /* video info */
-    int pict_type; /* XXX: Put it back in AVCodecContext. */
-    /**
-     * This field is used for proper frame duration computation in lavf.
-     * It signals, how much longer the frame duration of the current frame
-     * is compared to normal frame duration.
-     *
-     * frame_duration = (1 + repeat_pict) * time_base
-     *
-     * It is used by codecs like H.264 to display telecined material.
-     */
-    int repeat_pict; /* XXX: Put it back in AVCodecContext. */
-    int64_t pts;     /* pts of the current frame */
-    int64_t dts;     /* dts of the current frame */
-
-    /* private data */
-    int64_t last_pts;
-    int64_t last_dts;
-    int fetch_timestamp;
-
-#define AV_PARSER_PTS_NB 4
-    int cur_frame_start_index;
-    int64_t cur_frame_offset[AV_PARSER_PTS_NB];
-    int64_t cur_frame_pts[AV_PARSER_PTS_NB];
-    int64_t cur_frame_dts[AV_PARSER_PTS_NB];
-
-    int flags;
-#define PARSER_FLAG_COMPLETE_FRAMES           0x0001
-#define PARSER_FLAG_ONCE                      0x0002
-/// Set if the parser has a valid file offset
-#define PARSER_FLAG_FETCHED_OFFSET            0x0004
-#define PARSER_FLAG_USE_CODEC_TS              0x1000
-
-    int64_t offset;      ///< byte offset from starting packet start
-    int64_t cur_frame_end[AV_PARSER_PTS_NB];
-
-    /**
-     * Set by parser to 1 for key frames and 0 for non-key frames.
-     * It is initialized to -1, so if the parser doesn't set this flag,
-     * old-style fallback using AV_PICTURE_TYPE_I picture type as key frames
-     * will be used.
-     */
-    int key_frame;
-
-    /**
-     * Time difference in stream time base units from the pts of this
-     * packet to the point at which the output from the decoder has converged
-     * independent from the availability of previous frames. That is, the
-     * frames are virtually identical no matter if decoding started from
-     * the very first frame or from this keyframe.
-     * Is AV_NOPTS_VALUE if unknown.
-     * This field is not the display duration of the current frame.
-     * This field has no meaning if the packet does not have AV_PKT_FLAG_KEY
-     * set.
-     *
-     * The purpose of this field is to allow seeking in streams that have no
-     * keyframes in the conventional sense. It corresponds to the
-     * recovery point SEI in H.264 and match_time_delta in NUT. It is also
-     * essential for some types of subtitle streams to ensure that all
-     * subtitles are correctly displayed after seeking.
-     */
-    int64_t convergence_duration;
-
-    // Timestamp generation support:
-    /**
-     * Synchronization point for start of timestamp generation.
-     *
-     * Set to >0 for sync point, 0 for no sync point and <0 for undefined
-     * (default).
-     *
-     * For example, this corresponds to presence of H.264 buffering period
-     * SEI message.
-     */
-    int dts_sync_point;
-
-    /**
-     * Offset of the current timestamp against last timestamp sync point in
-     * units of AVCodecContext.time_base.
-     *
-     * Set to INT_MIN when dts_sync_point unused. Otherwise, it must
-     * contain a valid timestamp offset.
-     *
-     * Note that the timestamp of sync point has usually a nonzero
-     * dts_ref_dts_delta, which refers to the previous sync point. Offset of
-     * the next frame after timestamp sync point will be usually 1.
-     *
-     * For example, this corresponds to H.264 cpb_removal_delay.
-     */
-    int dts_ref_dts_delta;
-
-    /**
-     * Presentation delay of current frame in units of AVCodecContext.time_base.
-     *
-     * Set to INT_MIN when dts_sync_point unused. Otherwise, it must
-     * contain valid non-negative timestamp delta (presentation time of a frame
-     * must not lie in the past).
-     *
-     * This delay represents the difference between decoding and presentation
-     * time of the frame.
-     *
-     * For example, this corresponds to H.264 dpb_output_delay.
-     */
-    int pts_dts_delta;
-
-    /**
-     * Position of the packet in file.
-     *
-     * Analogous to cur_frame_pts/dts
-     */
-    int64_t cur_frame_pos[AV_PARSER_PTS_NB];
-
-    /**
-     * Byte position of currently parsed frame in stream.
-     */
-    int64_t pos;
-
-    /**
-     * Previous frame byte position.
-     */
-    int64_t last_pos;
-
-    /**
-     * Duration of the current frame.
-     * For audio, this is in units of 1 / AVCodecContext.sample_rate.
-     * For all other types, this is in units of AVCodecContext.time_base.
-     */
-    int duration;
-
-    enum AVFieldOrder field_order;
-
-    /**
-     * Indicate whether a picture is coded as a frame, top field or bottom field.
-     *
-     * For example, H.264 field_pic_flag equal to 0 corresponds to
-     * AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
-     * equal to 1 and bottom_field_flag equal to 0 corresponds to
-     * AV_PICTURE_STRUCTURE_TOP_FIELD.
-     */
-    enum AVPictureStructure picture_structure;
-
-    /**
-     * Picture number incremented in presentation or output order.
-     * This field may be reinitialized at the first picture of a new sequence.
-     *
-     * For example, this corresponds to H.264 PicOrderCnt.
-     */
-    int output_picture_number;
-} AVCodecParserContext;
-
-typedef struct AVCodecParser {
-    int codec_ids[5]; /* several codec IDs are permitted */
-    int priv_data_size;
-    int (*parser_init)(AVCodecParserContext *s);
-    int (*parser_parse)(AVCodecParserContext *s,
-                        AVCodecContext *avctx,
-                        const uint8_t **poutbuf, int *poutbuf_size,
-                        const uint8_t *buf, int buf_size);
-    void (*parser_close)(AVCodecParserContext *s);
-    int (*split)(AVCodecContext *avctx, const uint8_t *buf, int buf_size);
-    struct AVCodecParser *next;
-} AVCodecParser;
-
-AVCodecParser *av_parser_next(AVCodecParser *c);
-
-void av_register_codec_parser(AVCodecParser *parser);
-AVCodecParserContext *av_parser_init(int codec_id);
-
-/**
- * Parse a packet.
- *
- * @param s             parser context.
- * @param avctx         codec context.
- * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.
- * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.
- * @param buf           input buffer.
- * @param buf_size      input length, to signal EOF, this should be 0 (so that the last frame can be output).
- * @param pts           input presentation timestamp.
- * @param dts           input decoding timestamp.
- * @param pos           input byte position in stream.
- * @return the number of bytes of the input bitstream used.
- *
- * Example:
- * @code
- *   while(in_len){
- *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
- *                                        in_data, in_len,
- *                                        pts, dts, pos);
- *       in_data += len;
- *       in_len  -= len;
- *
- *       if(size)
- *          decode_frame(data, size);
- *   }
- * @endcode
- */
-int av_parser_parse2(AVCodecParserContext *s,
-                     AVCodecContext *avctx,
-                     uint8_t **poutbuf, int *poutbuf_size,
-                     const uint8_t *buf, int buf_size,
-                     int64_t pts, int64_t dts,
-                     int64_t pos);
-
-/**
- * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed
- * @deprecated use AVBitStreamFilter
- */
-int av_parser_change(AVCodecParserContext *s,
-                     AVCodecContext *avctx,
-                     uint8_t **poutbuf, int *poutbuf_size,
-                     const uint8_t *buf, int buf_size, int keyframe);
-void av_parser_close(AVCodecParserContext *s);
-
-/**
- * @}
- * @}
- */
-
-/**
- * @addtogroup lavc_encoding
- * @{
- */
-
-/**
- * Find a registered encoder with a matching codec ID.
- *
- * @param id AVCodecID of the requested encoder
- * @return An encoder if one was found, NULL otherwise.
- */
-AVCodec *avcodec_find_encoder(enum AVCodecID id);
-
-/**
- * Find a registered encoder with the specified name.
- *
- * @param name name of the requested encoder
- * @return An encoder if one was found, NULL otherwise.
- */
-AVCodec *avcodec_find_encoder_by_name(const char *name);
-
-#if FF_API_OLD_ENCODE_AUDIO
-/**
- * Encode an audio frame from samples into buf.
- *
- * @deprecated Use avcodec_encode_audio2 instead.
- *
- * @note The output buffer should be at least FF_MIN_BUFFER_SIZE bytes large.
- * However, for codecs with avctx->frame_size equal to 0 (e.g. PCM) the user
- * will know how much space is needed because it depends on the value passed
- * in buf_size as described below. In that case a lower value can be used.
- *
- * @param avctx the codec context
- * @param[out] buf the output buffer
- * @param[in] buf_size the output buffer size
- * @param[in] samples the input buffer containing the samples
- * The number of samples read from this buffer is frame_size*channels,
- * both of which are defined in avctx.
- * For codecs which have avctx->frame_size equal to 0 (e.g. PCM) the number of
- * samples read from samples is equal to:
- * buf_size * 8 / (avctx->channels * av_get_bits_per_sample(avctx->codec_id))
- * This also implies that av_get_bits_per_sample() must not return 0 for these
- * codecs.
- * @return On error a negative value is returned, on success zero or the number
- * of bytes used to encode the data read from the input buffer.
- */
-int attribute_deprecated avcodec_encode_audio(AVCodecContext *avctx,
-                                              uint8_t *buf, int buf_size,
-                                              const short *samples);
-#endif
-
-/**
- * Encode a frame of audio.
- *
- * Takes input samples from frame and writes the next output packet, if
- * available, to avpkt. The output packet does not necessarily contain data for
- * the most recent frame, as encoders can delay, split, and combine input frames
- * internally as needed.
- *
- * @param avctx     codec context
- * @param avpkt     output AVPacket.
- *                  The user can supply an output buffer by setting
- *                  avpkt->data and avpkt->size prior to calling the
- *                  function, but if the size of the user-provided data is not
- *                  large enough, encoding will fail. If avpkt->data and
- *                  avpkt->size are set, avpkt->destruct must also be set. All
- *                  other AVPacket fields will be reset by the encoder using
- *                  av_init_packet(). If avpkt->data is NULL, the encoder will
- *                  allocate it. The encoder will set avpkt->size to the size
- *                  of the output packet.
- *
- *                  If this function fails or produces no output, avpkt will be
- *                  freed using av_free_packet() (i.e. avpkt->destruct will be
- *                  called to free the user supplied buffer).
- * @param[in] frame AVFrame containing the raw audio data to be encoded.
- *                  May be NULL when flushing an encoder that has the
- *                  CODEC_CAP_DELAY capability set.
- *                  If CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
- *                  can have any number of samples.
- *                  If it is not set, frame->nb_samples must be equal to
- *                  avctx->frame_size for all frames except the last.
- *                  The final frame may be smaller than avctx->frame_size.
- * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
- *                            output packet is non-empty, and to 0 if it is
- *                            empty. If the function returns an error, the
- *                            packet can be assumed to be invalid, and the
- *                            value of got_packet_ptr is undefined and should
- *                            not be used.
- * @return          0 on success, negative error code on failure
- */
-int avcodec_encode_audio2(AVCodecContext *avctx, AVPacket *avpkt,
-                          const AVFrame *frame, int *got_packet_ptr);
+};
+
+typedef struct AVCodecParserContext {
+    int dummy;
+} AVCodecParserContext;
+
+typedef struct AVCodecParser;
 
-#if FF_API_OLD_ENCODE_VIDEO
 /**
- * @deprecated use avcodec_encode_video2() instead.
- *
- * Encode a video frame from pict into buf.
- * The input picture should be
- * stored using a specific format, namely avctx.pix_fmt.
+ * Find a registered encoder with a matching codec ID.
  *
- * @param avctx the codec context
- * @param[out] buf the output buffer for the bitstream of encoded frame
- * @param[in] buf_size the size of the output buffer in bytes
- * @param[in] pict the input picture to encode
- * @return On error a negative value is returned, on success zero or the number
- * of bytes used from the output buffer.
+ * @param id AVCodecID of the requested encoder
+ * @return An encoder if one was found, NULL otherwise.
  */
-attribute_deprecated
-int avcodec_encode_video(AVCodecContext *avctx, uint8_t *buf, int buf_size,
-                         const AVFrame *pict);
-#endif
+AVCodec *avcodec_find_encoder(enum AVCodecID id);
 
 /**
  * Encode a frame of video.
@@ -4482,141 +955,6 @@ int avcodec_encode_video(AVCodecContext
 int avcodec_encode_video2(AVCodecContext *avctx, AVPacket *avpkt,
                           const AVFrame *frame, int *got_packet_ptr);
 
-int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size,
-                            const AVSubtitle *sub);
-
-
-/**
- * @}
- */
-
-#if FF_API_AVCODEC_RESAMPLE
-/**
- * @defgroup lavc_resample Audio resampling
- * @ingroup libavc
- * @deprecated use libswresample instead
- *
- * @{
- */
-struct ReSampleContext;
-struct AVResampleContext;
-
-typedef struct ReSampleContext ReSampleContext;
-
-/**
- *  Initialize audio resampling context.
- *
- * @param output_channels  number of output channels
- * @param input_channels   number of input channels
- * @param output_rate      output sample rate
- * @param input_rate       input sample rate
- * @param sample_fmt_out   requested output sample format
- * @param sample_fmt_in    input sample format
- * @param filter_length    length of each FIR filter in the filterbank relative to the cutoff frequency
- * @param log2_phase_count log2 of the number of entries in the polyphase filterbank
- * @param linear           if 1 then the used FIR filter will be linearly interpolated
-                           between the 2 closest, if 0 the closest will be used
- * @param cutoff           cutoff frequency, 1.0 corresponds to half the output sampling rate
- * @return allocated ReSampleContext, NULL if error occurred
- */
-attribute_deprecated
-ReSampleContext *av_audio_resample_init(int output_channels, int input_channels,
-                                        int output_rate, int input_rate,
-                                        enum AVSampleFormat sample_fmt_out,
-                                        enum AVSampleFormat sample_fmt_in,
-                                        int filter_length, int log2_phase_count,
-                                        int linear, double cutoff);
-
-attribute_deprecated
-int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples);
-
-/**
- * Free resample context.
- *
- * @param s a non-NULL pointer to a resample context previously
- *          created with av_audio_resample_init()
- */
-attribute_deprecated
-void audio_resample_close(ReSampleContext *s);
-
-
-/**
- * Initialize an audio resampler.
- * Note, if either rate is not an integer then simply scale both rates up so they are.
- * @param filter_length length of each FIR filter in the filterbank relative to the cutoff freq
- * @param log2_phase_count log2 of the number of entries in the polyphase filterbank
- * @param linear If 1 then the used FIR filter will be linearly interpolated
-                 between the 2 closest, if 0 the closest will be used
- * @param cutoff cutoff frequency, 1.0 corresponds to half the output sampling rate
- */
-attribute_deprecated
-struct AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);
-
-/**
- * Resample an array of samples using a previously configured context.
- * @param src an array of unconsumed samples
- * @param consumed the number of samples of src which have been consumed are returned here
- * @param src_size the number of unconsumed samples available
- * @param dst_size the amount of space in samples available in dst
- * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.
- * @return the number of samples written in dst or -1 if an error occurred
- */
-attribute_deprecated
-int av_resample(struct AVResampleContext *c, short *dst, short *src, int *consumed, int src_size, int dst_size, int update_ctx);
-
-
-/**
- * Compensate samplerate/timestamp drift. The compensation is done by changing
- * the resampler parameters, so no audible clicks or similar distortions occur
- * @param compensation_distance distance in output samples over which the compensation should be performed
- * @param sample_delta number of output samples which should be output less
- *
- * example: av_resample_compensate(c, 10, 500)
- * here instead of 510 samples only 500 samples would be output
- *
- * note, due to rounding the actual compensation might be slightly different,
- * especially if the compensation_distance is large and the in_rate used during init is small
- */
-attribute_deprecated
-void av_resample_compensate(struct AVResampleContext *c, int sample_delta, int compensation_distance);
-attribute_deprecated
-void av_resample_close(struct AVResampleContext *c);
-
-/**
- * @}
- */
-#endif
-
-/**
- * @addtogroup lavc_picture
- * @{
- */
-
-/**
- * Allocate memory for the pixels of a picture and setup the AVPicture
- * fields for it.
- *
- * Call avpicture_free() to free it.
- *
- * @param picture            the picture structure to be filled in
- * @param pix_fmt            the pixel format of the picture
- * @param width              the width of the picture
- * @param height             the height of the picture
- * @return zero if successful, a negative error code otherwise
- *
- * @see av_image_alloc(), avpicture_fill()
- */
-int avpicture_alloc(AVPicture *picture, enum AVPixelFormat pix_fmt, int width, int height);
-
-/**
- * Free a picture previously allocated by avpicture_alloc().
- * The data buffer used by the AVPicture is freed, but the AVPicture structure
- * itself is not.
- *
- * @param picture the AVPicture to be freed
- */
-void avpicture_free(AVPicture *picture);
-
 /**
  * Setup the picture fields based on the specified image parameters
  * and the provided image data buffer.
@@ -4644,28 +982,6 @@ int avpicture_fill(AVPicture *picture, c
                    enum AVPixelFormat pix_fmt, int width, int height);
 
 /**
- * Copy pixel data from an AVPicture into a buffer.
- *
- * avpicture_get_size() can be used to compute the required size for
- * the buffer to fill.
- *
- * @param src        source picture with filled data
- * @param pix_fmt    picture pixel format
- * @param width      picture width
- * @param height     picture height
- * @param dest       destination buffer
- * @param dest_size  destination buffer size in bytes
- * @return the number of bytes written to dest, or a negative value
- * (error code) on error, for example if the destination buffer is not
- * big enough
- *
- * @see av_image_copy_to_buffer()
- */
-int avpicture_layout(const AVPicture *src, enum AVPixelFormat pix_fmt,
-                     int width, int height,
-                     unsigned char *dest, int dest_size);
-
-/**
  * Calculate the size in bytes that a picture of the given width and height
  * would occupy if stored in the given picture format.
  *
@@ -4679,473 +995,4 @@ int avpicture_layout(const AVPicture *sr
  */
 int avpicture_get_size(enum AVPixelFormat pix_fmt, int width, int height);
 
-#if FF_API_DEINTERLACE
-/**
- *  deinterlace - if not supported return -1
- *
- * @deprecated - use yadif (in libavfilter) instead
- */
-attribute_deprecated
-int avpicture_deinterlace(AVPicture *dst, const AVPicture *src,
-                          enum AVPixelFormat pix_fmt, int width, int height);
-#endif
-/**
- * Copy image src to dst. Wraps av_image_copy().
- */
-void av_picture_copy(AVPicture *dst, const AVPicture *src,
-                     enum AVPixelFormat pix_fmt, int width, int height);
-
-/**
- * Crop image top and left side.
- */
-int av_picture_crop(AVPicture *dst, const AVPicture *src,
-                    enum AVPixelFormat pix_fmt, int top_band, int left_band);
-
-/**
- * Pad image.
- */
-int av_picture_pad(AVPicture *dst, const AVPicture *src, int height, int width, enum AVPixelFormat pix_fmt,
-            int padtop, int padbottom, int padleft, int padright, int *color);
-
-/**
- * @}
- */
-
-/**
- * @defgroup lavc_misc Utility functions
- * @ingroup libavc
- *
- * Miscellaneous utility functions related to both encoding and decoding
- * (or neither).
- * @{
- */
-
-/**
- * @defgroup lavc_misc_pixfmt Pixel formats
- *
- * Functions for working with pixel formats.
- * @{
- */
-
-/**
- * Utility function to access log2_chroma_w log2_chroma_h from
- * the pixel format AVPixFmtDescriptor.
- *
- * This function asserts that pix_fmt is valid. See av_pix_fmt_get_chroma_sub_sample
- * for one that returns a failure code and continues in case of invalid
- * pix_fmts.
- *
- * @param[in]  pix_fmt the pixel format
- * @param[out] h_shift store log2_chroma_w
- * @param[out] v_shift store log2_chroma_h
- *
- * @see av_pix_fmt_get_chroma_sub_sample
- */
-
-void avcodec_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift);
-
-/**
- * Return a value representing the fourCC code associated to the
- * pixel format pix_fmt, or 0 if no associated fourCC code can be
- * found.
- */
-unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt);
-
-/**
- * @deprecated see av_get_pix_fmt_loss()
- */
-int avcodec_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt,
-                             int has_alpha);
-
-/**
- * Find the best pixel format to convert to given a certain source pixel
- * format.  When converting from one pixel format to another, information loss
- * may occur.  For example, when converting from RGB24 to GRAY, the color
- * information will be lost. Similarly, other losses occur when converting from
- * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of
- * the given pixel formats should be used to suffer the least amount of loss.
- * The pixel formats from which it chooses one, are determined by the
- * pix_fmt_list parameter.
- *
- *
- * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from
- * @param[in] src_pix_fmt source pixel format
- * @param[in] has_alpha Whether the source pixel format alpha channel is used.
- * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.
- * @return The best pixel format to convert to or -1 if none was found.
- */
-enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list,
-                                            enum AVPixelFormat src_pix_fmt,
-                                            int has_alpha, int *loss_ptr);
-
-/**
- * @deprecated see av_find_best_pix_fmt_of_2()
- */
-enum AVPixelFormat avcodec_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2,
-                                            enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr);
-
-attribute_deprecated
-#if AV_HAVE_INCOMPATIBLE_LIBAV_ABI
-enum AVPixelFormat avcodec_find_best_pix_fmt2(const enum AVPixelFormat *pix_fmt_list,
-                                              enum AVPixelFormat src_pix_fmt,
-                                              int has_alpha, int *loss_ptr);
-#else
-enum AVPixelFormat avcodec_find_best_pix_fmt2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2,
-                                            enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr);
-#endif
-
-
-enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat * fmt);
-
-/**
- * @}
- */
-
-#if FF_API_SET_DIMENSIONS
-/**
- * @deprecated this function is not supposed to be used from outside of lavc
- */
-attribute_deprecated
-void avcodec_set_dimensions(AVCodecContext *s, int width, int height);
-#endif
-
-/**
- * Put a string representing the codec tag codec_tag in buf.
- *
- * @param buf       buffer to place codec tag in
- * @param buf_size size in bytes of buf
- * @param codec_tag codec tag to assign
- * @return the length of the string that would have been generated if
- * enough space had been available, excluding the trailing null
- */
-size_t av_get_codec_tag_string(char *buf, size_t buf_size, unsigned int codec_tag);
-
-void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode);
-
-/**
- * Return a name for the specified profile, if available.
- *
- * @param codec the codec that is searched for the given profile
- * @param profile the profile value for which a name is requested
- * @return A name for the profile if found, NULL otherwise.
- */
-const char *av_get_profile_name(const AVCodec *codec, int profile);
-
-int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2),void *arg, int *ret, int count, int size);
-int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int, int),void *arg, int *ret, int count);
-//FIXME func typedef
-
-/**
- * Fill AVFrame audio data and linesize pointers.
- *
- * The buffer buf must be a preallocated buffer with a size big enough
- * to contain the specified samples amount. The filled AVFrame data
- * pointers will point to this buffer.
- *
- * AVFrame extended_data channel pointers are allocated if necessary for
- * planar audio.
- *
- * @param frame       the AVFrame
- *                    frame->nb_samples must be set prior to calling the
- *                    function. This function fills in frame->data,
- *                    frame->extended_data, frame->linesize[0].
- * @param nb_channels channel count
- * @param sample_fmt  sample format
- * @param buf         buffer to use for frame data
- * @param buf_size    size of buffer
- * @param align       plane size sample alignment (0 = default)
- * @return            >=0 on success, negative error code on failure
- * @todo return the size in bytes required to store the samples in
- * case of success, at the next libavutil bump
- */
-int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,
-                             enum AVSampleFormat sample_fmt, const uint8_t *buf,
-                             int buf_size, int align);
-
-/**
- * Reset the internal decoder state / flush internal buffers. Should be called
- * e.g. when seeking or when switching to a different stream.
- *
- * @note when refcounted frames are not used (i.e. avctx->refcounted_frames is 0),
- * this invalidates the frames previously returned from the decoder. When
- * refcounted frames are used, the decoder just releases any references it might
- * keep internally, but the caller's reference remains valid.
- */
-void avcodec_flush_buffers(AVCodecContext *avctx);
-
-/**
- * Return codec bits per sample.
- *
- * @param[in] codec_id the codec
- * @return Number of bits per sample or zero if unknown for the given codec.
- */
-int av_get_bits_per_sample(enum AVCodecID codec_id);
-
-/**
- * Return the PCM codec associated with a sample format.
- * @param be  endianness, 0 for little, 1 for big,
- *            -1 (or anything else) for native
- * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
- */
-enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be);
-
-/**
- * Return codec bits per sample.
- * Only return non-zero if the bits per sample is exactly correct, not an
- * approximation.
- *
- * @param[in] codec_id the codec
- * @return Number of bits per sample or zero if unknown for the given codec.
- */
-int av_get_exact_bits_per_sample(enum AVCodecID codec_id);
-
-/**
- * Return audio frame duration.
- *
- * @param avctx        codec context
- * @param frame_bytes  size of the frame, or 0 if unknown
- * @return             frame duration, in samples, if known. 0 if not able to
- *                     determine.
- */
-int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes);
-
-
-typedef struct AVBitStreamFilterContext {
-    void *priv_data;
-    struct AVBitStreamFilter *filter;
-    AVCodecParserContext *parser;
-    struct AVBitStreamFilterContext *next;
-} AVBitStreamFilterContext;
-
-
-typedef struct AVBitStreamFilter {
-    const char *name;
-    int priv_data_size;
-    int (*filter)(AVBitStreamFilterContext *bsfc,
-                  AVCodecContext *avctx, const char *args,
-                  uint8_t **poutbuf, int *poutbuf_size,
-                  const uint8_t *buf, int buf_size, int keyframe);
-    void (*close)(AVBitStreamFilterContext *bsfc);
-    struct AVBitStreamFilter *next;
-} AVBitStreamFilter;
-
-/**
- * Register a bitstream filter.
- *
- * The filter will be accessible to the application code through
- * av_bitstream_filter_next() or can be directly initialized with
- * av_bitstream_filter_init().
- *
- * @see avcodec_register_all()
- */
-void av_register_bitstream_filter(AVBitStreamFilter *bsf);
-
-/**
- * Create and initialize a bitstream filter context given a bitstream
- * filter name.
- *
- * The returned context must be freed with av_bitstream_filter_close().
- *
- * @param name    the name of the bitstream filter
- * @return a bitstream filter context if a matching filter was found
- * and successfully initialized, NULL otherwise
- */
-AVBitStreamFilterContext *av_bitstream_filter_init(const char *name);
-
-/**
- * Filter bitstream.
- *
- * This function filters the buffer buf with size buf_size, and places the
- * filtered buffer in the buffer pointed to by poutbuf.
- *
- * The output buffer must be freed by the caller.
- *
- * @param bsfc            bitstream filter context created by av_bitstream_filter_init()
- * @param avctx           AVCodecContext accessed by the filter, may be NULL.
- *                        If specified, this must point to the encoder context of the
- *                        output stream the packet is sent to.
- * @param args            arguments which specify the filter configuration, may be NULL
- * @param poutbuf         pointer which is updated to point to the filtered buffer
- * @param poutbuf_size    pointer which is updated to the filtered buffer size in bytes
- * @param buf             buffer containing the data to filter
- * @param buf_size        size in bytes of buf
- * @param keyframe        set to non-zero if the buffer to filter corresponds to a key-frame packet data
- * @return >= 0 in case of success, or a negative error code in case of failure
- *
- * If the return value is positive, an output buffer is allocated and
- * is available in *poutbuf, and is distinct from the input buffer.
- *
- * If the return value is 0, the output buffer is not allocated and
- * should be considered identical to the input buffer, or in case
- * *poutbuf was set it points to the input buffer (not necessarily to
- * its starting address).
- */
-int av_bitstream_filter_filter(AVBitStreamFilterContext *bsfc,
-                               AVCodecContext *avctx, const char *args,
-                               uint8_t **poutbuf, int *poutbuf_size,
-                               const uint8_t *buf, int buf_size, int keyframe);
-
-/**
- * Release bitstream filter context.
- *
- * @param bsf the bitstream filter context created with
- * av_bitstream_filter_init(), can be NULL
- */
-void av_bitstream_filter_close(AVBitStreamFilterContext *bsf);
-
-/**
- * If f is NULL, return the first registered bitstream filter,
- * if f is non-NULL, return the next registered bitstream filter
- * after f, or NULL if f is the last one.
- *
- * This function can be used to iterate over all registered bitstream
- * filters.
- */
-AVBitStreamFilter *av_bitstream_filter_next(AVBitStreamFilter *f);
-
-/* memory */
-
-/**
- * Same behaviour av_fast_malloc but the buffer has additional
- * FF_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
- *
- * In addition the whole buffer will initially and after resizes
- * be 0-initialized so that no uninitialized data will ever appear.
- */
-void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size);
-
-/**
- * Same behaviour av_fast_padded_malloc except that buffer will always
- * be 0-initialized after call.
- */
-void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size);
-
-/**
- * Encode extradata length to a buffer. Used by xiph codecs.
- *
- * @param s buffer to write to; must be at least (v/255+1) bytes long
- * @param v size of extradata in bytes
- * @return number of bytes written to the buffer.
- */
-unsigned int av_xiphlacing(unsigned char *s, unsigned int v);
-
-#if FF_API_MISSING_SAMPLE
-/**
- * Log a generic warning message about a missing feature. This function is
- * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)
- * only, and would normally not be used by applications.
- * @param[in] avc a pointer to an arbitrary struct of which the first field is
- * a pointer to an AVClass struct
- * @param[in] feature string containing the name of the missing feature
- * @param[in] want_sample indicates if samples are wanted which exhibit this feature.
- * If want_sample is non-zero, additional verbage will be added to the log
- * message which tells the user how to report samples to the development
- * mailing list.
- * @deprecated Use avpriv_report_missing_feature() instead.
- */
-attribute_deprecated
-void av_log_missing_feature(void *avc, const char *feature, int want_sample);
-
-/**
- * Log a generic warning message asking for a sample. This function is
- * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)
- * only, and would normally not be used by applications.
- * @param[in] avc a pointer to an arbitrary struct of which the first field is
- * a pointer to an AVClass struct
- * @param[in] msg string containing an optional message, or NULL if no message
- * @deprecated Use avpriv_request_sample() instead.
- */
-attribute_deprecated
-void av_log_ask_for_sample(void *avc, const char *msg, ...) av_printf_format(2, 3);
-#endif /* FF_API_MISSING_SAMPLE */
-
-/**
- * Register the hardware accelerator hwaccel.
- */
-void av_register_hwaccel(AVHWAccel *hwaccel);
-
-/**
- * If hwaccel is NULL, returns the first registered hardware accelerator,
- * if hwaccel is non-NULL, returns the next registered hardware accelerator
- * after hwaccel, or NULL if hwaccel is the last one.
- */
-AVHWAccel *av_hwaccel_next(AVHWAccel *hwaccel);
-
-
-/**
- * Lock operation used by lockmgr
- */
-enum AVLockOp {
-  AV_LOCK_CREATE,  ///< Create a mutex
-  AV_LOCK_OBTAIN,  ///< Lock the mutex
-  AV_LOCK_RELEASE, ///< Unlock the mutex
-  AV_LOCK_DESTROY, ///< Free mutex resources
-};
-
-/**
- * Register a user provided lock manager supporting the operations
- * specified by AVLockOp. mutex points to a (void *) where the
- * lockmgr should store/get a pointer to a user allocated mutex. It's
- * NULL upon AV_LOCK_CREATE and != NULL for all other ops.
- *
- * @param cb User defined callback. Note: FFmpeg may invoke calls to this
- *           callback during the call to av_lockmgr_register().
- *           Thus, the application must be prepared to handle that.
- *           If cb is set to NULL the lockmgr will be unregistered.
- *           Also note that during unregistration the previously registered
- *           lockmgr callback may also be invoked.
- */
-int av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op));
-
-/**
- * Get the type of the given codec.
- */
-enum AVMediaType avcodec_get_type(enum AVCodecID codec_id);
-
-/**
- * Get the name of a codec.
- * @return  a static string identifying the codec; never NULL
- */
-const char *avcodec_get_name(enum AVCodecID id);
-
-/**
- * @return a positive value if s is open (i.e. avcodec_open2() was called on it
- * with no corresponding avcodec_close()), 0 otherwise.
- */
-int avcodec_is_open(AVCodecContext *s);
-
-/**
- * @return a non-zero number if codec is an encoder, zero otherwise
- */
-int av_codec_is_encoder(const AVCodec *codec);
-
-/**
- * @return a non-zero number if codec is a decoder, zero otherwise
- */
-int av_codec_is_decoder(const AVCodec *codec);
-
-/**
- * @return descriptor for given codec ID or NULL if no descriptor exists.
- */
-const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id);
-
-/**
- * Iterate over all codec descriptors known to libavcodec.
- *
- * @param prev previous descriptor. NULL to get the first descriptor.
- *
- * @return next descriptor or NULL after the last descriptor
- */
-const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev);
-
-/**
- * @return codec descriptor with the given name or NULL if no such descriptor
- *         exists.
- */
-const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name);
-
-/**
- * @}
- */
-
 #endif /* AVCODEC_AVCODEC_H */
diff -pruN /usr/include/ffmpeg/libavcodec/avcodecid.h csrc/libavcodec/avcodecid.h
--- /usr/include/ffmpeg/libavcodec/avcodecid.h	1970-01-01 01:00:00.000000000 +0100
+++ csrc/libavcodec/avcodecid.h	2014-10-20 10:48:10.118098394 +0200
@@ -0,0 +1,815 @@
+
+#ifndef AVCODEC_AVCODECID_H
+#define AVCODEC_AVCODECID_H
+#define AVCODEC_OLD_CODEC_IDS_H
+
+enum AVCodecID {
+    AV_CODEC_ID_NONE,
+
+    /* video codecs */
+    AV_CODEC_ID_MPEG1VIDEO,
+    AV_CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
+#if FF_API_XVMC
+    AV_CODEC_ID_MPEG2VIDEO_XVMC,
+#endif /* FF_API_XVMC */
+    AV_CODEC_ID_H261,
+    AV_CODEC_ID_H263,
+    AV_CODEC_ID_RV10,
+    AV_CODEC_ID_RV20,
+    AV_CODEC_ID_MJPEG,
+    AV_CODEC_ID_MJPEGB,
+    AV_CODEC_ID_LJPEG,
+    AV_CODEC_ID_SP5X,
+    AV_CODEC_ID_JPEGLS,
+    AV_CODEC_ID_MPEG4,
+    AV_CODEC_ID_RAWVIDEO,
+    AV_CODEC_ID_MSMPEG4V1,
+    AV_CODEC_ID_MSMPEG4V2,
+    AV_CODEC_ID_MSMPEG4V3,
+    AV_CODEC_ID_WMV1,
+    AV_CODEC_ID_WMV2,
+    AV_CODEC_ID_H263P,
+    AV_CODEC_ID_H263I,
+    AV_CODEC_ID_FLV1,
+    AV_CODEC_ID_SVQ1,
+    AV_CODEC_ID_SVQ3,
+    AV_CODEC_ID_DVVIDEO,
+    AV_CODEC_ID_HUFFYUV,
+    AV_CODEC_ID_CYUV,
+    AV_CODEC_ID_H264,
+    AV_CODEC_ID_INDEO3,
+    AV_CODEC_ID_VP3,
+    AV_CODEC_ID_THEORA,
+    AV_CODEC_ID_ASV1,
+    AV_CODEC_ID_ASV2,
+    AV_CODEC_ID_FFV1,
+    AV_CODEC_ID_4XM,
+    AV_CODEC_ID_VCR1,
+    AV_CODEC_ID_CLJR,
+    AV_CODEC_ID_MDEC,
+    AV_CODEC_ID_ROQ,
+    AV_CODEC_ID_INTERPLAY_VIDEO,
+    AV_CODEC_ID_XAN_WC3,
+    AV_CODEC_ID_XAN_WC4,
+    AV_CODEC_ID_RPZA,
+    AV_CODEC_ID_CINEPAK,
+    AV_CODEC_ID_WS_VQA,
+    AV_CODEC_ID_MSRLE,
+    AV_CODEC_ID_MSVIDEO1,
+    AV_CODEC_ID_IDCIN,
+    AV_CODEC_ID_8BPS,
+    AV_CODEC_ID_SMC,
+    AV_CODEC_ID_FLIC,
+    AV_CODEC_ID_TRUEMOTION1,
+    AV_CODEC_ID_VMDVIDEO,
+    AV_CODEC_ID_MSZH,
+    AV_CODEC_ID_ZLIB,
+    AV_CODEC_ID_QTRLE,
+    AV_CODEC_ID_TSCC,
+    AV_CODEC_ID_ULTI,
+    AV_CODEC_ID_QDRAW,
+    AV_CODEC_ID_VIXL,
+    AV_CODEC_ID_QPEG,
+    AV_CODEC_ID_PNG,
+    AV_CODEC_ID_PPM,
+    AV_CODEC_ID_PBM,
+    AV_CODEC_ID_PGM,
+    AV_CODEC_ID_PGMYUV,
+    AV_CODEC_ID_PAM,
+    AV_CODEC_ID_FFVHUFF,
+    AV_CODEC_ID_RV30,
+    AV_CODEC_ID_RV40,
+    AV_CODEC_ID_VC1,
+    AV_CODEC_ID_WMV3,
+    AV_CODEC_ID_LOCO,
+    AV_CODEC_ID_WNV1,
+    AV_CODEC_ID_AASC,
+    AV_CODEC_ID_INDEO2,
+    AV_CODEC_ID_FRAPS,
+    AV_CODEC_ID_TRUEMOTION2,
+    AV_CODEC_ID_BMP,
+    AV_CODEC_ID_CSCD,
+    AV_CODEC_ID_MMVIDEO,
+    AV_CODEC_ID_ZMBV,
+    AV_CODEC_ID_AVS,
+    AV_CODEC_ID_SMACKVIDEO,
+    AV_CODEC_ID_NUV,
+    AV_CODEC_ID_KMVC,
+    AV_CODEC_ID_FLASHSV,
+    AV_CODEC_ID_CAVS,
+    AV_CODEC_ID_JPEG2000,
+    AV_CODEC_ID_VMNC,
+    AV_CODEC_ID_VP5,
+    AV_CODEC_ID_VP6,
+    AV_CODEC_ID_VP6F,
+    AV_CODEC_ID_TARGA,
+    AV_CODEC_ID_DSICINVIDEO,
+    AV_CODEC_ID_TIERTEXSEQVIDEO,
+    AV_CODEC_ID_TIFF,
+    AV_CODEC_ID_GIF,
+    AV_CODEC_ID_DXA,
+    AV_CODEC_ID_DNXHD,
+    AV_CODEC_ID_THP,
+    AV_CODEC_ID_SGI,
+    AV_CODEC_ID_C93,
+    AV_CODEC_ID_BETHSOFTVID,
+    AV_CODEC_ID_PTX,
+    AV_CODEC_ID_TXD,
+    AV_CODEC_ID_VP6A,
+    AV_CODEC_ID_AMV,
+    AV_CODEC_ID_VB,
+    AV_CODEC_ID_PCX,
+    AV_CODEC_ID_SUNRAST,
+    AV_CODEC_ID_INDEO4,
+    AV_CODEC_ID_INDEO5,
+    AV_CODEC_ID_MIMIC,
+    AV_CODEC_ID_RL2,
+    AV_CODEC_ID_ESCAPE124,
+    AV_CODEC_ID_DIRAC,
+    AV_CODEC_ID_BFI,
+    AV_CODEC_ID_CMV,
+    AV_CODEC_ID_MOTIONPIXELS,
+    AV_CODEC_ID_TGV,
+    AV_CODEC_ID_TGQ,
+    AV_CODEC_ID_TQI,
+    AV_CODEC_ID_AURA,
+    AV_CODEC_ID_AURA2,
+    AV_CODEC_ID_V210X,
+    AV_CODEC_ID_TMV,
+    AV_CODEC_ID_V210,
+    AV_CODEC_ID_DPX,
+    AV_CODEC_ID_MAD,
+    AV_CODEC_ID_FRWU,
+    AV_CODEC_ID_FLASHSV2,
+    AV_CODEC_ID_CDGRAPHICS,
+    AV_CODEC_ID_R210,
+    AV_CODEC_ID_ANM,
+    AV_CODEC_ID_BINKVIDEO,
+    AV_CODEC_ID_IFF_ILBM,
+    AV_CODEC_ID_IFF_BYTERUN1,
+    AV_CODEC_ID_KGV1,
+    AV_CODEC_ID_YOP,
+    AV_CODEC_ID_VP8,
+    AV_CODEC_ID_PICTOR,
+    AV_CODEC_ID_ANSI,
+    AV_CODEC_ID_A64_MULTI,
+    AV_CODEC_ID_A64_MULTI5,
+    AV_CODEC_ID_R10K,
+    AV_CODEC_ID_MXPEG,
+    AV_CODEC_ID_LAGARITH,
+    AV_CODEC_ID_PRORES,
+    AV_CODEC_ID_JV,
+    AV_CODEC_ID_DFA,
+    AV_CODEC_ID_WMV3IMAGE,
+    AV_CODEC_ID_VC1IMAGE,
+    AV_CODEC_ID_UTVIDEO,
+    AV_CODEC_ID_BMV_VIDEO,
+    AV_CODEC_ID_VBLE,
+    AV_CODEC_ID_DXTORY,
+    AV_CODEC_ID_V410,
+    AV_CODEC_ID_XWD,
+    AV_CODEC_ID_CDXL,
+    AV_CODEC_ID_XBM,
+    AV_CODEC_ID_ZEROCODEC,
+    AV_CODEC_ID_MSS1,
+    AV_CODEC_ID_MSA1,
+    AV_CODEC_ID_TSCC2,
+    AV_CODEC_ID_MTS2,
+    AV_CODEC_ID_CLLC,
+    AV_CODEC_ID_MSS2,
+    AV_CODEC_ID_VP9,
+    AV_CODEC_ID_AIC,
+    AV_CODEC_ID_ESCAPE130_DEPRECATED,
+    AV_CODEC_ID_G2M_DEPRECATED,
+    AV_CODEC_ID_WEBP_DEPRECATED,
+    AV_CODEC_ID_HNM4_VIDEO,
+    AV_CODEC_ID_HEVC_DEPRECATED,
+    AV_CODEC_ID_FIC,
+    AV_CODEC_ID_ALIAS_PIX,
+    AV_CODEC_ID_BRENDER_PIX_DEPRECATED,
+    AV_CODEC_ID_PAF_VIDEO_DEPRECATED,
+    AV_CODEC_ID_EXR_DEPRECATED,
+    AV_CODEC_ID_VP7_DEPRECATED,
+    AV_CODEC_ID_SANM_DEPRECATED,
+    AV_CODEC_ID_SGIRLE_DEPRECATED,
+    AV_CODEC_ID_MVC1_DEPRECATED,
+    AV_CODEC_ID_MVC2_DEPRECATED,
+
+    AV_CODEC_ID_BRENDER_PIX= MKBETAG('B','P','I','X'),
+    AV_CODEC_ID_Y41P       = MKBETAG('Y','4','1','P'),
+    AV_CODEC_ID_ESCAPE130  = MKBETAG('E','1','3','0'),
+    AV_CODEC_ID_EXR        = MKBETAG('0','E','X','R'),
+    AV_CODEC_ID_AVRP       = MKBETAG('A','V','R','P'),
+
+    AV_CODEC_ID_012V       = MKBETAG('0','1','2','V'),
+    AV_CODEC_ID_G2M        = MKBETAG( 0 ,'G','2','M'),
+    AV_CODEC_ID_AVUI       = MKBETAG('A','V','U','I'),
+    AV_CODEC_ID_AYUV       = MKBETAG('A','Y','U','V'),
+    AV_CODEC_ID_TARGA_Y216 = MKBETAG('T','2','1','6'),
+    AV_CODEC_ID_V308       = MKBETAG('V','3','0','8'),
+    AV_CODEC_ID_V408       = MKBETAG('V','4','0','8'),
+    AV_CODEC_ID_YUV4       = MKBETAG('Y','U','V','4'),
+    AV_CODEC_ID_SANM       = MKBETAG('S','A','N','M'),
+    AV_CODEC_ID_PAF_VIDEO  = MKBETAG('P','A','F','V'),
+    AV_CODEC_ID_AVRN       = MKBETAG('A','V','R','n'),
+    AV_CODEC_ID_CPIA       = MKBETAG('C','P','I','A'),
+    AV_CODEC_ID_XFACE      = MKBETAG('X','F','A','C'),
+    AV_CODEC_ID_SGIRLE     = MKBETAG('S','G','I','R'),
+    AV_CODEC_ID_MVC1       = MKBETAG('M','V','C','1'),
+    AV_CODEC_ID_MVC2       = MKBETAG('M','V','C','2'),
+    AV_CODEC_ID_SNOW       = MKBETAG('S','N','O','W'),
+    AV_CODEC_ID_WEBP       = MKBETAG('W','E','B','P'),
+    AV_CODEC_ID_SMVJPEG    = MKBETAG('S','M','V','J'),
+    AV_CODEC_ID_HEVC       = MKBETAG('H','2','6','5'),
+#define AV_CODEC_ID_H265 AV_CODEC_ID_HEVC
+    AV_CODEC_ID_VP7        = MKBETAG('V','P','7','0'),
+
+    /* various PCM "codecs" */
+    AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
+    AV_CODEC_ID_PCM_S16LE = 0x10000,
+    AV_CODEC_ID_PCM_S16BE,
+    AV_CODEC_ID_PCM_U16LE,
+    AV_CODEC_ID_PCM_U16BE,
+    AV_CODEC_ID_PCM_S8,
+    AV_CODEC_ID_PCM_U8,
+    AV_CODEC_ID_PCM_MULAW,
+    AV_CODEC_ID_PCM_ALAW,
+    AV_CODEC_ID_PCM_S32LE,
+    AV_CODEC_ID_PCM_S32BE,
+    AV_CODEC_ID_PCM_U32LE,
+    AV_CODEC_ID_PCM_U32BE,
+    AV_CODEC_ID_PCM_S24LE,
+    AV_CODEC_ID_PCM_S24BE,
+    AV_CODEC_ID_PCM_U24LE,
+    AV_CODEC_ID_PCM_U24BE,
+    AV_CODEC_ID_PCM_S24DAUD,
+    AV_CODEC_ID_PCM_ZORK,
+    AV_CODEC_ID_PCM_S16LE_PLANAR,
+    AV_CODEC_ID_PCM_DVD,
+    AV_CODEC_ID_PCM_F32BE,
+    AV_CODEC_ID_PCM_F32LE,
+    AV_CODEC_ID_PCM_F64BE,
+    AV_CODEC_ID_PCM_F64LE,
+    AV_CODEC_ID_PCM_BLURAY,
+    AV_CODEC_ID_PCM_LXF,
+    AV_CODEC_ID_S302M,
+    AV_CODEC_ID_PCM_S8_PLANAR,
+    AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED,
+    AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED,
+    AV_CODEC_ID_PCM_S24LE_PLANAR = MKBETAG(24,'P','S','P'),
+    AV_CODEC_ID_PCM_S32LE_PLANAR = MKBETAG(32,'P','S','P'),
+    AV_CODEC_ID_PCM_S16BE_PLANAR = MKBETAG('P','S','P',16),
+
+    /* various ADPCM codecs */
+    AV_CODEC_ID_ADPCM_IMA_QT = 0x11000,
+    AV_CODEC_ID_ADPCM_IMA_WAV,
+    AV_CODEC_ID_ADPCM_IMA_DK3,
+    AV_CODEC_ID_ADPCM_IMA_DK4,
+    AV_CODEC_ID_ADPCM_IMA_WS,
+    AV_CODEC_ID_ADPCM_IMA_SMJPEG,
+    AV_CODEC_ID_ADPCM_MS,
+    AV_CODEC_ID_ADPCM_4XM,
+    AV_CODEC_ID_ADPCM_XA,
+    AV_CODEC_ID_ADPCM_ADX,
+    AV_CODEC_ID_ADPCM_EA,
+    AV_CODEC_ID_ADPCM_G726,
+    AV_CODEC_ID_ADPCM_CT,
+    AV_CODEC_ID_ADPCM_SWF,
+    AV_CODEC_ID_ADPCM_YAMAHA,
+    AV_CODEC_ID_ADPCM_SBPRO_4,
+    AV_CODEC_ID_ADPCM_SBPRO_3,
+    AV_CODEC_ID_ADPCM_SBPRO_2,
+    AV_CODEC_ID_ADPCM_THP,
+    AV_CODEC_ID_ADPCM_IMA_AMV,
+    AV_CODEC_ID_ADPCM_EA_R1,
+    AV_CODEC_ID_ADPCM_EA_R3,
+    AV_CODEC_ID_ADPCM_EA_R2,
+    AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
+    AV_CODEC_ID_ADPCM_IMA_EA_EACS,
+    AV_CODEC_ID_ADPCM_EA_XAS,
+    AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
+    AV_CODEC_ID_ADPCM_IMA_ISS,
+    AV_CODEC_ID_ADPCM_G722,
+    AV_CODEC_ID_ADPCM_IMA_APC,
+    AV_CODEC_ID_ADPCM_VIMA_DEPRECATED,
+    AV_CODEC_ID_ADPCM_VIMA = MKBETAG('V','I','M','A'),
+    AV_CODEC_ID_VIMA       = MKBETAG('V','I','M','A'),
+    AV_CODEC_ID_ADPCM_AFC  = MKBETAG('A','F','C',' '),
+    AV_CODEC_ID_ADPCM_IMA_OKI = MKBETAG('O','K','I',' '),
+    AV_CODEC_ID_ADPCM_DTK  = MKBETAG('D','T','K',' '),
+    AV_CODEC_ID_ADPCM_IMA_RAD = MKBETAG('R','A','D',' '),
+    AV_CODEC_ID_ADPCM_G726LE = MKBETAG('6','2','7','G'),
+
+    /* AMR */
+    AV_CODEC_ID_AMR_NB = 0x12000,
+    AV_CODEC_ID_AMR_WB,
+
+    /* RealAudio codecs*/
+    AV_CODEC_ID_RA_144 = 0x13000,
+    AV_CODEC_ID_RA_288,
+
+    /* various DPCM codecs */
+    AV_CODEC_ID_ROQ_DPCM = 0x14000,
+    AV_CODEC_ID_INTERPLAY_DPCM,
+    AV_CODEC_ID_XAN_DPCM,
+    AV_CODEC_ID_SOL_DPCM,
+
+    /* audio codecs */
+    AV_CODEC_ID_MP2 = 0x15000,
+    AV_CODEC_ID_MP3, ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
+    AV_CODEC_ID_AAC,
+    AV_CODEC_ID_AC3,
+    AV_CODEC_ID_DTS,
+    AV_CODEC_ID_VORBIS,
+    AV_CODEC_ID_DVAUDIO,
+    AV_CODEC_ID_WMAV1,
+    AV_CODEC_ID_WMAV2,
+    AV_CODEC_ID_MACE3,
+    AV_CODEC_ID_MACE6,
+    AV_CODEC_ID_VMDAUDIO,
+    AV_CODEC_ID_FLAC,
+    AV_CODEC_ID_MP3ADU,
+    AV_CODEC_ID_MP3ON4,
+    AV_CODEC_ID_SHORTEN,
+    AV_CODEC_ID_ALAC,
+    AV_CODEC_ID_WESTWOOD_SND1,
+    AV_CODEC_ID_GSM, ///< as in Berlin toast format
+    AV_CODEC_ID_QDM2,
+    AV_CODEC_ID_COOK,
+    AV_CODEC_ID_TRUESPEECH,
+    AV_CODEC_ID_TTA,
+    AV_CODEC_ID_SMACKAUDIO,
+    AV_CODEC_ID_QCELP,
+    AV_CODEC_ID_WAVPACK,
+    AV_CODEC_ID_DSICINAUDIO,
+    AV_CODEC_ID_IMC,
+    AV_CODEC_ID_MUSEPACK7,
+    AV_CODEC_ID_MLP,
+    AV_CODEC_ID_GSM_MS, /* as found in WAV */
+    AV_CODEC_ID_ATRAC3,
+#if FF_API_VOXWARE
+    AV_CODEC_ID_VOXWARE,
+#endif
+    AV_CODEC_ID_APE,
+    AV_CODEC_ID_NELLYMOSER,
+    AV_CODEC_ID_MUSEPACK8,
+    AV_CODEC_ID_SPEEX,
+    AV_CODEC_ID_WMAVOICE,
+    AV_CODEC_ID_WMAPRO,
+    AV_CODEC_ID_WMALOSSLESS,
+    AV_CODEC_ID_ATRAC3P,
+    AV_CODEC_ID_EAC3,
+    AV_CODEC_ID_SIPR,
+    AV_CODEC_ID_MP1,
+    AV_CODEC_ID_TWINVQ,
+    AV_CODEC_ID_TRUEHD,
+    AV_CODEC_ID_MP4ALS,
+    AV_CODEC_ID_ATRAC1,
+    AV_CODEC_ID_BINKAUDIO_RDFT,
+    AV_CODEC_ID_BINKAUDIO_DCT,
+    AV_CODEC_ID_AAC_LATM,
+    AV_CODEC_ID_QDMC,
+    AV_CODEC_ID_CELT,
+    AV_CODEC_ID_G723_1,
+    AV_CODEC_ID_G729,
+    AV_CODEC_ID_8SVX_EXP,
+    AV_CODEC_ID_8SVX_FIB,
+    AV_CODEC_ID_BMV_AUDIO,
+    AV_CODEC_ID_RALF,
+    AV_CODEC_ID_IAC,
+    AV_CODEC_ID_ILBC,
+    AV_CODEC_ID_OPUS_DEPRECATED,
+    AV_CODEC_ID_COMFORT_NOISE,
+    AV_CODEC_ID_TAK_DEPRECATED,
+    AV_CODEC_ID_METASOUND,
+    AV_CODEC_ID_PAF_AUDIO_DEPRECATED,
+    AV_CODEC_ID_ON2AVC,
+    AV_CODEC_ID_FFWAVESYNTH = MKBETAG('F','F','W','S'),
+    AV_CODEC_ID_SONIC       = MKBETAG('S','O','N','C'),
+    AV_CODEC_ID_SONIC_LS    = MKBETAG('S','O','N','L'),
+    AV_CODEC_ID_PAF_AUDIO   = MKBETAG('P','A','F','A'),
+    AV_CODEC_ID_OPUS        = MKBETAG('O','P','U','S'),
+    AV_CODEC_ID_TAK         = MKBETAG('t','B','a','K'),
+    AV_CODEC_ID_EVRC        = MKBETAG('s','e','v','c'),
+    AV_CODEC_ID_SMV         = MKBETAG('s','s','m','v'),
+    AV_CODEC_ID_DSD_LSBF    = MKBETAG('D','S','D','L'),
+    AV_CODEC_ID_DSD_MSBF    = MKBETAG('D','S','D','M'),
+    AV_CODEC_ID_DSD_LSBF_PLANAR = MKBETAG('D','S','D','1'),
+    AV_CODEC_ID_DSD_MSBF_PLANAR = MKBETAG('D','S','D','8'),
+
+    /* subtitle codecs */
+    AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
+    AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
+    AV_CODEC_ID_DVB_SUBTITLE,
+    AV_CODEC_ID_TEXT,  ///< raw UTF-8 text
+    AV_CODEC_ID_XSUB,
+    AV_CODEC_ID_SSA,
+    AV_CODEC_ID_MOV_TEXT,
+    AV_CODEC_ID_HDMV_PGS_SUBTITLE,
+    AV_CODEC_ID_DVB_TELETEXT,
+    AV_CODEC_ID_SRT,
+    AV_CODEC_ID_MICRODVD   = MKBETAG('m','D','V','D'),
+    AV_CODEC_ID_EIA_608    = MKBETAG('c','6','0','8'),
+    AV_CODEC_ID_JACOSUB    = MKBETAG('J','S','U','B'),
+    AV_CODEC_ID_SAMI       = MKBETAG('S','A','M','I'),
+    AV_CODEC_ID_REALTEXT   = MKBETAG('R','T','X','T'),
+    AV_CODEC_ID_SUBVIEWER1 = MKBETAG('S','b','V','1'),
+    AV_CODEC_ID_SUBVIEWER  = MKBETAG('S','u','b','V'),
+    AV_CODEC_ID_SUBRIP     = MKBETAG('S','R','i','p'),
+    AV_CODEC_ID_WEBVTT     = MKBETAG('W','V','T','T'),
+    AV_CODEC_ID_MPL2       = MKBETAG('M','P','L','2'),
+    AV_CODEC_ID_VPLAYER    = MKBETAG('V','P','l','r'),
+    AV_CODEC_ID_PJS        = MKBETAG('P','h','J','S'),
+    AV_CODEC_ID_ASS        = MKBETAG('A','S','S',' '),  ///< ASS as defined in Matroska
+
+    /* other specific kind of codecs (generally used for attachments) */
+    AV_CODEC_ID_FIRST_UNKNOWN = 0x18000,           ///< A dummy ID pointing at the start of various fake codecs.
+    AV_CODEC_ID_TTF = 0x18000,
+    AV_CODEC_ID_BINTEXT    = MKBETAG('B','T','X','T'),
+    AV_CODEC_ID_XBIN       = MKBETAG('X','B','I','N'),
+    AV_CODEC_ID_IDF        = MKBETAG( 0 ,'I','D','F'),
+    AV_CODEC_ID_OTF        = MKBETAG( 0 ,'O','T','F'),
+    AV_CODEC_ID_SMPTE_KLV  = MKBETAG('K','L','V','A'),
+    AV_CODEC_ID_DVD_NAV    = MKBETAG('D','N','A','V'),
+    AV_CODEC_ID_TIMED_ID3  = MKBETAG('T','I','D','3'),
+    AV_CODEC_ID_BIN_DATA   = MKBETAG('D','A','T','A'),
+
+
+    AV_CODEC_ID_PROBE = 0x19000, ///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
+
+    AV_CODEC_ID_MPEG2TS = 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
+                                * stream (only used by libavformat) */
+    AV_CODEC_ID_MPEG4SYSTEMS = 0x20001, /**< _FAKE_ codec to indicate a MPEG-4 Systems
+                                * stream (only used by libavformat) */
+    AV_CODEC_ID_FFMETADATA = 0x21000,   ///< Dummy codec for streams containing only metadata information.
+
+    CODEC_ID_NONE = AV_CODEC_ID_NONE,
+
+    /* video codecs */
+    CODEC_ID_MPEG1VIDEO,
+    CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
+#if FF_API_XVMC
+    CODEC_ID_MPEG2VIDEO_XVMC,
+#endif
+    CODEC_ID_H261,
+    CODEC_ID_H263,
+    CODEC_ID_RV10,
+    CODEC_ID_RV20,
+    CODEC_ID_MJPEG,
+    CODEC_ID_MJPEGB,
+    CODEC_ID_LJPEG,
+    CODEC_ID_SP5X,
+    CODEC_ID_JPEGLS,
+    CODEC_ID_MPEG4,
+    CODEC_ID_RAWVIDEO,
+    CODEC_ID_MSMPEG4V1,
+    CODEC_ID_MSMPEG4V2,
+    CODEC_ID_MSMPEG4V3,
+    CODEC_ID_WMV1,
+    CODEC_ID_WMV2,
+    CODEC_ID_H263P,
+    CODEC_ID_H263I,
+    CODEC_ID_FLV1,
+    CODEC_ID_SVQ1,
+    CODEC_ID_SVQ3,
+    CODEC_ID_DVVIDEO,
+    CODEC_ID_HUFFYUV,
+    CODEC_ID_CYUV,
+    CODEC_ID_H264,
+    CODEC_ID_INDEO3,
+    CODEC_ID_VP3,
+    CODEC_ID_THEORA,
+    CODEC_ID_ASV1,
+    CODEC_ID_ASV2,
+    CODEC_ID_FFV1,
+    CODEC_ID_4XM,
+    CODEC_ID_VCR1,
+    CODEC_ID_CLJR,
+    CODEC_ID_MDEC,
+    CODEC_ID_ROQ,
+    CODEC_ID_INTERPLAY_VIDEO,
+    CODEC_ID_XAN_WC3,
+    CODEC_ID_XAN_WC4,
+    CODEC_ID_RPZA,
+    CODEC_ID_CINEPAK,
+    CODEC_ID_WS_VQA,
+    CODEC_ID_MSRLE,
+    CODEC_ID_MSVIDEO1,
+    CODEC_ID_IDCIN,
+    CODEC_ID_8BPS,
+    CODEC_ID_SMC,
+    CODEC_ID_FLIC,
+    CODEC_ID_TRUEMOTION1,
+    CODEC_ID_VMDVIDEO,
+    CODEC_ID_MSZH,
+    CODEC_ID_ZLIB,
+    CODEC_ID_QTRLE,
+    CODEC_ID_TSCC,
+    CODEC_ID_ULTI,
+    CODEC_ID_QDRAW,
+    CODEC_ID_VIXL,
+    CODEC_ID_QPEG,
+    CODEC_ID_PNG,
+    CODEC_ID_PPM,
+    CODEC_ID_PBM,
+    CODEC_ID_PGM,
+    CODEC_ID_PGMYUV,
+    CODEC_ID_PAM,
+    CODEC_ID_FFVHUFF,
+    CODEC_ID_RV30,
+    CODEC_ID_RV40,
+    CODEC_ID_VC1,
+    CODEC_ID_WMV3,
+    CODEC_ID_LOCO,
+    CODEC_ID_WNV1,
+    CODEC_ID_AASC,
+    CODEC_ID_INDEO2,
+    CODEC_ID_FRAPS,
+    CODEC_ID_TRUEMOTION2,
+    CODEC_ID_BMP,
+    CODEC_ID_CSCD,
+    CODEC_ID_MMVIDEO,
+    CODEC_ID_ZMBV,
+    CODEC_ID_AVS,
+    CODEC_ID_SMACKVIDEO,
+    CODEC_ID_NUV,
+    CODEC_ID_KMVC,
+    CODEC_ID_FLASHSV,
+    CODEC_ID_CAVS,
+    CODEC_ID_JPEG2000,
+    CODEC_ID_VMNC,
+    CODEC_ID_VP5,
+    CODEC_ID_VP6,
+    CODEC_ID_VP6F,
+    CODEC_ID_TARGA,
+    CODEC_ID_DSICINVIDEO,
+    CODEC_ID_TIERTEXSEQVIDEO,
+    CODEC_ID_TIFF,
+    CODEC_ID_GIF,
+    CODEC_ID_DXA,
+    CODEC_ID_DNXHD,
+    CODEC_ID_THP,
+    CODEC_ID_SGI,
+    CODEC_ID_C93,
+    CODEC_ID_BETHSOFTVID,
+    CODEC_ID_PTX,
+    CODEC_ID_TXD,
+    CODEC_ID_VP6A,
+    CODEC_ID_AMV,
+    CODEC_ID_VB,
+    CODEC_ID_PCX,
+    CODEC_ID_SUNRAST,
+    CODEC_ID_INDEO4,
+    CODEC_ID_INDEO5,
+    CODEC_ID_MIMIC,
+    CODEC_ID_RL2,
+    CODEC_ID_ESCAPE124,
+    CODEC_ID_DIRAC,
+    CODEC_ID_BFI,
+    CODEC_ID_CMV,
+    CODEC_ID_MOTIONPIXELS,
+    CODEC_ID_TGV,
+    CODEC_ID_TGQ,
+    CODEC_ID_TQI,
+    CODEC_ID_AURA,
+    CODEC_ID_AURA2,
+    CODEC_ID_V210X,
+    CODEC_ID_TMV,
+    CODEC_ID_V210,
+    CODEC_ID_DPX,
+    CODEC_ID_MAD,
+    CODEC_ID_FRWU,
+    CODEC_ID_FLASHSV2,
+    CODEC_ID_CDGRAPHICS,
+    CODEC_ID_R210,
+    CODEC_ID_ANM,
+    CODEC_ID_BINKVIDEO,
+    CODEC_ID_IFF_ILBM,
+    CODEC_ID_IFF_BYTERUN1,
+    CODEC_ID_KGV1,
+    CODEC_ID_YOP,
+    CODEC_ID_VP8,
+    CODEC_ID_PICTOR,
+    CODEC_ID_ANSI,
+    CODEC_ID_A64_MULTI,
+    CODEC_ID_A64_MULTI5,
+    CODEC_ID_R10K,
+    CODEC_ID_MXPEG,
+    CODEC_ID_LAGARITH,
+    CODEC_ID_PRORES,
+    CODEC_ID_JV,
+    CODEC_ID_DFA,
+    CODEC_ID_WMV3IMAGE,
+    CODEC_ID_VC1IMAGE,
+    CODEC_ID_UTVIDEO,
+    CODEC_ID_BMV_VIDEO,
+    CODEC_ID_VBLE,
+    CODEC_ID_DXTORY,
+    CODEC_ID_V410,
+    CODEC_ID_XWD,
+    CODEC_ID_CDXL,
+    CODEC_ID_XBM,
+    CODEC_ID_ZEROCODEC,
+    CODEC_ID_MSS1,
+    CODEC_ID_MSA1,
+    CODEC_ID_TSCC2,
+    CODEC_ID_MTS2,
+    CODEC_ID_CLLC,
+    CODEC_ID_Y41P       = MKBETAG('Y','4','1','P'),
+    CODEC_ID_ESCAPE130  = MKBETAG('E','1','3','0'),
+    CODEC_ID_EXR        = MKBETAG('0','E','X','R'),
+    CODEC_ID_AVRP       = MKBETAG('A','V','R','P'),
+
+    CODEC_ID_G2M        = MKBETAG( 0 ,'G','2','M'),
+    CODEC_ID_AVUI       = MKBETAG('A','V','U','I'),
+    CODEC_ID_AYUV       = MKBETAG('A','Y','U','V'),
+    CODEC_ID_V308       = MKBETAG('V','3','0','8'),
+    CODEC_ID_V408       = MKBETAG('V','4','0','8'),
+    CODEC_ID_YUV4       = MKBETAG('Y','U','V','4'),
+    CODEC_ID_SANM       = MKBETAG('S','A','N','M'),
+    CODEC_ID_PAF_VIDEO  = MKBETAG('P','A','F','V'),
+    CODEC_ID_SNOW       = AV_CODEC_ID_SNOW,
+
+    /* various PCM "codecs" */
+    CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
+    CODEC_ID_PCM_S16LE = 0x10000,
+    CODEC_ID_PCM_S16BE,
+    CODEC_ID_PCM_U16LE,
+    CODEC_ID_PCM_U16BE,
+    CODEC_ID_PCM_S8,
+    CODEC_ID_PCM_U8,
+    CODEC_ID_PCM_MULAW,
+    CODEC_ID_PCM_ALAW,
+    CODEC_ID_PCM_S32LE,
+    CODEC_ID_PCM_S32BE,
+    CODEC_ID_PCM_U32LE,
+    CODEC_ID_PCM_U32BE,
+    CODEC_ID_PCM_S24LE,
+    CODEC_ID_PCM_S24BE,
+    CODEC_ID_PCM_U24LE,
+    CODEC_ID_PCM_U24BE,
+    CODEC_ID_PCM_S24DAUD,
+    CODEC_ID_PCM_ZORK,
+    CODEC_ID_PCM_S16LE_PLANAR,
+    CODEC_ID_PCM_DVD,
+    CODEC_ID_PCM_F32BE,
+    CODEC_ID_PCM_F32LE,
+    CODEC_ID_PCM_F64BE,
+    CODEC_ID_PCM_F64LE,
+    CODEC_ID_PCM_BLURAY,
+    CODEC_ID_PCM_LXF,
+    CODEC_ID_S302M,
+    CODEC_ID_PCM_S8_PLANAR,
+
+    /* various ADPCM codecs */
+    CODEC_ID_ADPCM_IMA_QT = 0x11000,
+    CODEC_ID_ADPCM_IMA_WAV,
+    CODEC_ID_ADPCM_IMA_DK3,
+    CODEC_ID_ADPCM_IMA_DK4,
+    CODEC_ID_ADPCM_IMA_WS,
+    CODEC_ID_ADPCM_IMA_SMJPEG,
+    CODEC_ID_ADPCM_MS,
+    CODEC_ID_ADPCM_4XM,
+    CODEC_ID_ADPCM_XA,
+    CODEC_ID_ADPCM_ADX,
+    CODEC_ID_ADPCM_EA,
+    CODEC_ID_ADPCM_G726,
+    CODEC_ID_ADPCM_CT,
+    CODEC_ID_ADPCM_SWF,
+    CODEC_ID_ADPCM_YAMAHA,
+    CODEC_ID_ADPCM_SBPRO_4,
+    CODEC_ID_ADPCM_SBPRO_3,
+    CODEC_ID_ADPCM_SBPRO_2,
+    CODEC_ID_ADPCM_THP,
+    CODEC_ID_ADPCM_IMA_AMV,
+    CODEC_ID_ADPCM_EA_R1,
+    CODEC_ID_ADPCM_EA_R3,
+    CODEC_ID_ADPCM_EA_R2,
+    CODEC_ID_ADPCM_IMA_EA_SEAD,
+    CODEC_ID_ADPCM_IMA_EA_EACS,
+    CODEC_ID_ADPCM_EA_XAS,
+    CODEC_ID_ADPCM_EA_MAXIS_XA,
+    CODEC_ID_ADPCM_IMA_ISS,
+    CODEC_ID_ADPCM_G722,
+    CODEC_ID_ADPCM_IMA_APC,
+    CODEC_ID_VIMA       = MKBETAG('V','I','M','A'),
+
+    /* AMR */
+    CODEC_ID_AMR_NB = 0x12000,
+    CODEC_ID_AMR_WB,
+
+    /* RealAudio codecs*/
+    CODEC_ID_RA_144 = 0x13000,
+    CODEC_ID_RA_288,
+
+    /* various DPCM codecs */
+    CODEC_ID_ROQ_DPCM = 0x14000,
+    CODEC_ID_INTERPLAY_DPCM,
+    CODEC_ID_XAN_DPCM,
+    CODEC_ID_SOL_DPCM,
+
+    /* audio codecs */
+    CODEC_ID_MP2 = 0x15000,
+    CODEC_ID_MP3, ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
+    CODEC_ID_AAC,
+    CODEC_ID_AC3,
+    CODEC_ID_DTS,
+    CODEC_ID_VORBIS,
+    CODEC_ID_DVAUDIO,
+    CODEC_ID_WMAV1,
+    CODEC_ID_WMAV2,
+    CODEC_ID_MACE3,
+    CODEC_ID_MACE6,
+    CODEC_ID_VMDAUDIO,
+    CODEC_ID_FLAC,
+    CODEC_ID_MP3ADU,
+    CODEC_ID_MP3ON4,
+    CODEC_ID_SHORTEN,
+    CODEC_ID_ALAC,
+    CODEC_ID_WESTWOOD_SND1,
+    CODEC_ID_GSM, ///< as in Berlin toast format
+    CODEC_ID_QDM2,
+    CODEC_ID_COOK,
+    CODEC_ID_TRUESPEECH,
+    CODEC_ID_TTA,
+    CODEC_ID_SMACKAUDIO,
+    CODEC_ID_QCELP,
+    CODEC_ID_WAVPACK,
+    CODEC_ID_DSICINAUDIO,
+    CODEC_ID_IMC,
+    CODEC_ID_MUSEPACK7,
+    CODEC_ID_MLP,
+    CODEC_ID_GSM_MS, /* as found in WAV */
+    CODEC_ID_ATRAC3,
+    CODEC_ID_VOXWARE,
+    CODEC_ID_APE,
+    CODEC_ID_NELLYMOSER,
+    CODEC_ID_MUSEPACK8,
+    CODEC_ID_SPEEX,
+    CODEC_ID_WMAVOICE,
+    CODEC_ID_WMAPRO,
+    CODEC_ID_WMALOSSLESS,
+    CODEC_ID_ATRAC3P,
+    CODEC_ID_EAC3,
+    CODEC_ID_SIPR,
+    CODEC_ID_MP1,
+    CODEC_ID_TWINVQ,
+    CODEC_ID_TRUEHD,
+    CODEC_ID_MP4ALS,
+    CODEC_ID_ATRAC1,
+    CODEC_ID_BINKAUDIO_RDFT,
+    CODEC_ID_BINKAUDIO_DCT,
+    CODEC_ID_AAC_LATM,
+    CODEC_ID_QDMC,
+    CODEC_ID_CELT,
+    CODEC_ID_G723_1,
+    CODEC_ID_G729,
+    CODEC_ID_8SVX_EXP,
+    CODEC_ID_8SVX_FIB,
+    CODEC_ID_BMV_AUDIO,
+    CODEC_ID_RALF,
+    CODEC_ID_IAC,
+    CODEC_ID_ILBC,
+    CODEC_ID_FFWAVESYNTH = MKBETAG('F','F','W','S'),
+    CODEC_ID_SONIC       = MKBETAG('S','O','N','C'),
+    CODEC_ID_SONIC_LS    = MKBETAG('S','O','N','L'),
+    CODEC_ID_PAF_AUDIO   = MKBETAG('P','A','F','A'),
+    CODEC_ID_OPUS        = MKBETAG('O','P','U','S'),
+
+    /* subtitle codecs */
+    CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
+    CODEC_ID_DVD_SUBTITLE = 0x17000,
+    CODEC_ID_DVB_SUBTITLE,
+    CODEC_ID_TEXT,  ///< raw UTF-8 text
+    CODEC_ID_XSUB,
+    CODEC_ID_SSA,
+    CODEC_ID_MOV_TEXT,
+    CODEC_ID_HDMV_PGS_SUBTITLE,
+    CODEC_ID_DVB_TELETEXT,
+    CODEC_ID_SRT,
+    CODEC_ID_MICRODVD   = MKBETAG('m','D','V','D'),
+    CODEC_ID_EIA_608    = MKBETAG('c','6','0','8'),
+    CODEC_ID_JACOSUB    = MKBETAG('J','S','U','B'),
+    CODEC_ID_SAMI       = MKBETAG('S','A','M','I'),
+    CODEC_ID_REALTEXT   = MKBETAG('R','T','X','T'),
+    CODEC_ID_SUBVIEWER  = MKBETAG('S','u','b','V'),
+
+    /* other specific kind of codecs (generally used for attachments) */
+    CODEC_ID_FIRST_UNKNOWN = 0x18000,           ///< A dummy ID pointing at the start of various fake codecs.
+    CODEC_ID_TTF = 0x18000,
+    CODEC_ID_BINTEXT    = MKBETAG('B','T','X','T'),
+    CODEC_ID_XBIN       = MKBETAG('X','B','I','N'),
+    CODEC_ID_IDF        = MKBETAG( 0 ,'I','D','F'),
+    CODEC_ID_OTF        = MKBETAG( 0 ,'O','T','F'),
+
+    CODEC_ID_PROBE = 0x19000, ///< codec_id is not known (like CODEC_ID_NONE) but lavf should attempt to identify it
+
+    CODEC_ID_MPEG2TS = 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
+                                * stream (only used by libavformat) */
+    CODEC_ID_MPEG4SYSTEMS = 0x20001, /**< _FAKE_ codec to indicate a MPEG-4 Systems
+                                * stream (only used by libavformat) */
+    CODEC_ID_FFMETADATA = 0x21000,   ///< Dummy codec for streams containing only metadata information.
+
+};
+
+#endif
diff -pruN /usr/include/ffmpeg/libavcodec/avfft.h csrc/libavcodec/avfft.h
--- /usr/include/ffmpeg/libavcodec/avfft.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/avfft.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,118 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_AVFFT_H
-#define AVCODEC_AVFFT_H
-
-/**
- * @file
- * @ingroup lavc_fft
- * FFT functions
- */
-
-/**
- * @defgroup lavc_fft FFT functions
- * @ingroup lavc_misc
- *
- * @{
- */
-
-typedef float FFTSample;
-
-typedef struct FFTComplex {
-    FFTSample re, im;
-} FFTComplex;
-
-typedef struct FFTContext FFTContext;
-
-/**
- * Set up a complex FFT.
- * @param nbits           log2 of the length of the input array
- * @param inverse         if 0 perform the forward transform, if 1 perform the inverse
- */
-FFTContext *av_fft_init(int nbits, int inverse);
-
-/**
- * Do the permutation needed BEFORE calling ff_fft_calc().
- */
-void av_fft_permute(FFTContext *s, FFTComplex *z);
-
-/**
- * Do a complex FFT with the parameters defined in av_fft_init(). The
- * input data must be permuted before. No 1.0/sqrt(n) normalization is done.
- */
-void av_fft_calc(FFTContext *s, FFTComplex *z);
-
-void av_fft_end(FFTContext *s);
-
-FFTContext *av_mdct_init(int nbits, int inverse, double scale);
-void av_imdct_calc(FFTContext *s, FFTSample *output, const FFTSample *input);
-void av_imdct_half(FFTContext *s, FFTSample *output, const FFTSample *input);
-void av_mdct_calc(FFTContext *s, FFTSample *output, const FFTSample *input);
-void av_mdct_end(FFTContext *s);
-
-/* Real Discrete Fourier Transform */
-
-enum RDFTransformType {
-    DFT_R2C,
-    IDFT_C2R,
-    IDFT_R2C,
-    DFT_C2R,
-};
-
-typedef struct RDFTContext RDFTContext;
-
-/**
- * Set up a real FFT.
- * @param nbits           log2 of the length of the input array
- * @param trans           the type of transform
- */
-RDFTContext *av_rdft_init(int nbits, enum RDFTransformType trans);
-void av_rdft_calc(RDFTContext *s, FFTSample *data);
-void av_rdft_end(RDFTContext *s);
-
-/* Discrete Cosine Transform */
-
-typedef struct DCTContext DCTContext;
-
-enum DCTTransformType {
-    DCT_II = 0,
-    DCT_III,
-    DCT_I,
-    DST_I,
-};
-
-/**
- * Set up DCT.
- *
- * @param nbits           size of the input array:
- *                        (1 << nbits)     for DCT-II, DCT-III and DST-I
- *                        (1 << nbits) + 1 for DCT-I
- * @param type            the type of transform
- *
- * @note the first element of the input of DST-I is ignored
- */
-DCTContext *av_dct_init(int nbits, enum DCTTransformType type);
-void av_dct_calc(DCTContext *s, FFTSample *data);
-void av_dct_end (DCTContext *s);
-
-/**
- * @}
- */
-
-#endif /* AVCODEC_AVFFT_H */
diff -pruN /usr/include/ffmpeg/libavcodec/dvdata.h csrc/libavcodec/dvdata.h
--- /usr/include/ffmpeg/libavcodec/dvdata.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavcodec/dvdata.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_DVDATA_H
-#define AVCODEC_DVDATA_H
-
-#include <stdint.h>
-
-extern const uint8_t ff_dv_zigzag248_direct[64];
-
-extern const uint8_t ff_dv_quant_shifts[22][4];
-extern const uint8_t ff_dv_quant_offset[4];
-
-extern const int ff_dv_iweight_88[64];
-extern const int ff_dv_iweight_248[64];
-extern const int ff_dv_iweight_1080_y[64];
-extern const int ff_dv_iweight_1080_c[64];
-extern const int ff_dv_iweight_720_y[64];
-extern const int ff_dv_iweight_720_c[64];
-
-#define NB_DV_VLC 409
-
-extern const uint16_t ff_dv_vlc_bits[NB_DV_VLC];
-extern const uint8_t ff_dv_vlc_len[NB_DV_VLC];
-extern const uint8_t ff_dv_vlc_run[NB_DV_VLC];
-extern const uint8_t ff_dv_vlc_level[NB_DV_VLC];
-
-#endif /* AVCODEC_DVDATA_H */
diff -pruN /usr/include/ffmpeg/libavcodec/dv_profile.h csrc/libavcodec/dv_profile.h
--- /usr/include/ffmpeg/libavcodec/dv_profile.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/dv_profile.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_DV_PROFILE_H
-#define AVCODEC_DV_PROFILE_H
-
-#include <stdint.h>
-
-#include "libavutil/pixfmt.h"
-#include "libavutil/rational.h"
-#include "avcodec.h"
-
-/* minimum number of bytes to read from a DV stream in order to
-   determine the profile */
-#define DV_PROFILE_BYTES (6*80) /* 6 DIF blocks */
-
-/*
- * AVDVProfile is used to express the differences between various
- * DV flavors. For now it's primarily used for differentiating
- * 525/60 and 625/50, but the plans are to use it for various
- * DV specs as well (e.g. SMPTE314M vs. IEC 61834).
- */
-typedef struct AVDVProfile {
-    int              dsf;                   /* value of the dsf in the DV header */
-    int              video_stype;           /* stype for VAUX source pack */
-    int              frame_size;            /* total size of one frame in bytes */
-    int              difseg_size;           /* number of DIF segments per DIF channel */
-    int              n_difchan;             /* number of DIF channels per frame */
-    AVRational       time_base;             /* 1/framerate */
-    int              ltc_divisor;           /* FPS from the LTS standpoint */
-    int              height;                /* picture height in pixels */
-    int              width;                 /* picture width in pixels */
-    AVRational       sar[2];                /* sample aspect ratios for 4:3 and 16:9 */
-    enum AVPixelFormat pix_fmt;             /* picture pixel format */
-    int              bpm;                   /* blocks per macroblock */
-    const uint8_t   *block_sizes;           /* AC block sizes, in bits */
-    int              audio_stride;          /* size of audio_shuffle table */
-    int              audio_min_samples[3];  /* min amount of audio samples */
-                                            /* for 48kHz, 44.1kHz and 32kHz */
-    int              audio_samples_dist[5]; /* how many samples are supposed to be */
-                                            /* in each frame in a 5 frames window */
-    const uint8_t  (*audio_shuffle)[9];     /* PCM shuffling table */
-} AVDVProfile;
-
-const AVDVProfile* avpriv_dv_frame_profile2(AVCodecContext* codec, const AVDVProfile *sys,
-                                            const uint8_t* frame, unsigned buf_size);
-#if LIBAVCODEC_VERSION_MAJOR < 56
-const AVDVProfile *avpriv_dv_frame_profile(const AVDVProfile *sys,
-                                           const uint8_t* frame, unsigned buf_size);
-const AVDVProfile *avpriv_dv_codec_profile(AVCodecContext* codec);
-#endif
-
-/**
- * Get a DV profile for the provided compressed frame.
- *
- * @param sys the profile used for the previous frame, may be NULL
- * @param frame the compressed data buffer
- * @param buf_size size of the buffer in bytes
- * @return the DV profile for the supplied data or NULL on failure
- */
-const AVDVProfile *av_dv_frame_profile(const AVDVProfile *sys,
-                                       const uint8_t *frame, unsigned buf_size);
-
-/**
- * Get a DV profile for the provided stream parameters.
- */
-const AVDVProfile *av_dv_codec_profile(int width, int height, enum AVPixelFormat pix_fmt);
-
-#endif /* AVCODEC_DV_PROFILE_H */
diff -pruN /usr/include/ffmpeg/libavcodec/dxva2.h csrc/libavcodec/dxva2.h
--- /usr/include/ffmpeg/libavcodec/dxva2.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/dxva2.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-/*
- * DXVA2 HW acceleration
- *
- * copyright (c) 2009 Laurent Aimar
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_DXVA_H
-#define AVCODEC_DXVA_H
-
-/**
- * @file
- * @ingroup lavc_codec_hwaccel_dxva2
- * Public libavcodec DXVA2 header.
- */
-
-#if defined(_WIN32_WINNT) && _WIN32_WINNT < 0x0600
-#undef _WIN32_WINNT
-#endif
-
-#if !defined(_WIN32_WINNT)
-#define _WIN32_WINNT 0x0600
-#endif
-
-#include <stdint.h>
-#include <d3d9.h>
-#include <dxva2api.h>
-
-/**
- * @defgroup lavc_codec_hwaccel_dxva2 DXVA2
- * @ingroup lavc_codec_hwaccel
- *
- * @{
- */
-
-#define FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG 1 ///< Work around for DXVA2 and old UVD/UVD+ ATI video cards
-#define FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO    2 ///< Work around for DXVA2 and old Intel GPUs with ClearVideo interface
-
-/**
- * This structure is used to provides the necessary configurations and data
- * to the DXVA2 FFmpeg HWAccel implementation.
- *
- * The application must make it available as AVCodecContext.hwaccel_context.
- */
-struct dxva_context {
-    /**
-     * DXVA2 decoder object
-     */
-    IDirectXVideoDecoder *decoder;
-
-    /**
-     * DXVA2 configuration used to create the decoder
-     */
-    const DXVA2_ConfigPictureDecode *cfg;
-
-    /**
-     * The number of surface in the surface array
-     */
-    unsigned surface_count;
-
-    /**
-     * The array of Direct3D surfaces used to create the decoder
-     */
-    LPDIRECT3DSURFACE9 *surface;
-
-    /**
-     * A bit field configuring the workarounds needed for using the decoder
-     */
-    uint64_t workaround;
-
-    /**
-     * Private to the FFmpeg AVHWAccel implementation
-     */
-    unsigned report_id;
-};
-
-/**
- * @}
- */
-
-#endif /* AVCODEC_DXVA_H */
diff -pruN /usr/include/ffmpeg/libavcodec/old_codec_ids.h csrc/libavcodec/old_codec_ids.h
--- /usr/include/ffmpeg/libavcodec/old_codec_ids.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/old_codec_ids.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,397 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_OLD_CODEC_IDS_H
-#define AVCODEC_OLD_CODEC_IDS_H
-
-/*
- * This header exists to prevent new codec IDs from being accidentally added to
- * the deprecated list.
- * Do not include it directly. It will be removed on next major bump
- *
- * Do not add new items to this list. Use the AVCodecID enum instead.
- */
-
-    CODEC_ID_NONE = AV_CODEC_ID_NONE,
-
-    /* video codecs */
-    CODEC_ID_MPEG1VIDEO,
-    CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
-#if FF_API_XVMC
-    CODEC_ID_MPEG2VIDEO_XVMC,
-#endif
-    CODEC_ID_H261,
-    CODEC_ID_H263,
-    CODEC_ID_RV10,
-    CODEC_ID_RV20,
-    CODEC_ID_MJPEG,
-    CODEC_ID_MJPEGB,
-    CODEC_ID_LJPEG,
-    CODEC_ID_SP5X,
-    CODEC_ID_JPEGLS,
-    CODEC_ID_MPEG4,
-    CODEC_ID_RAWVIDEO,
-    CODEC_ID_MSMPEG4V1,
-    CODEC_ID_MSMPEG4V2,
-    CODEC_ID_MSMPEG4V3,
-    CODEC_ID_WMV1,
-    CODEC_ID_WMV2,
-    CODEC_ID_H263P,
-    CODEC_ID_H263I,
-    CODEC_ID_FLV1,
-    CODEC_ID_SVQ1,
-    CODEC_ID_SVQ3,
-    CODEC_ID_DVVIDEO,
-    CODEC_ID_HUFFYUV,
-    CODEC_ID_CYUV,
-    CODEC_ID_H264,
-    CODEC_ID_INDEO3,
-    CODEC_ID_VP3,
-    CODEC_ID_THEORA,
-    CODEC_ID_ASV1,
-    CODEC_ID_ASV2,
-    CODEC_ID_FFV1,
-    CODEC_ID_4XM,
-    CODEC_ID_VCR1,
-    CODEC_ID_CLJR,
-    CODEC_ID_MDEC,
-    CODEC_ID_ROQ,
-    CODEC_ID_INTERPLAY_VIDEO,
-    CODEC_ID_XAN_WC3,
-    CODEC_ID_XAN_WC4,
-    CODEC_ID_RPZA,
-    CODEC_ID_CINEPAK,
-    CODEC_ID_WS_VQA,
-    CODEC_ID_MSRLE,
-    CODEC_ID_MSVIDEO1,
-    CODEC_ID_IDCIN,
-    CODEC_ID_8BPS,
-    CODEC_ID_SMC,
-    CODEC_ID_FLIC,
-    CODEC_ID_TRUEMOTION1,
-    CODEC_ID_VMDVIDEO,
-    CODEC_ID_MSZH,
-    CODEC_ID_ZLIB,
-    CODEC_ID_QTRLE,
-    CODEC_ID_TSCC,
-    CODEC_ID_ULTI,
-    CODEC_ID_QDRAW,
-    CODEC_ID_VIXL,
-    CODEC_ID_QPEG,
-    CODEC_ID_PNG,
-    CODEC_ID_PPM,
-    CODEC_ID_PBM,
-    CODEC_ID_PGM,
-    CODEC_ID_PGMYUV,
-    CODEC_ID_PAM,
-    CODEC_ID_FFVHUFF,
-    CODEC_ID_RV30,
-    CODEC_ID_RV40,
-    CODEC_ID_VC1,
-    CODEC_ID_WMV3,
-    CODEC_ID_LOCO,
-    CODEC_ID_WNV1,
-    CODEC_ID_AASC,
-    CODEC_ID_INDEO2,
-    CODEC_ID_FRAPS,
-    CODEC_ID_TRUEMOTION2,
-    CODEC_ID_BMP,
-    CODEC_ID_CSCD,
-    CODEC_ID_MMVIDEO,
-    CODEC_ID_ZMBV,
-    CODEC_ID_AVS,
-    CODEC_ID_SMACKVIDEO,
-    CODEC_ID_NUV,
-    CODEC_ID_KMVC,
-    CODEC_ID_FLASHSV,
-    CODEC_ID_CAVS,
-    CODEC_ID_JPEG2000,
-    CODEC_ID_VMNC,
-    CODEC_ID_VP5,
-    CODEC_ID_VP6,
-    CODEC_ID_VP6F,
-    CODEC_ID_TARGA,
-    CODEC_ID_DSICINVIDEO,
-    CODEC_ID_TIERTEXSEQVIDEO,
-    CODEC_ID_TIFF,
-    CODEC_ID_GIF,
-    CODEC_ID_DXA,
-    CODEC_ID_DNXHD,
-    CODEC_ID_THP,
-    CODEC_ID_SGI,
-    CODEC_ID_C93,
-    CODEC_ID_BETHSOFTVID,
-    CODEC_ID_PTX,
-    CODEC_ID_TXD,
-    CODEC_ID_VP6A,
-    CODEC_ID_AMV,
-    CODEC_ID_VB,
-    CODEC_ID_PCX,
-    CODEC_ID_SUNRAST,
-    CODEC_ID_INDEO4,
-    CODEC_ID_INDEO5,
-    CODEC_ID_MIMIC,
-    CODEC_ID_RL2,
-    CODEC_ID_ESCAPE124,
-    CODEC_ID_DIRAC,
-    CODEC_ID_BFI,
-    CODEC_ID_CMV,
-    CODEC_ID_MOTIONPIXELS,
-    CODEC_ID_TGV,
-    CODEC_ID_TGQ,
-    CODEC_ID_TQI,
-    CODEC_ID_AURA,
-    CODEC_ID_AURA2,
-    CODEC_ID_V210X,
-    CODEC_ID_TMV,
-    CODEC_ID_V210,
-    CODEC_ID_DPX,
-    CODEC_ID_MAD,
-    CODEC_ID_FRWU,
-    CODEC_ID_FLASHSV2,
-    CODEC_ID_CDGRAPHICS,
-    CODEC_ID_R210,
-    CODEC_ID_ANM,
-    CODEC_ID_BINKVIDEO,
-    CODEC_ID_IFF_ILBM,
-    CODEC_ID_IFF_BYTERUN1,
-    CODEC_ID_KGV1,
-    CODEC_ID_YOP,
-    CODEC_ID_VP8,
-    CODEC_ID_PICTOR,
-    CODEC_ID_ANSI,
-    CODEC_ID_A64_MULTI,
-    CODEC_ID_A64_MULTI5,
-    CODEC_ID_R10K,
-    CODEC_ID_MXPEG,
-    CODEC_ID_LAGARITH,
-    CODEC_ID_PRORES,
-    CODEC_ID_JV,
-    CODEC_ID_DFA,
-    CODEC_ID_WMV3IMAGE,
-    CODEC_ID_VC1IMAGE,
-    CODEC_ID_UTVIDEO,
-    CODEC_ID_BMV_VIDEO,
-    CODEC_ID_VBLE,
-    CODEC_ID_DXTORY,
-    CODEC_ID_V410,
-    CODEC_ID_XWD,
-    CODEC_ID_CDXL,
-    CODEC_ID_XBM,
-    CODEC_ID_ZEROCODEC,
-    CODEC_ID_MSS1,
-    CODEC_ID_MSA1,
-    CODEC_ID_TSCC2,
-    CODEC_ID_MTS2,
-    CODEC_ID_CLLC,
-    CODEC_ID_Y41P       = MKBETAG('Y','4','1','P'),
-    CODEC_ID_ESCAPE130  = MKBETAG('E','1','3','0'),
-    CODEC_ID_EXR        = MKBETAG('0','E','X','R'),
-    CODEC_ID_AVRP       = MKBETAG('A','V','R','P'),
-
-    CODEC_ID_G2M        = MKBETAG( 0 ,'G','2','M'),
-    CODEC_ID_AVUI       = MKBETAG('A','V','U','I'),
-    CODEC_ID_AYUV       = MKBETAG('A','Y','U','V'),
-    CODEC_ID_V308       = MKBETAG('V','3','0','8'),
-    CODEC_ID_V408       = MKBETAG('V','4','0','8'),
-    CODEC_ID_YUV4       = MKBETAG('Y','U','V','4'),
-    CODEC_ID_SANM       = MKBETAG('S','A','N','M'),
-    CODEC_ID_PAF_VIDEO  = MKBETAG('P','A','F','V'),
-    CODEC_ID_SNOW       = AV_CODEC_ID_SNOW,
-
-    /* various PCM "codecs" */
-    CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
-    CODEC_ID_PCM_S16LE = 0x10000,
-    CODEC_ID_PCM_S16BE,
-    CODEC_ID_PCM_U16LE,
-    CODEC_ID_PCM_U16BE,
-    CODEC_ID_PCM_S8,
-    CODEC_ID_PCM_U8,
-    CODEC_ID_PCM_MULAW,
-    CODEC_ID_PCM_ALAW,
-    CODEC_ID_PCM_S32LE,
-    CODEC_ID_PCM_S32BE,
-    CODEC_ID_PCM_U32LE,
-    CODEC_ID_PCM_U32BE,
-    CODEC_ID_PCM_S24LE,
-    CODEC_ID_PCM_S24BE,
-    CODEC_ID_PCM_U24LE,
-    CODEC_ID_PCM_U24BE,
-    CODEC_ID_PCM_S24DAUD,
-    CODEC_ID_PCM_ZORK,
-    CODEC_ID_PCM_S16LE_PLANAR,
-    CODEC_ID_PCM_DVD,
-    CODEC_ID_PCM_F32BE,
-    CODEC_ID_PCM_F32LE,
-    CODEC_ID_PCM_F64BE,
-    CODEC_ID_PCM_F64LE,
-    CODEC_ID_PCM_BLURAY,
-    CODEC_ID_PCM_LXF,
-    CODEC_ID_S302M,
-    CODEC_ID_PCM_S8_PLANAR,
-
-    /* various ADPCM codecs */
-    CODEC_ID_ADPCM_IMA_QT = 0x11000,
-    CODEC_ID_ADPCM_IMA_WAV,
-    CODEC_ID_ADPCM_IMA_DK3,
-    CODEC_ID_ADPCM_IMA_DK4,
-    CODEC_ID_ADPCM_IMA_WS,
-    CODEC_ID_ADPCM_IMA_SMJPEG,
-    CODEC_ID_ADPCM_MS,
-    CODEC_ID_ADPCM_4XM,
-    CODEC_ID_ADPCM_XA,
-    CODEC_ID_ADPCM_ADX,
-    CODEC_ID_ADPCM_EA,
-    CODEC_ID_ADPCM_G726,
-    CODEC_ID_ADPCM_CT,
-    CODEC_ID_ADPCM_SWF,
-    CODEC_ID_ADPCM_YAMAHA,
-    CODEC_ID_ADPCM_SBPRO_4,
-    CODEC_ID_ADPCM_SBPRO_3,
-    CODEC_ID_ADPCM_SBPRO_2,
-    CODEC_ID_ADPCM_THP,
-    CODEC_ID_ADPCM_IMA_AMV,
-    CODEC_ID_ADPCM_EA_R1,
-    CODEC_ID_ADPCM_EA_R3,
-    CODEC_ID_ADPCM_EA_R2,
-    CODEC_ID_ADPCM_IMA_EA_SEAD,
-    CODEC_ID_ADPCM_IMA_EA_EACS,
-    CODEC_ID_ADPCM_EA_XAS,
-    CODEC_ID_ADPCM_EA_MAXIS_XA,
-    CODEC_ID_ADPCM_IMA_ISS,
-    CODEC_ID_ADPCM_G722,
-    CODEC_ID_ADPCM_IMA_APC,
-    CODEC_ID_VIMA       = MKBETAG('V','I','M','A'),
-
-    /* AMR */
-    CODEC_ID_AMR_NB = 0x12000,
-    CODEC_ID_AMR_WB,
-
-    /* RealAudio codecs*/
-    CODEC_ID_RA_144 = 0x13000,
-    CODEC_ID_RA_288,
-
-    /* various DPCM codecs */
-    CODEC_ID_ROQ_DPCM = 0x14000,
-    CODEC_ID_INTERPLAY_DPCM,
-    CODEC_ID_XAN_DPCM,
-    CODEC_ID_SOL_DPCM,
-
-    /* audio codecs */
-    CODEC_ID_MP2 = 0x15000,
-    CODEC_ID_MP3, ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
-    CODEC_ID_AAC,
-    CODEC_ID_AC3,
-    CODEC_ID_DTS,
-    CODEC_ID_VORBIS,
-    CODEC_ID_DVAUDIO,
-    CODEC_ID_WMAV1,
-    CODEC_ID_WMAV2,
-    CODEC_ID_MACE3,
-    CODEC_ID_MACE6,
-    CODEC_ID_VMDAUDIO,
-    CODEC_ID_FLAC,
-    CODEC_ID_MP3ADU,
-    CODEC_ID_MP3ON4,
-    CODEC_ID_SHORTEN,
-    CODEC_ID_ALAC,
-    CODEC_ID_WESTWOOD_SND1,
-    CODEC_ID_GSM, ///< as in Berlin toast format
-    CODEC_ID_QDM2,
-    CODEC_ID_COOK,
-    CODEC_ID_TRUESPEECH,
-    CODEC_ID_TTA,
-    CODEC_ID_SMACKAUDIO,
-    CODEC_ID_QCELP,
-    CODEC_ID_WAVPACK,
-    CODEC_ID_DSICINAUDIO,
-    CODEC_ID_IMC,
-    CODEC_ID_MUSEPACK7,
-    CODEC_ID_MLP,
-    CODEC_ID_GSM_MS, /* as found in WAV */
-    CODEC_ID_ATRAC3,
-    CODEC_ID_VOXWARE,
-    CODEC_ID_APE,
-    CODEC_ID_NELLYMOSER,
-    CODEC_ID_MUSEPACK8,
-    CODEC_ID_SPEEX,
-    CODEC_ID_WMAVOICE,
-    CODEC_ID_WMAPRO,
-    CODEC_ID_WMALOSSLESS,
-    CODEC_ID_ATRAC3P,
-    CODEC_ID_EAC3,
-    CODEC_ID_SIPR,
-    CODEC_ID_MP1,
-    CODEC_ID_TWINVQ,
-    CODEC_ID_TRUEHD,
-    CODEC_ID_MP4ALS,
-    CODEC_ID_ATRAC1,
-    CODEC_ID_BINKAUDIO_RDFT,
-    CODEC_ID_BINKAUDIO_DCT,
-    CODEC_ID_AAC_LATM,
-    CODEC_ID_QDMC,
-    CODEC_ID_CELT,
-    CODEC_ID_G723_1,
-    CODEC_ID_G729,
-    CODEC_ID_8SVX_EXP,
-    CODEC_ID_8SVX_FIB,
-    CODEC_ID_BMV_AUDIO,
-    CODEC_ID_RALF,
-    CODEC_ID_IAC,
-    CODEC_ID_ILBC,
-    CODEC_ID_FFWAVESYNTH = MKBETAG('F','F','W','S'),
-    CODEC_ID_SONIC       = MKBETAG('S','O','N','C'),
-    CODEC_ID_SONIC_LS    = MKBETAG('S','O','N','L'),
-    CODEC_ID_PAF_AUDIO   = MKBETAG('P','A','F','A'),
-    CODEC_ID_OPUS        = MKBETAG('O','P','U','S'),
-
-    /* subtitle codecs */
-    CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
-    CODEC_ID_DVD_SUBTITLE = 0x17000,
-    CODEC_ID_DVB_SUBTITLE,
-    CODEC_ID_TEXT,  ///< raw UTF-8 text
-    CODEC_ID_XSUB,
-    CODEC_ID_SSA,
-    CODEC_ID_MOV_TEXT,
-    CODEC_ID_HDMV_PGS_SUBTITLE,
-    CODEC_ID_DVB_TELETEXT,
-    CODEC_ID_SRT,
-    CODEC_ID_MICRODVD   = MKBETAG('m','D','V','D'),
-    CODEC_ID_EIA_608    = MKBETAG('c','6','0','8'),
-    CODEC_ID_JACOSUB    = MKBETAG('J','S','U','B'),
-    CODEC_ID_SAMI       = MKBETAG('S','A','M','I'),
-    CODEC_ID_REALTEXT   = MKBETAG('R','T','X','T'),
-    CODEC_ID_SUBVIEWER  = MKBETAG('S','u','b','V'),
-
-    /* other specific kind of codecs (generally used for attachments) */
-    CODEC_ID_FIRST_UNKNOWN = 0x18000,           ///< A dummy ID pointing at the start of various fake codecs.
-    CODEC_ID_TTF = 0x18000,
-    CODEC_ID_BINTEXT    = MKBETAG('B','T','X','T'),
-    CODEC_ID_XBIN       = MKBETAG('X','B','I','N'),
-    CODEC_ID_IDF        = MKBETAG( 0 ,'I','D','F'),
-    CODEC_ID_OTF        = MKBETAG( 0 ,'O','T','F'),
-
-    CODEC_ID_PROBE = 0x19000, ///< codec_id is not known (like CODEC_ID_NONE) but lavf should attempt to identify it
-
-    CODEC_ID_MPEG2TS = 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
-                                * stream (only used by libavformat) */
-    CODEC_ID_MPEG4SYSTEMS = 0x20001, /**< _FAKE_ codec to indicate a MPEG-4 Systems
-                                * stream (only used by libavformat) */
-    CODEC_ID_FFMETADATA = 0x21000,   ///< Dummy codec for streams containing only metadata information.
-
-#endif /* AVCODEC_OLD_CODEC_IDS_H */
diff -pruN /usr/include/ffmpeg/libavcodec/vaapi.h csrc/libavcodec/vaapi.h
--- /usr/include/ffmpeg/libavcodec/vaapi.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/vaapi.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,173 +0,0 @@
-/*
- * Video Acceleration API (shared data between FFmpeg and the video player)
- * HW decode acceleration for MPEG-2, MPEG-4, H.264 and VC-1
- *
- * Copyright (C) 2008-2009 Splitted-Desktop Systems
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_VAAPI_H
-#define AVCODEC_VAAPI_H
-
-/**
- * @file
- * @ingroup lavc_codec_hwaccel_vaapi
- * Public libavcodec VA API header.
- */
-
-#include <stdint.h>
-
-/**
- * @defgroup lavc_codec_hwaccel_vaapi VA API Decoding
- * @ingroup lavc_codec_hwaccel
- * @{
- */
-
-/**
- * This structure is used to share data between the FFmpeg library and
- * the client video application.
- * This shall be zero-allocated and available as
- * AVCodecContext.hwaccel_context. All user members can be set once
- * during initialization or through each AVCodecContext.get_buffer()
- * function call. In any case, they must be valid prior to calling
- * decoding functions.
- */
-struct vaapi_context {
-    /**
-     * Window system dependent data
-     *
-     * - encoding: unused
-     * - decoding: Set by user
-     */
-    void *display;
-
-    /**
-     * Configuration ID
-     *
-     * - encoding: unused
-     * - decoding: Set by user
-     */
-    uint32_t config_id;
-
-    /**
-     * Context ID (video decode pipeline)
-     *
-     * - encoding: unused
-     * - decoding: Set by user
-     */
-    uint32_t context_id;
-
-    /**
-     * VAPictureParameterBuffer ID
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    uint32_t pic_param_buf_id;
-
-    /**
-     * VAIQMatrixBuffer ID
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    uint32_t iq_matrix_buf_id;
-
-    /**
-     * VABitPlaneBuffer ID (for VC-1 decoding)
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    uint32_t bitplane_buf_id;
-
-    /**
-     * Slice parameter/data buffer IDs
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    uint32_t *slice_buf_ids;
-
-    /**
-     * Number of effective slice buffer IDs to send to the HW
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    unsigned int n_slice_buf_ids;
-
-    /**
-     * Size of pre-allocated slice_buf_ids
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    unsigned int slice_buf_ids_alloc;
-
-    /**
-     * Pointer to VASliceParameterBuffers
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    void *slice_params;
-
-    /**
-     * Size of a VASliceParameterBuffer element
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    unsigned int slice_param_size;
-
-    /**
-     * Size of pre-allocated slice_params
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    unsigned int slice_params_alloc;
-
-    /**
-     * Number of slices currently filled in
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    unsigned int slice_count;
-
-    /**
-     * Pointer to slice data buffer base
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    const uint8_t *slice_data;
-
-    /**
-     * Current size of slice data
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     */
-    uint32_t slice_data_size;
-};
-
-/* @} */
-
-#endif /* AVCODEC_VAAPI_H */
diff -pruN /usr/include/ffmpeg/libavcodec/vda.h csrc/libavcodec/vda.h
--- /usr/include/ffmpeg/libavcodec/vda.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/vda.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,213 +0,0 @@
-/*
- * VDA HW acceleration
- *
- * copyright (c) 2011 Sebastien Zwickert
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_VDA_H
-#define AVCODEC_VDA_H
-
-/**
- * @file
- * @ingroup lavc_codec_hwaccel_vda
- * Public libavcodec VDA header.
- */
-
-#include "libavcodec/avcodec.h"
-
-#include <stdint.h>
-
-// emmintrin.h is unable to compile with -std=c99 -Werror=missing-prototypes
-// http://openradar.appspot.com/8026390
-#undef __GNUC_STDC_INLINE__
-
-#define Picture QuickdrawPicture
-#include <VideoDecodeAcceleration/VDADecoder.h>
-#undef Picture
-
-#include "libavcodec/version.h"
-
-// extra flags not defined in VDADecoder.h
-enum {
-    kVDADecodeInfo_Asynchronous = 1UL << 0,
-    kVDADecodeInfo_FrameDropped = 1UL << 1
-};
-
-/**
- * @defgroup lavc_codec_hwaccel_vda VDA
- * @ingroup lavc_codec_hwaccel
- *
- * @{
- */
-
-/**
- * This structure is used to provide the necessary configurations and data
- * to the VDA FFmpeg HWAccel implementation.
- *
- * The application must make it available as AVCodecContext.hwaccel_context.
- */
-struct vda_context {
-    /**
-     * VDA decoder object.
-     *
-     * - encoding: unused
-     * - decoding: Set/Unset by libavcodec.
-     */
-    VDADecoder          decoder;
-
-    /**
-     * The Core Video pixel buffer that contains the current image data.
-     *
-     * encoding: unused
-     * decoding: Set by libavcodec. Unset by user.
-     */
-    CVPixelBufferRef    cv_buffer;
-
-    /**
-     * Use the hardware decoder in synchronous mode.
-     *
-     * encoding: unused
-     * decoding: Set by user.
-     */
-    int                 use_sync_decoding;
-
-    /**
-     * The frame width.
-     *
-     * - encoding: unused
-     * - decoding: Set/Unset by user.
-     */
-    int                 width;
-
-    /**
-     * The frame height.
-     *
-     * - encoding: unused
-     * - decoding: Set/Unset by user.
-     */
-    int                 height;
-
-    /**
-     * The frame format.
-     *
-     * - encoding: unused
-     * - decoding: Set/Unset by user.
-     */
-    int                 format;
-
-    /**
-     * The pixel format for output image buffers.
-     *
-     * - encoding: unused
-     * - decoding: Set/Unset by user.
-     */
-    OSType              cv_pix_fmt_type;
-
-    /**
-     * unused
-     */
-    uint8_t             *priv_bitstream;
-
-    /**
-     * unused
-     */
-    int                 priv_bitstream_size;
-
-    /**
-     * unused
-     */
-    int                 priv_allocated_size;
-
-    /**
-     * Use av_buffer to manage buffer.
-     * When the flag is set, the CVPixelBuffers returned by the decoder will
-     * be released automatically, so you have to retain them if necessary.
-     * Not setting this flag may cause memory leak.
-     *
-     * encoding: unused
-     * decoding: Set by user.
-     */
-    int                 use_ref_buffer;
-};
-
-/** Create the video decoder. */
-int ff_vda_create_decoder(struct vda_context *vda_ctx,
-                          uint8_t *extradata,
-                          int extradata_size);
-
-/** Destroy the video decoder. */
-int ff_vda_destroy_decoder(struct vda_context *vda_ctx);
-
-/**
- * This struct holds all the information that needs to be passed
- * between the caller and libavcodec for initializing VDA decoding.
- * Its size is not a part of the public ABI, it must be allocated with
- * av_vda_alloc_context() and freed with av_free().
- */
-typedef struct AVVDAContext {
-    /**
-     * VDA decoder object. Created and freed by the caller.
-     */
-    VDADecoder decoder;
-
-    /**
-     * The output callback that must be passed to VDADecoderCreate.
-     * Set by av_vda_alloc_context().
-     */
-    VDADecoderOutputCallback output_callback;
-} AVVDAContext;
-
-/**
- * Allocate and initialize a VDA context.
- *
- * This function should be called from the get_format() callback when the caller
- * selects the AV_PIX_FMT_VDA format. The caller must then create the decoder
- * object (using the output callback provided by libavcodec) that will be used
- * for VDA-accelerated decoding.
- *
- * When decoding with VDA is finished, the caller must destroy the decoder
- * object and free the VDA context using av_free().
- *
- * @return the newly allocated context or NULL on failure
- */
-AVVDAContext *av_vda_alloc_context(void);
-
-/**
- * This is a convenience function that creates and sets up the VDA context using
- * an internal implementation.
- *
- * @param avctx the corresponding codec context
- *
- * @return >= 0 on success, a negative AVERROR code on failure
- */
-int av_vda_default_init(AVCodecContext *avctx);
-
-/**
- * This function must be called to free the VDA context initialized with
- * av_vda_default_init().
- *
- * @param avctx the corresponding codec context
- */
-void av_vda_default_free(AVCodecContext *avctx);
-
-/**
- * @}
- */
-
-#endif /* AVCODEC_VDA_H */
diff -pruN /usr/include/ffmpeg/libavcodec/vdpau.h csrc/libavcodec/vdpau.h
--- /usr/include/ffmpeg/libavcodec/vdpau.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/vdpau.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,215 +0,0 @@
-/*
- * The Video Decode and Presentation API for UNIX (VDPAU) is used for
- * hardware-accelerated decoding of MPEG-1/2, H.264 and VC-1.
- *
- * Copyright (C) 2008 NVIDIA
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_VDPAU_H
-#define AVCODEC_VDPAU_H
-
-/**
- * @file
- * @ingroup lavc_codec_hwaccel_vdpau
- * Public libavcodec VDPAU header.
- */
-
-
-/**
- * @defgroup lavc_codec_hwaccel_vdpau VDPAU Decoder and Renderer
- * @ingroup lavc_codec_hwaccel
- *
- * VDPAU hardware acceleration has two modules
- * - VDPAU decoding
- * - VDPAU presentation
- *
- * The VDPAU decoding module parses all headers using FFmpeg
- * parsing mechanisms and uses VDPAU for the actual decoding.
- *
- * As per the current implementation, the actual decoding
- * and rendering (API calls) are done as part of the VDPAU
- * presentation (vo_vdpau.c) module.
- *
- * @{
- */
-
-#include <vdpau/vdpau.h>
-#include <vdpau/vdpau_x11.h>
-#include "libavutil/avconfig.h"
-#include "libavutil/attributes.h"
-
-#include "avcodec.h"
-#include "version.h"
-
-#if FF_API_BUFS_VDPAU
-union AVVDPAUPictureInfo {
-    VdpPictureInfoH264        h264;
-    VdpPictureInfoMPEG1Or2    mpeg;
-    VdpPictureInfoVC1          vc1;
-    VdpPictureInfoMPEG4Part2 mpeg4;
-};
-#endif
-
-struct AVCodecContext;
-struct AVFrame;
-
-typedef int (*AVVDPAU_Render2)(struct AVCodecContext *, struct AVFrame *,
-                               const VdpPictureInfo *, uint32_t,
-                               const VdpBitstreamBuffer *);
-
-/**
- * This structure is used to share data between the libavcodec library and
- * the client video application.
- * The user shall allocate the structure via the av_alloc_vdpau_hwaccel
- * function and make it available as
- * AVCodecContext.hwaccel_context. Members can be set by the user once
- * during initialization or through each AVCodecContext.get_buffer()
- * function call. In any case, they must be valid prior to calling
- * decoding functions.
- *
- * The size of this structure is not a part of the public ABI and must not
- * be used outside of libavcodec. Use av_vdpau_alloc_context() to allocate an
- * AVVDPAUContext.
- */
-typedef struct AVVDPAUContext {
-    /**
-     * VDPAU decoder handle
-     *
-     * Set by user.
-     */
-    VdpDecoder decoder;
-
-    /**
-     * VDPAU decoder render callback
-     *
-     * Set by the user.
-     */
-    VdpDecoderRender *render;
-
-#if FF_API_BUFS_VDPAU
-    /**
-     * VDPAU picture information
-     *
-     * Set by libavcodec.
-     */
-    attribute_deprecated
-    union AVVDPAUPictureInfo info;
-
-    /**
-     * Allocated size of the bitstream_buffers table.
-     *
-     * Set by libavcodec.
-     */
-    attribute_deprecated
-    int bitstream_buffers_allocated;
-
-    /**
-     * Useful bitstream buffers in the bitstream buffers table.
-     *
-     * Set by libavcodec.
-     */
-    attribute_deprecated
-    int bitstream_buffers_used;
-
-   /**
-     * Table of bitstream buffers.
-     * The user is responsible for freeing this buffer using av_freep().
-     *
-     * Set by libavcodec.
-     */
-    attribute_deprecated
-    VdpBitstreamBuffer *bitstream_buffers;
-#endif
-    AVVDPAU_Render2 render2;
-} AVVDPAUContext;
-
-/**
- * @brief allocation function for AVVDPAUContext
- *
- * Allows extending the struct without breaking API/ABI
- */
-AVVDPAUContext *av_alloc_vdpaucontext(void);
-
-AVVDPAU_Render2 av_vdpau_hwaccel_get_render2(const AVVDPAUContext *);
-void av_vdpau_hwaccel_set_render2(AVVDPAUContext *, AVVDPAU_Render2);
-
-/**
- * Allocate an AVVDPAUContext.
- *
- * @return Newly-allocated AVVDPAUContext or NULL on failure.
- */
-AVVDPAUContext *av_vdpau_alloc_context(void);
-
-/**
- * Get a decoder profile that should be used for initializing a VDPAU decoder.
- * Should be called from the AVCodecContext.get_format() callback.
- *
- * @param avctx the codec context being used for decoding the stream
- * @param profile a pointer into which the result will be written on success.
- *                The contents of profile are undefined if this function returns
- *                an error.
- *
- * @return 0 on success (non-negative), a negative AVERROR on failure.
- */
-int av_vdpau_get_profile(AVCodecContext *avctx, VdpDecoderProfile *profile);
-
-#if FF_API_CAP_VDPAU
-/** @brief The videoSurface is used for rendering. */
-#define FF_VDPAU_STATE_USED_FOR_RENDER 1
-
-/**
- * @brief The videoSurface is needed for reference/prediction.
- * The codec manipulates this.
- */
-#define FF_VDPAU_STATE_USED_FOR_REFERENCE 2
-
-/**
- * @brief This structure is used as a callback between the FFmpeg
- * decoder (vd_) and presentation (vo_) module.
- * This is used for defining a video frame containing surface,
- * picture parameter, bitstream information etc which are passed
- * between the FFmpeg decoder and its clients.
- */
-struct vdpau_render_state {
-    VdpVideoSurface surface; ///< Used as rendered surface, never changed.
-
-    int state; ///< Holds FF_VDPAU_STATE_* values.
-
-#if AV_HAVE_INCOMPATIBLE_LIBAV_ABI
-    /** picture parameter information for all supported codecs */
-    union AVVDPAUPictureInfo info;
-#endif
-
-    /** Describe size/location of the compressed video data.
-        Set to 0 when freeing bitstream_buffers. */
-    int bitstream_buffers_allocated;
-    int bitstream_buffers_used;
-    /** The user is responsible for freeing this buffer using av_freep(). */
-    VdpBitstreamBuffer *bitstream_buffers;
-
-#if !AV_HAVE_INCOMPATIBLE_LIBAV_ABI
-    /** picture parameter information for all supported codecs */
-    union AVVDPAUPictureInfo info;
-#endif
-};
-#endif
-
-/* @}*/
-
-#endif /* AVCODEC_VDPAU_H */
diff -pruN /usr/include/ffmpeg/libavcodec/version.h csrc/libavcodec/version.h
--- /usr/include/ffmpeg/libavcodec/version.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/version.h	2014-10-20 16:52:54.462029939 +0200
@@ -1,31 +1,7 @@
-/*
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
 
 #ifndef AVCODEC_VERSION_H
 #define AVCODEC_VERSION_H
 
-/**
- * @file
- * @ingroup libavc
- * Libavcodec version macros.
- */
-
 #include "libavutil/version.h"
 
 #define LIBAVCODEC_VERSION_MAJOR 55
@@ -40,13 +16,7 @@
                                            LIBAVCODEC_VERSION_MICRO)
 #define LIBAVCODEC_BUILD        LIBAVCODEC_VERSION_INT
 
-#define LIBAVCODEC_IDENT        "Lavc" AV_STRINGIFY(LIBAVCODEC_VERSION)
-
-/**
- * FF_API_* defines may be placed below to indicate public API that will be
- * dropped at a future version bump. The defines themselves are not part of
- * the public API and may change, break or disappear at any time.
- */
+#define LIBAVCODEC_IDENT        "Lavc55.69.100"
 
 #ifndef FF_API_REQUEST_CHANNELS
 #define FF_API_REQUEST_CHANNELS (LIBAVCODEC_VERSION_MAJOR < 56)
diff -pruN /usr/include/ffmpeg/libavcodec/xvmc.h csrc/libavcodec/xvmc.h
--- /usr/include/ffmpeg/libavcodec/xvmc.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavcodec/xvmc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,170 +0,0 @@
-/*
- * Copyright (C) 2003 Ivan Kalvachev
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_XVMC_H
-#define AVCODEC_XVMC_H
-
-/**
- * @file
- * @ingroup lavc_codec_hwaccel_xvmc
- * Public libavcodec XvMC header.
- */
-
-#include <X11/extensions/XvMC.h>
-
-#include "libavutil/attributes.h"
-#include "version.h"
-#include "avcodec.h"
-
-/**
- * @defgroup lavc_codec_hwaccel_xvmc XvMC
- * @ingroup lavc_codec_hwaccel
- *
- * @{
- */
-
-#define AV_XVMC_ID                    0x1DC711C0  /**< special value to ensure that regular pixel routines haven't corrupted the struct
-                                                       the number is 1337 speak for the letters IDCT MCo (motion compensation) */
-
-attribute_deprecated struct xvmc_pix_fmt {
-    /** The field contains the special constant value AV_XVMC_ID.
-        It is used as a test that the application correctly uses the API,
-        and that there is no corruption caused by pixel routines.
-        - application - set during initialization
-        - libavcodec  - unchanged
-    */
-    int             xvmc_id;
-
-    /** Pointer to the block array allocated by XvMCCreateBlocks().
-        The array has to be freed by XvMCDestroyBlocks().
-        Each group of 64 values represents one data block of differential
-        pixel information (in MoCo mode) or coefficients for IDCT.
-        - application - set the pointer during initialization
-        - libavcodec  - fills coefficients/pixel data into the array
-    */
-    short*          data_blocks;
-
-    /** Pointer to the macroblock description array allocated by
-        XvMCCreateMacroBlocks() and freed by XvMCDestroyMacroBlocks().
-        - application - set the pointer during initialization
-        - libavcodec  - fills description data into the array
-    */
-    XvMCMacroBlock* mv_blocks;
-
-    /** Number of macroblock descriptions that can be stored in the mv_blocks
-        array.
-        - application - set during initialization
-        - libavcodec  - unchanged
-    */
-    int             allocated_mv_blocks;
-
-    /** Number of blocks that can be stored at once in the data_blocks array.
-        - application - set during initialization
-        - libavcodec  - unchanged
-    */
-    int             allocated_data_blocks;
-
-    /** Indicate that the hardware would interpret data_blocks as IDCT
-        coefficients and perform IDCT on them.
-        - application - set during initialization
-        - libavcodec  - unchanged
-    */
-    int             idct;
-
-    /** In MoCo mode it indicates that intra macroblocks are assumed to be in
-        unsigned format; same as the XVMC_INTRA_UNSIGNED flag.
-        - application - set during initialization
-        - libavcodec  - unchanged
-    */
-    int             unsigned_intra;
-
-    /** Pointer to the surface allocated by XvMCCreateSurface().
-        It has to be freed by XvMCDestroySurface() on application exit.
-        It identifies the frame and its state on the video hardware.
-        - application - set during initialization
-        - libavcodec  - unchanged
-    */
-    XvMCSurface*    p_surface;
-
-/** Set by the decoder before calling ff_draw_horiz_band(),
-    needed by the XvMCRenderSurface function. */
-//@{
-    /** Pointer to the surface used as past reference
-        - application - unchanged
-        - libavcodec  - set
-    */
-    XvMCSurface*    p_past_surface;
-
-    /** Pointer to the surface used as future reference
-        - application - unchanged
-        - libavcodec  - set
-    */
-    XvMCSurface*    p_future_surface;
-
-    /** top/bottom field or frame
-        - application - unchanged
-        - libavcodec  - set
-    */
-    unsigned int    picture_structure;
-
-    /** XVMC_SECOND_FIELD - 1st or 2nd field in the sequence
-        - application - unchanged
-        - libavcodec  - set
-    */
-    unsigned int    flags;
-//}@
-
-    /** Number of macroblock descriptions in the mv_blocks array
-        that have already been passed to the hardware.
-        - application - zeroes it on get_buffer().
-                        A successful ff_draw_horiz_band() may increment it
-                        with filled_mb_block_num or zero both.
-        - libavcodec  - unchanged
-    */
-    int             start_mv_blocks_num;
-
-    /** Number of new macroblock descriptions in the mv_blocks array (after
-        start_mv_blocks_num) that are filled by libavcodec and have to be
-        passed to the hardware.
-        - application - zeroes it on get_buffer() or after successful
-                        ff_draw_horiz_band().
-        - libavcodec  - increment with one of each stored MB
-    */
-    int             filled_mv_blocks_num;
-
-    /** Number of the next free data block; one data block consists of
-        64 short values in the data_blocks array.
-        All blocks before this one have already been claimed by placing their
-        position into the corresponding block description structure field,
-        that are part of the mv_blocks array.
-        - application - zeroes it on get_buffer().
-                        A successful ff_draw_horiz_band() may zero it together
-                        with start_mb_blocks_num.
-        - libavcodec  - each decoded macroblock increases it by the number
-                        of coded blocks it contains.
-    */
-    int             next_free_data_block_num;
-};
-
-/**
- * @}
- */
-
-#endif /* AVCODEC_XVMC_H */
diff -pruN /usr/include/ffmpeg/libavdevice/avdevice.h csrc/libavdevice/avdevice.h
--- /usr/include/ffmpeg/libavdevice/avdevice.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavdevice/avdevice.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,487 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVDEVICE_AVDEVICE_H
-#define AVDEVICE_AVDEVICE_H
-
-#include "version.h"
-
-/**
- * @file
- * @ingroup lavd
- * Main libavdevice API header
- */
-
-/**
- * @defgroup lavd Special devices muxing/demuxing library
- * @{
- * Libavdevice is a complementary library to @ref libavf "libavformat". It
- * provides various "special" platform-specific muxers and demuxers, e.g. for
- * grabbing devices, audio capture and playback etc. As a consequence, the
- * (de)muxers in libavdevice are of the AVFMT_NOFILE type (they use their own
- * I/O functions). The filename passed to avformat_open_input() often does not
- * refer to an actually existing file, but has some special device-specific
- * meaning - e.g. for x11grab it is the display name.
- *
- * To use libavdevice, simply call avdevice_register_all() to register all
- * compiled muxers and demuxers. They all use standard libavformat API.
- * @}
- */
-
-#include "libavutil/log.h"
-#include "libavutil/opt.h"
-#include "libavutil/dict.h"
-#include "libavformat/avformat.h"
-
-/**
- * Return the LIBAVDEVICE_VERSION_INT constant.
- */
-unsigned avdevice_version(void);
-
-/**
- * Return the libavdevice build-time configuration.
- */
-const char *avdevice_configuration(void);
-
-/**
- * Return the libavdevice license.
- */
-const char *avdevice_license(void);
-
-/**
- * Initialize libavdevice and register all the input and output devices.
- * @warning This function is not thread safe.
- */
-void avdevice_register_all(void);
-
-/**
- * Audio input devices iterator.
- *
- * If d is NULL, returns the first registered input audio/video device,
- * if d is non-NULL, returns the next registered input audio/video device after d
- * or NULL if d is the last one.
- */
-AVInputFormat *av_input_audio_device_next(AVInputFormat  *d);
-
-/**
- * Video input devices iterator.
- *
- * If d is NULL, returns the first registered input audio/video device,
- * if d is non-NULL, returns the next registered input audio/video device after d
- * or NULL if d is the last one.
- */
-AVInputFormat *av_input_video_device_next(AVInputFormat  *d);
-
-/**
- * Audio output devices iterator.
- *
- * If d is NULL, returns the first registered output audio/video device,
- * if d is non-NULL, returns the next registered output audio/video device after d
- * or NULL if d is the last one.
- */
-AVOutputFormat *av_output_audio_device_next(AVOutputFormat *d);
-
-/**
- * Video output devices iterator.
- *
- * If d is NULL, returns the first registered output audio/video device,
- * if d is non-NULL, returns the next registered output audio/video device after d
- * or NULL if d is the last one.
- */
-AVOutputFormat *av_output_video_device_next(AVOutputFormat *d);
-
-typedef struct AVDeviceRect {
-    int x;      /**< x coordinate of top left corner */
-    int y;      /**< y coordinate of top left corner */
-    int width;  /**< width */
-    int height; /**< height */
-} AVDeviceRect;
-
-/**
- * Message types used by avdevice_app_to_dev_control_message().
- */
-enum AVAppToDevMessageType {
-    /**
-     * Dummy message.
-     */
-    AV_APP_TO_DEV_NONE = MKBETAG('N','O','N','E'),
-
-    /**
-     * Window size change message.
-     *
-     * Message is sent to the device every time the application changes the size
-     * of the window device renders to.
-     * Message should also be sent right after window is created.
-     *
-     * data: AVDeviceRect: new window size.
-     */
-    AV_APP_TO_DEV_WINDOW_SIZE = MKBETAG('G','E','O','M'),
-
-    /**
-     * Repaint request message.
-     *
-     * Message is sent to the device when window has to be repainted.
-     *
-     * data: AVDeviceRect: area required to be repainted.
-     *       NULL: whole area is required to be repainted.
-     */
-    AV_APP_TO_DEV_WINDOW_REPAINT = MKBETAG('R','E','P','A'),
-
-    /**
-     * Request pause/play.
-     *
-     * Application requests pause/unpause playback.
-     * Mostly usable with devices that have internal buffer.
-     * By default devices are not paused.
-     *
-     * data: NULL
-     */
-    AV_APP_TO_DEV_PAUSE        = MKBETAG('P', 'A', 'U', ' '),
-    AV_APP_TO_DEV_PLAY         = MKBETAG('P', 'L', 'A', 'Y'),
-    AV_APP_TO_DEV_TOGGLE_PAUSE = MKBETAG('P', 'A', 'U', 'T'),
-
-    /**
-     * Volume control message.
-     *
-     * Set volume level. It may be device-dependent if volume
-     * is changed per stream or system wide. Per stream volume
-     * change is expected when possible.
-     *
-     * data: double: new volume with range of 0.0 - 1.0.
-     */
-    AV_APP_TO_DEV_SET_VOLUME = MKBETAG('S', 'V', 'O', 'L'),
-
-    /**
-     * Mute control messages.
-     *
-     * Change mute state. It may be device-dependent if mute status
-     * is changed per stream or system wide. Per stream mute status
-     * change is expected when possible.
-     *
-     * data: NULL.
-     */
-    AV_APP_TO_DEV_MUTE        = MKBETAG(' ', 'M', 'U', 'T'),
-    AV_APP_TO_DEV_UNMUTE      = MKBETAG('U', 'M', 'U', 'T'),
-    AV_APP_TO_DEV_TOGGLE_MUTE = MKBETAG('T', 'M', 'U', 'T'),
-
-    /**
-     * Get volume/mute messages.
-     *
-     * Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or
-     * AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively.
-     *
-     * data: NULL.
-     */
-    AV_APP_TO_DEV_GET_VOLUME = MKBETAG('G', 'V', 'O', 'L'),
-    AV_APP_TO_DEV_GET_MUTE   = MKBETAG('G', 'M', 'U', 'T'),
-};
-
-/**
- * Message types used by avdevice_dev_to_app_control_message().
- */
-enum AVDevToAppMessageType {
-    /**
-     * Dummy message.
-     */
-    AV_DEV_TO_APP_NONE = MKBETAG('N','O','N','E'),
-
-    /**
-     * Create window buffer message.
-     *
-     * Device requests to create a window buffer. Exact meaning is device-
-     * and application-dependent. Message is sent before rendering first
-     * frame and all one-shot initializations should be done here.
-     * Application is allowed to ignore preferred window buffer size.
-     *
-     * @note: Application is obligated to inform about window buffer size
-     *        with AV_APP_TO_DEV_WINDOW_SIZE message.
-     *
-     * data: AVDeviceRect: preferred size of the window buffer.
-     *       NULL: no preferred size of the window buffer.
-     */
-    AV_DEV_TO_APP_CREATE_WINDOW_BUFFER = MKBETAG('B','C','R','E'),
-
-    /**
-     * Prepare window buffer message.
-     *
-     * Device requests to prepare a window buffer for rendering.
-     * Exact meaning is device- and application-dependent.
-     * Message is sent before rendering of each frame.
-     *
-     * data: NULL.
-     */
-    AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER = MKBETAG('B','P','R','E'),
-
-    /**
-     * Display window buffer message.
-     *
-     * Device requests to display a window buffer.
-     * Message is sent when new frame is ready to be displayed.
-     * Usually buffers need to be swapped in handler of this message.
-     *
-     * data: NULL.
-     */
-    AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER = MKBETAG('B','D','I','S'),
-
-    /**
-     * Destroy window buffer message.
-     *
-     * Device requests to destroy a window buffer.
-     * Message is sent when device is about to be destroyed and window
-     * buffer is not required anymore.
-     *
-     * data: NULL.
-     */
-    AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER = MKBETAG('B','D','E','S'),
-
-    /**
-     * Buffer fullness status messages.
-     *
-     * Device signals buffer overflow/underflow.
-     *
-     * data: NULL.
-     */
-    AV_DEV_TO_APP_BUFFER_OVERFLOW = MKBETAG('B','O','F','L'),
-    AV_DEV_TO_APP_BUFFER_UNDERFLOW = MKBETAG('B','U','F','L'),
-
-    /**
-     * Buffer readable/writable.
-     *
-     * Device informs that buffer is readable/writable.
-     * When possible, device informs how many bytes can be read/write.
-     *
-     * @warning Device may not inform when number of bytes than can be read/write changes.
-     *
-     * data: int64_t: amount of bytes available to read/write.
-     *       NULL: amount of bytes available to read/write is not known.
-     */
-    AV_DEV_TO_APP_BUFFER_READABLE = MKBETAG('B','R','D',' '),
-    AV_DEV_TO_APP_BUFFER_WRITABLE = MKBETAG('B','W','R',' '),
-
-    /**
-     * Mute state change message.
-     *
-     * Device informs that mute state has changed.
-     *
-     * data: int: 0 for not muted state, non-zero for muted state.
-     */
-    AV_DEV_TO_APP_MUTE_STATE_CHANGED = MKBETAG('C','M','U','T'),
-
-    /**
-     * Volume level change message.
-     *
-     * Device informs that volume level has changed.
-     *
-     * data: double: new volume with range of 0.0 - 1.0.
-     */
-    AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED = MKBETAG('C','V','O','L'),
-};
-
-/**
- * Send control message from application to device.
- *
- * @param s         device context.
- * @param type      message type.
- * @param data      message data. Exact type depends on message type.
- * @param data_size size of message data.
- * @return >= 0 on success, negative on error.
- *         AVERROR(ENOSYS) when device doesn't implement handler of the message.
- */
-int avdevice_app_to_dev_control_message(struct AVFormatContext *s,
-                                        enum AVAppToDevMessageType type,
-                                        void *data, size_t data_size);
-
-/**
- * Send control message from device to application.
- *
- * @param s         device context.
- * @param type      message type.
- * @param data      message data. Can be NULL.
- * @param data_size size of message data.
- * @return >= 0 on success, negative on error.
- *         AVERROR(ENOSYS) when application doesn't implement handler of the message.
- */
-int avdevice_dev_to_app_control_message(struct AVFormatContext *s,
-                                        enum AVDevToAppMessageType type,
-                                        void *data, size_t data_size);
-
-/**
- * Following API allows user to probe device capabilities (supported codecs,
- * pixel formats, sample formats, resolutions, channel counts, etc).
- * It is build on top op AVOption API.
- * Queried capabilities allows to set up converters of video or audio
- * parameters that fit to the device.
- *
- * List of capabilities that can be queried:
- *  - Capabilities valid for both audio and video devices:
- *    - codec:          supported audio/video codecs.
- *                      type: AV_OPT_TYPE_INT (AVCodecID value)
- *  - Capabilities valid for audio devices:
- *    - sample_format:  supported sample formats.
- *                      type: AV_OPT_TYPE_INT (AVSampleFormat value)
- *    - sample_rate:    supported sample rates.
- *                      type: AV_OPT_TYPE_INT
- *    - channels:       supported number of channels.
- *                      type: AV_OPT_TYPE_INT
- *    - channel_layout: supported channel layouts.
- *                      type: AV_OPT_TYPE_INT64
- *  - Capabilities valid for video devices:
- *    - pixel_format:   supported pixel formats.
- *                      type: AV_OPT_TYPE_INT (AVPixelFormat value)
- *    - window_size:    supported window sizes (describes size of the window size presented to the user).
- *                      type: AV_OPT_TYPE_IMAGE_SIZE
- *    - frame_size:     supported frame sizes (describes size of provided video frames).
- *                      type: AV_OPT_TYPE_IMAGE_SIZE
- *    - fps:            supported fps values
- *                      type: AV_OPT_TYPE_RATIONAL
- *
- * Value of the capability may be set by user using av_opt_set() function
- * and AVDeviceCapabilitiesQuery object. Following queries will
- * limit results to the values matching already set capabilities.
- * For example, setting a codec may impact number of formats or fps values
- * returned during next query. Setting invalid value may limit results to zero.
- *
- * Example of the usage basing on opengl output device:
- *
- * @code
- *  AVFormatContext *oc = NULL;
- *  AVDeviceCapabilitiesQuery *caps = NULL;
- *  AVOptionRanges *ranges;
- *  int ret;
- *
- *  if ((ret = avformat_alloc_output_context2(&oc, NULL, "opengl", NULL)) < 0)
- *      goto fail;
- *  if (avdevice_capabilities_create(&caps, oc, NULL) < 0)
- *      goto fail;
- *
- *  //query codecs
- *  if (av_opt_query_ranges(&ranges, caps, "codec", AV_OPT_MULTI_COMPONENT_RANGE)) < 0)
- *      goto fail;
- *  //pick codec here and set it
- *  av_opt_set(caps, "codec", AV_CODEC_ID_RAWVIDEO, 0);
- *
- *  //query format
- *  if (av_opt_query_ranges(&ranges, caps, "pixel_format", AV_OPT_MULTI_COMPONENT_RANGE)) < 0)
- *      goto fail;
- *  //pick format here and set it
- *  av_opt_set(caps, "pixel_format", AV_PIX_FMT_YUV420P, 0);
- *
- *  //query and set more capabilities
- *
- * fail:
- *  //clean up code
- *  avdevice_capabilities_free(&query, oc);
- *  avformat_free_context(oc);
- * @endcode
- */
-
-/**
- * Structure describes device capabilities.
- *
- * It is used by devices in conjunction with av_device_capabilities AVOption table
- * to implement capabilities probing API based on AVOption API. Should not be used directly.
- */
-typedef struct AVDeviceCapabilitiesQuery {
-    const AVClass *av_class;
-    AVFormatContext *device_context;
-    enum AVCodecID codec;
-    enum AVSampleFormat sample_format;
-    enum AVPixelFormat pixel_format;
-    int sample_rate;
-    int channels;
-    int64_t channel_layout;
-    int window_width;
-    int window_height;
-    int frame_width;
-    int frame_height;
-    AVRational fps;
-} AVDeviceCapabilitiesQuery;
-
-/**
- * AVOption table used by devices to implement device capabilities API. Should not be used by a user.
- */
-extern const AVOption av_device_capabilities[];
-
-/**
- * Initialize capabilities probing API based on AVOption API.
- *
- * avdevice_capabilities_free() must be called when query capabilities API is
- * not used anymore.
- *
- * @param[out] caps      Device capabilities data. Pointer to a NULL pointer must be passed.
- * @param s              Context of the device.
- * @param device_options An AVDictionary filled with device-private options.
- *                       On return this parameter will be destroyed and replaced with a dict
- *                       containing options that were not found. May be NULL.
- *                       The same options must be passed later to avformat_write_header() for output
- *                       devices or avformat_open_input() for input devices, or at any other place
- *                       that affects device-private options.
- *
- * @return >= 0 on success, negative otherwise.
- */
-int avdevice_capabilities_create(AVDeviceCapabilitiesQuery **caps, AVFormatContext *s,
-                                 AVDictionary **device_options);
-
-/**
- * Free resources created by avdevice_capabilities_create()
- *
- * @param caps Device capabilities data to be freed.
- * @param s    Context of the device.
- */
-void avdevice_capabilities_free(AVDeviceCapabilitiesQuery **caps, AVFormatContext *s);
-
-/**
- * Structure describes basic parameters of the device.
- */
-typedef struct AVDeviceInfo {
-    char *device_name;                   /**< device name, format depends on device */
-    char *device_description;            /**< human friendly name */
-} AVDeviceInfo;
-
-/**
- * List of devices.
- */
-typedef struct AVDeviceInfoList {
-    AVDeviceInfo **devices;              /**< list of autodetected devices */
-    int nb_devices;                      /**< number of autodetected devices */
-    int default_device;                  /**< index of default device or -1 if no default */
-} AVDeviceInfoList;
-
-/**
- * List devices.
- *
- * Returns available device names and their parameters.
- *
- * @note: Some devices may accept system-dependent device names that cannot be
- *        autodetected. The list returned by this function cannot be assumed to
- *        be always completed.
- *
- * @param s                device context.
- * @param[out] device_list list of autodetected devices.
- * @return count of autodetected devices, negative on error.
- */
-int avdevice_list_devices(struct AVFormatContext *s, AVDeviceInfoList **device_list);
-
-/**
- * Convenient function to free result of avdevice_list_devices().
- *
- * @param devices device list to be freed.
- */
-void avdevice_free_list_devices(AVDeviceInfoList **device_list);
-
-#endif /* AVDEVICE_AVDEVICE_H */
diff -pruN /usr/include/ffmpeg/libavdevice/version.h csrc/libavdevice/version.h
--- /usr/include/ffmpeg/libavdevice/version.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavdevice/version.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVDEVICE_VERSION_H
-#define AVDEVICE_VERSION_H
-
-/**
- * @file
- * @ingroup lavd
- * Libavdevice version macros
- */
-
-#include "libavutil/version.h"
-
-#define LIBAVDEVICE_VERSION_MAJOR  55
-#define LIBAVDEVICE_VERSION_MINOR  13
-#define LIBAVDEVICE_VERSION_MICRO 102
-
-#define LIBAVDEVICE_VERSION_INT AV_VERSION_INT(LIBAVDEVICE_VERSION_MAJOR, \
-                                               LIBAVDEVICE_VERSION_MINOR, \
-                                               LIBAVDEVICE_VERSION_MICRO)
-#define LIBAVDEVICE_VERSION     AV_VERSION(LIBAVDEVICE_VERSION_MAJOR, \
-                                           LIBAVDEVICE_VERSION_MINOR, \
-                                           LIBAVDEVICE_VERSION_MICRO)
-#define LIBAVDEVICE_BUILD       LIBAVDEVICE_VERSION_INT
-
-#define LIBAVDEVICE_IDENT       "Lavd" AV_STRINGIFY(LIBAVDEVICE_VERSION)
-
-/**
- * FF_API_* defines may be placed below to indicate public API that will be
- * dropped at a future version bump. The defines themselves are not part of
- * the public API and may change, break or disappear at any time.
- */
-
-#endif /* AVDEVICE_VERSION_H */
diff -pruN /usr/include/ffmpeg/libavfilter/asrc_abuffer.h csrc/libavfilter/asrc_abuffer.h
--- /usr/include/ffmpeg/libavfilter/asrc_abuffer.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavfilter/asrc_abuffer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVFILTER_ASRC_ABUFFER_H
-#define AVFILTER_ASRC_ABUFFER_H
-
-#include "avfilter.h"
-
-/**
- * @file
- * memory buffer source for audio
- *
- * @deprecated use buffersrc.h instead.
- */
-
-/**
- * Queue an audio buffer to the audio buffer source.
- *
- * @param abuffersrc audio source buffer context
- * @param data pointers to the samples planes
- * @param linesize linesizes of each audio buffer plane
- * @param nb_samples number of samples per channel
- * @param sample_fmt sample format of the audio data
- * @param ch_layout channel layout of the audio data
- * @param planar flag to indicate if audio data is planar or packed
- * @param pts presentation timestamp of the audio buffer
- * @param flags unused
- *
- * @deprecated use av_buffersrc_add_ref() instead.
- */
-attribute_deprecated
-int av_asrc_buffer_add_samples(AVFilterContext *abuffersrc,
-                               uint8_t *data[8], int linesize[8],
-                               int nb_samples, int sample_rate,
-                               int sample_fmt, int64_t ch_layout, int planar,
-                               int64_t pts, int av_unused flags);
-
-/**
- * Queue an audio buffer to the audio buffer source.
- *
- * This is similar to av_asrc_buffer_add_samples(), but the samples
- * are stored in a buffer with known size.
- *
- * @param abuffersrc audio source buffer context
- * @param buf pointer to the samples data, packed is assumed
- * @param size the size in bytes of the buffer, it must contain an
- * integer number of samples
- * @param sample_fmt sample format of the audio data
- * @param ch_layout channel layout of the audio data
- * @param pts presentation timestamp of the audio buffer
- * @param flags unused
- *
- * @deprecated use av_buffersrc_add_ref() instead.
- */
-attribute_deprecated
-int av_asrc_buffer_add_buffer(AVFilterContext *abuffersrc,
-                              uint8_t *buf, int buf_size,
-                              int sample_rate,
-                              int sample_fmt, int64_t ch_layout, int planar,
-                              int64_t pts, int av_unused flags);
-
-/**
- * Queue an audio buffer to the audio buffer source.
- *
- * @param abuffersrc audio source buffer context
- * @param samplesref buffer ref to queue
- * @param flags unused
- *
- * @deprecated use av_buffersrc_add_ref() instead.
- */
-attribute_deprecated
-int av_asrc_buffer_add_audio_buffer_ref(AVFilterContext *abuffersrc,
-                                        AVFilterBufferRef *samplesref,
-                                        int av_unused flags);
-
-#endif /* AVFILTER_ASRC_ABUFFER_H */
diff -pruN /usr/include/ffmpeg/libavfilter/avcodec.h csrc/libavfilter/avcodec.h
--- /usr/include/ffmpeg/libavfilter/avcodec.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavfilter/avcodec.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,110 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVFILTER_AVCODEC_H
-#define AVFILTER_AVCODEC_H
-
-/**
- * @file
- * libavcodec/libavfilter gluing utilities
- *
- * This should be included in an application ONLY if the installed
- * libavfilter has been compiled with libavcodec support, otherwise
- * symbols defined below will not be available.
- */
-
-#include "avfilter.h"
-
-#if FF_API_AVFILTERBUFFER
-/**
- * Create and return a picref reference from the data and properties
- * contained in frame.
- *
- * @param perms permissions to assign to the new buffer reference
- * @deprecated avfilter APIs work natively with AVFrame instead.
- */
-attribute_deprecated
-AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame, int perms);
-
-
-/**
- * Create and return a picref reference from the data and properties
- * contained in frame.
- *
- * @param perms permissions to assign to the new buffer reference
- * @deprecated avfilter APIs work natively with AVFrame instead.
- */
-attribute_deprecated
-AVFilterBufferRef *avfilter_get_audio_buffer_ref_from_frame(const AVFrame *frame,
-                                                            int perms);
-
-/**
- * Create and return a buffer reference from the data and properties
- * contained in frame.
- *
- * @param perms permissions to assign to the new buffer reference
- * @deprecated avfilter APIs work natively with AVFrame instead.
- */
-attribute_deprecated
-AVFilterBufferRef *avfilter_get_buffer_ref_from_frame(enum AVMediaType type,
-                                                      const AVFrame *frame,
-                                                      int perms);
-#endif
-
-#if FF_API_FILL_FRAME
-/**
- * Fill an AVFrame with the information stored in samplesref.
- *
- * @param frame an already allocated AVFrame
- * @param samplesref an audio buffer reference
- * @return >= 0 in case of success, a negative AVERROR code in case of
- * failure
- * @deprecated Use avfilter_copy_buf_props() instead.
- */
-attribute_deprecated
-int avfilter_fill_frame_from_audio_buffer_ref(AVFrame *frame,
-                                              const AVFilterBufferRef *samplesref);
-
-/**
- * Fill an AVFrame with the information stored in picref.
- *
- * @param frame an already allocated AVFrame
- * @param picref a video buffer reference
- * @return >= 0 in case of success, a negative AVERROR code in case of
- * failure
- * @deprecated Use avfilter_copy_buf_props() instead.
- */
-attribute_deprecated
-int avfilter_fill_frame_from_video_buffer_ref(AVFrame *frame,
-                                              const AVFilterBufferRef *picref);
-
-/**
- * Fill an AVFrame with information stored in ref.
- *
- * @param frame an already allocated AVFrame
- * @param ref a video or audio buffer reference
- * @return >= 0 in case of success, a negative AVERROR code in case of
- * failure
- * @deprecated Use avfilter_copy_buf_props() instead.
- */
-attribute_deprecated
-int avfilter_fill_frame_from_buffer_ref(AVFrame *frame,
-                                        const AVFilterBufferRef *ref);
-#endif
-
-#endif /* AVFILTER_AVCODEC_H */
diff -pruN /usr/include/ffmpeg/libavfilter/avfiltergraph.h csrc/libavfilter/avfiltergraph.h
--- /usr/include/ffmpeg/libavfilter/avfiltergraph.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavfilter/avfiltergraph.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-/*
- * Filter graphs
- * copyright (c) 2007 Bobby Bingham
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVFILTER_AVFILTERGRAPH_H
-#define AVFILTER_AVFILTERGRAPH_H
-
-#include "avfilter.h"
-#include "libavutil/log.h"
-
-#endif /* AVFILTER_AVFILTERGRAPH_H */
diff -pruN /usr/include/ffmpeg/libavfilter/avfilter.h csrc/libavfilter/avfilter.h
--- /usr/include/ffmpeg/libavfilter/avfilter.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavfilter/avfilter.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1531 +0,0 @@
-/*
- * filter layer
- * Copyright (c) 2007 Bobby Bingham
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVFILTER_AVFILTER_H
-#define AVFILTER_AVFILTER_H
-
-/**
- * @file
- * @ingroup lavfi
- * Main libavfilter public API header
- */
-
-/**
- * @defgroup lavfi Libavfilter - graph-based frame editing library
- * @{
- */
-
-#include <stddef.h>
-
-#include "libavutil/attributes.h"
-#include "libavutil/avutil.h"
-#include "libavutil/dict.h"
-#include "libavutil/frame.h"
-#include "libavutil/log.h"
-#include "libavutil/samplefmt.h"
-#include "libavutil/pixfmt.h"
-#include "libavutil/rational.h"
-
-#include "libavfilter/version.h"
-
-/**
- * Return the LIBAVFILTER_VERSION_INT constant.
- */
-unsigned avfilter_version(void);
-
-/**
- * Return the libavfilter build-time configuration.
- */
-const char *avfilter_configuration(void);
-
-/**
- * Return the libavfilter license.
- */
-const char *avfilter_license(void);
-
-typedef struct AVFilterContext AVFilterContext;
-typedef struct AVFilterLink    AVFilterLink;
-typedef struct AVFilterPad     AVFilterPad;
-typedef struct AVFilterFormats AVFilterFormats;
-
-#if FF_API_AVFILTERBUFFER
-/**
- * A reference-counted buffer data type used by the filter system. Filters
- * should not store pointers to this structure directly, but instead use the
- * AVFilterBufferRef structure below.
- */
-typedef struct AVFilterBuffer {
-    uint8_t *data[8];           ///< buffer data for each plane/channel
-
-    /**
-     * pointers to the data planes/channels.
-     *
-     * For video, this should simply point to data[].
-     *
-     * For planar audio, each channel has a separate data pointer, and
-     * linesize[0] contains the size of each channel buffer.
-     * For packed audio, there is just one data pointer, and linesize[0]
-     * contains the total size of the buffer for all channels.
-     *
-     * Note: Both data and extended_data will always be set, but for planar
-     * audio with more channels that can fit in data, extended_data must be used
-     * in order to access all channels.
-     */
-    uint8_t **extended_data;
-    int linesize[8];            ///< number of bytes per line
-
-    /** private data to be used by a custom free function */
-    void *priv;
-    /**
-     * A pointer to the function to deallocate this buffer if the default
-     * function is not sufficient. This could, for example, add the memory
-     * back into a memory pool to be reused later without the overhead of
-     * reallocating it from scratch.
-     */
-    void (*free)(struct AVFilterBuffer *buf);
-
-    int format;                 ///< media format
-    int w, h;                   ///< width and height of the allocated buffer
-    unsigned refcount;          ///< number of references to this buffer
-} AVFilterBuffer;
-
-#define AV_PERM_READ     0x01   ///< can read from the buffer
-#define AV_PERM_WRITE    0x02   ///< can write to the buffer
-#define AV_PERM_PRESERVE 0x04   ///< nobody else can overwrite the buffer
-#define AV_PERM_REUSE    0x08   ///< can output the buffer multiple times, with the same contents each time
-#define AV_PERM_REUSE2   0x10   ///< can output the buffer multiple times, modified each time
-#define AV_PERM_NEG_LINESIZES 0x20  ///< the buffer requested can have negative linesizes
-#define AV_PERM_ALIGN    0x40   ///< the buffer must be aligned
-
-#define AVFILTER_ALIGN 16 //not part of ABI
-
-/**
- * Audio specific properties in a reference to an AVFilterBuffer. Since
- * AVFilterBufferRef is common to different media formats, audio specific
- * per reference properties must be separated out.
- */
-typedef struct AVFilterBufferRefAudioProps {
-    uint64_t channel_layout;    ///< channel layout of audio buffer
-    int nb_samples;             ///< number of audio samples per channel
-    int sample_rate;            ///< audio buffer sample rate
-    int channels;               ///< number of channels (do not access directly)
-} AVFilterBufferRefAudioProps;
-
-/**
- * Video specific properties in a reference to an AVFilterBuffer. Since
- * AVFilterBufferRef is common to different media formats, video specific
- * per reference properties must be separated out.
- */
-typedef struct AVFilterBufferRefVideoProps {
-    int w;                      ///< image width
-    int h;                      ///< image height
-    AVRational sample_aspect_ratio; ///< sample aspect ratio
-    int interlaced;             ///< is frame interlaced
-    int top_field_first;        ///< field order
-    enum AVPictureType pict_type; ///< picture type of the frame
-    int key_frame;              ///< 1 -> keyframe, 0-> not
-    int qp_table_linesize;                ///< qp_table stride
-    int qp_table_size;            ///< qp_table size
-    int8_t *qp_table;             ///< array of Quantization Parameters
-} AVFilterBufferRefVideoProps;
-
-/**
- * A reference to an AVFilterBuffer. Since filters can manipulate the origin of
- * a buffer to, for example, crop image without any memcpy, the buffer origin
- * and dimensions are per-reference properties. Linesize is also useful for
- * image flipping, frame to field filters, etc, and so is also per-reference.
- *
- * TODO: add anything necessary for frame reordering
- */
-typedef struct AVFilterBufferRef {
-    AVFilterBuffer *buf;        ///< the buffer that this is a reference to
-    uint8_t *data[8];           ///< picture/audio data for each plane
-    /**
-     * pointers to the data planes/channels.
-     *
-     * For video, this should simply point to data[].
-     *
-     * For planar audio, each channel has a separate data pointer, and
-     * linesize[0] contains the size of each channel buffer.
-     * For packed audio, there is just one data pointer, and linesize[0]
-     * contains the total size of the buffer for all channels.
-     *
-     * Note: Both data and extended_data will always be set, but for planar
-     * audio with more channels that can fit in data, extended_data must be used
-     * in order to access all channels.
-     */
-    uint8_t **extended_data;
-    int linesize[8];            ///< number of bytes per line
-
-    AVFilterBufferRefVideoProps *video; ///< video buffer specific properties
-    AVFilterBufferRefAudioProps *audio; ///< audio buffer specific properties
-
-    /**
-     * presentation timestamp. The time unit may change during
-     * filtering, as it is specified in the link and the filter code
-     * may need to rescale the PTS accordingly.
-     */
-    int64_t pts;
-    int64_t pos;                ///< byte position in stream, -1 if unknown
-
-    int format;                 ///< media format
-
-    int perms;                  ///< permissions, see the AV_PERM_* flags
-
-    enum AVMediaType type;      ///< media type of buffer data
-
-    AVDictionary *metadata;     ///< dictionary containing metadata key=value tags
-} AVFilterBufferRef;
-
-/**
- * Copy properties of src to dst, without copying the actual data
- */
-attribute_deprecated
-void avfilter_copy_buffer_ref_props(AVFilterBufferRef *dst, const AVFilterBufferRef *src);
-
-/**
- * Add a new reference to a buffer.
- *
- * @param ref   an existing reference to the buffer
- * @param pmask a bitmask containing the allowable permissions in the new
- *              reference
- * @return      a new reference to the buffer with the same properties as the
- *              old, excluding any permissions denied by pmask
- */
-attribute_deprecated
-AVFilterBufferRef *avfilter_ref_buffer(AVFilterBufferRef *ref, int pmask);
-
-/**
- * Remove a reference to a buffer. If this is the last reference to the
- * buffer, the buffer itself is also automatically freed.
- *
- * @param ref reference to the buffer, may be NULL
- *
- * @note it is recommended to use avfilter_unref_bufferp() instead of this
- * function
- */
-attribute_deprecated
-void avfilter_unref_buffer(AVFilterBufferRef *ref);
-
-/**
- * Remove a reference to a buffer and set the pointer to NULL.
- * If this is the last reference to the buffer, the buffer itself
- * is also automatically freed.
- *
- * @param ref pointer to the buffer reference
- */
-attribute_deprecated
-void avfilter_unref_bufferp(AVFilterBufferRef **ref);
-#endif
-
-/**
- * Get the number of channels of a buffer reference.
- */
-attribute_deprecated
-int avfilter_ref_get_channels(AVFilterBufferRef *ref);
-
-#if FF_API_AVFILTERPAD_PUBLIC
-/**
- * A filter pad used for either input or output.
- *
- * See doc/filter_design.txt for details on how to implement the methods.
- *
- * @warning this struct might be removed from public API.
- * users should call avfilter_pad_get_name() and avfilter_pad_get_type()
- * to access the name and type fields; there should be no need to access
- * any other fields from outside of libavfilter.
- */
-struct AVFilterPad {
-    /**
-     * Pad name. The name is unique among inputs and among outputs, but an
-     * input may have the same name as an output. This may be NULL if this
-     * pad has no need to ever be referenced by name.
-     */
-    const char *name;
-
-    /**
-     * AVFilterPad type.
-     */
-    enum AVMediaType type;
-
-    /**
-     * Input pads:
-     * Minimum required permissions on incoming buffers. Any buffer with
-     * insufficient permissions will be automatically copied by the filter
-     * system to a new buffer which provides the needed access permissions.
-     *
-     * Output pads:
-     * Guaranteed permissions on outgoing buffers. Any buffer pushed on the
-     * link must have at least these permissions; this fact is checked by
-     * asserts. It can be used to optimize buffer allocation.
-     */
-    attribute_deprecated int min_perms;
-
-    /**
-     * Input pads:
-     * Permissions which are not accepted on incoming buffers. Any buffer
-     * which has any of these permissions set will be automatically copied
-     * by the filter system to a new buffer which does not have those
-     * permissions. This can be used to easily disallow buffers with
-     * AV_PERM_REUSE.
-     *
-     * Output pads:
-     * Permissions which are automatically removed on outgoing buffers. It
-     * can be used to optimize buffer allocation.
-     */
-    attribute_deprecated int rej_perms;
-
-    /**
-     * @deprecated unused
-     */
-    int (*start_frame)(AVFilterLink *link, AVFilterBufferRef *picref);
-
-    /**
-     * Callback function to get a video buffer. If NULL, the filter system will
-     * use ff_default_get_video_buffer().
-     *
-     * Input video pads only.
-     */
-    AVFrame *(*get_video_buffer)(AVFilterLink *link, int w, int h);
-
-    /**
-     * Callback function to get an audio buffer. If NULL, the filter system will
-     * use ff_default_get_audio_buffer().
-     *
-     * Input audio pads only.
-     */
-    AVFrame *(*get_audio_buffer)(AVFilterLink *link, int nb_samples);
-
-    /**
-     * @deprecated unused
-     */
-    int (*end_frame)(AVFilterLink *link);
-
-    /**
-     * @deprecated unused
-     */
-    int (*draw_slice)(AVFilterLink *link, int y, int height, int slice_dir);
-
-    /**
-     * Filtering callback. This is where a filter receives a frame with
-     * audio/video data and should do its processing.
-     *
-     * Input pads only.
-     *
-     * @return >= 0 on success, a negative AVERROR on error. This function
-     * must ensure that frame is properly unreferenced on error if it
-     * hasn't been passed on to another filter.
-     */
-    int (*filter_frame)(AVFilterLink *link, AVFrame *frame);
-
-    /**
-     * Frame poll callback. This returns the number of immediately available
-     * samples. It should return a positive value if the next request_frame()
-     * is guaranteed to return one frame (with no delay).
-     *
-     * Defaults to just calling the source poll_frame() method.
-     *
-     * Output pads only.
-     */
-    int (*poll_frame)(AVFilterLink *link);
-
-    /**
-     * Frame request callback. A call to this should result in at least one
-     * frame being output over the given link. This should return zero on
-     * success, and another value on error.
-     * See ff_request_frame() for the error codes with a specific
-     * meaning.
-     *
-     * Output pads only.
-     */
-    int (*request_frame)(AVFilterLink *link);
-
-    /**
-     * Link configuration callback.
-     *
-     * For output pads, this should set the following link properties:
-     * video: width, height, sample_aspect_ratio, time_base
-     * audio: sample_rate.
-     *
-     * This should NOT set properties such as format, channel_layout, etc which
-     * are negotiated between filters by the filter system using the
-     * query_formats() callback before this function is called.
-     *
-     * For input pads, this should check the properties of the link, and update
-     * the filter's internal state as necessary.
-     *
-     * For both input and output pads, this should return zero on success,
-     * and another value on error.
-     */
-    int (*config_props)(AVFilterLink *link);
-
-    /**
-     * The filter expects a fifo to be inserted on its input link,
-     * typically because it has a delay.
-     *
-     * input pads only.
-     */
-    int needs_fifo;
-
-    /**
-     * The filter expects writable frames from its input link,
-     * duplicating data buffers if needed.
-     *
-     * input pads only.
-     */
-    int needs_writable;
-};
-#endif
-
-/**
- * Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.
- * AVFilter.inputs/outputs).
- */
-int avfilter_pad_count(const AVFilterPad *pads);
-
-/**
- * Get the name of an AVFilterPad.
- *
- * @param pads an array of AVFilterPads
- * @param pad_idx index of the pad in the array it; is the caller's
- *                responsibility to ensure the index is valid
- *
- * @return name of the pad_idx'th pad in pads
- */
-const char *avfilter_pad_get_name(const AVFilterPad *pads, int pad_idx);
-
-/**
- * Get the type of an AVFilterPad.
- *
- * @param pads an array of AVFilterPads
- * @param pad_idx index of the pad in the array; it is the caller's
- *                responsibility to ensure the index is valid
- *
- * @return type of the pad_idx'th pad in pads
- */
-enum AVMediaType avfilter_pad_get_type(const AVFilterPad *pads, int pad_idx);
-
-/**
- * The number of the filter inputs is not determined just by AVFilter.inputs.
- * The filter might add additional inputs during initialization depending on the
- * options supplied to it.
- */
-#define AVFILTER_FLAG_DYNAMIC_INPUTS        (1 << 0)
-/**
- * The number of the filter outputs is not determined just by AVFilter.outputs.
- * The filter might add additional outputs during initialization depending on
- * the options supplied to it.
- */
-#define AVFILTER_FLAG_DYNAMIC_OUTPUTS       (1 << 1)
-/**
- * The filter supports multithreading by splitting frames into multiple parts
- * and processing them concurrently.
- */
-#define AVFILTER_FLAG_SLICE_THREADS         (1 << 2)
-/**
- * Some filters support a generic "enable" expression option that can be used
- * to enable or disable a filter in the timeline. Filters supporting this
- * option have this flag set. When the enable expression is false, the default
- * no-op filter_frame() function is called in place of the filter_frame()
- * callback defined on each input pad, thus the frame is passed unchanged to
- * the next filters.
- */
-#define AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC  (1 << 16)
-/**
- * Same as AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC, except that the filter will
- * have its filter_frame() callback(s) called as usual even when the enable
- * expression is false. The filter will disable filtering within the
- * filter_frame() callback(s) itself, for example executing code depending on
- * the AVFilterContext->is_disabled value.
- */
-#define AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL (1 << 17)
-/**
- * Handy mask to test whether the filter supports or no the timeline feature
- * (internally or generically).
- */
-#define AVFILTER_FLAG_SUPPORT_TIMELINE (AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC | AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL)
-
-/**
- * Filter definition. This defines the pads a filter contains, and all the
- * callback functions used to interact with the filter.
- */
-typedef struct AVFilter {
-    /**
-     * Filter name. Must be non-NULL and unique among filters.
-     */
-    const char *name;
-
-    /**
-     * A description of the filter. May be NULL.
-     *
-     * You should use the NULL_IF_CONFIG_SMALL() macro to define it.
-     */
-    const char *description;
-
-    /**
-     * List of inputs, terminated by a zeroed element.
-     *
-     * NULL if there are no (static) inputs. Instances of filters with
-     * AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in
-     * this list.
-     */
-    const AVFilterPad *inputs;
-    /**
-     * List of outputs, terminated by a zeroed element.
-     *
-     * NULL if there are no (static) outputs. Instances of filters with
-     * AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in
-     * this list.
-     */
-    const AVFilterPad *outputs;
-
-    /**
-     * A class for the private data, used to declare filter private AVOptions.
-     * This field is NULL for filters that do not declare any options.
-     *
-     * If this field is non-NULL, the first member of the filter private data
-     * must be a pointer to AVClass, which will be set by libavfilter generic
-     * code to this class.
-     */
-    const AVClass *priv_class;
-
-    /**
-     * A combination of AVFILTER_FLAG_*
-     */
-    int flags;
-
-    /*****************************************************************
-     * All fields below this line are not part of the public API. They
-     * may not be used outside of libavfilter and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     */
-
-    /**
-     * Filter initialization function.
-     *
-     * This callback will be called only once during the filter lifetime, after
-     * all the options have been set, but before links between filters are
-     * established and format negotiation is done.
-     *
-     * Basic filter initialization should be done here. Filters with dynamic
-     * inputs and/or outputs should create those inputs/outputs here based on
-     * provided options. No more changes to this filter's inputs/outputs can be
-     * done after this callback.
-     *
-     * This callback must not assume that the filter links exist or frame
-     * parameters are known.
-     *
-     * @ref AVFilter.uninit "uninit" is guaranteed to be called even if
-     * initialization fails, so this callback does not have to clean up on
-     * failure.
-     *
-     * @return 0 on success, a negative AVERROR on failure
-     */
-    int (*init)(AVFilterContext *ctx);
-
-    /**
-     * Should be set instead of @ref AVFilter.init "init" by the filters that
-     * want to pass a dictionary of AVOptions to nested contexts that are
-     * allocated during init.
-     *
-     * On return, the options dict should be freed and replaced with one that
-     * contains all the options which could not be processed by this filter (or
-     * with NULL if all the options were processed).
-     *
-     * Otherwise the semantics is the same as for @ref AVFilter.init "init".
-     */
-    int (*init_dict)(AVFilterContext *ctx, AVDictionary **options);
-
-    /**
-     * Filter uninitialization function.
-     *
-     * Called only once right before the filter is freed. Should deallocate any
-     * memory held by the filter, release any buffer references, etc. It does
-     * not need to deallocate the AVFilterContext.priv memory itself.
-     *
-     * This callback may be called even if @ref AVFilter.init "init" was not
-     * called or failed, so it must be prepared to handle such a situation.
-     */
-    void (*uninit)(AVFilterContext *ctx);
-
-    /**
-     * Query formats supported by the filter on its inputs and outputs.
-     *
-     * This callback is called after the filter is initialized (so the inputs
-     * and outputs are fixed), shortly before the format negotiation. This
-     * callback may be called more than once.
-     *
-     * This callback must set AVFilterLink.out_formats on every input link and
-     * AVFilterLink.in_formats on every output link to a list of pixel/sample
-     * formats that the filter supports on that link. For audio links, this
-     * filter must also set @ref AVFilterLink.in_samplerates "in_samplerates" /
-     * @ref AVFilterLink.out_samplerates "out_samplerates" and
-     * @ref AVFilterLink.in_channel_layouts "in_channel_layouts" /
-     * @ref AVFilterLink.out_channel_layouts "out_channel_layouts" analogously.
-     *
-     * This callback may be NULL for filters with one input, in which case
-     * libavfilter assumes that it supports all input formats and preserves
-     * them on output.
-     *
-     * @return zero on success, a negative value corresponding to an
-     * AVERROR code otherwise
-     */
-    int (*query_formats)(AVFilterContext *);
-
-    int priv_size;      ///< size of private data to allocate for the filter
-
-    /**
-     * Used by the filter registration system. Must not be touched by any other
-     * code.
-     */
-    struct AVFilter *next;
-
-    /**
-     * Make the filter instance process a command.
-     *
-     * @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only
-     * @param arg    the argument for the command
-     * @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported.
-     * @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be
-     *               time consuming then a filter should treat it like an unsupported command
-     *
-     * @returns >=0 on success otherwise an error code.
-     *          AVERROR(ENOSYS) on unsupported commands
-     */
-    int (*process_command)(AVFilterContext *, const char *cmd, const char *arg, char *res, int res_len, int flags);
-
-    /**
-     * Filter initialization function, alternative to the init()
-     * callback. Args contains the user-supplied parameters, opaque is
-     * used for providing binary data.
-     */
-    int (*init_opaque)(AVFilterContext *ctx, void *opaque);
-} AVFilter;
-
-/**
- * Process multiple parts of the frame concurrently.
- */
-#define AVFILTER_THREAD_SLICE (1 << 0)
-
-typedef struct AVFilterInternal AVFilterInternal;
-
-/** An instance of a filter */
-struct AVFilterContext {
-    const AVClass *av_class;        ///< needed for av_log() and filters common options
-
-    const AVFilter *filter;         ///< the AVFilter of which this is an instance
-
-    char *name;                     ///< name of this filter instance
-
-    AVFilterPad   *input_pads;      ///< array of input pads
-    AVFilterLink **inputs;          ///< array of pointers to input links
-#if FF_API_FOO_COUNT
-    attribute_deprecated unsigned input_count; ///< @deprecated use nb_inputs
-#endif
-    unsigned    nb_inputs;          ///< number of input pads
-
-    AVFilterPad   *output_pads;     ///< array of output pads
-    AVFilterLink **outputs;         ///< array of pointers to output links
-#if FF_API_FOO_COUNT
-    attribute_deprecated unsigned output_count; ///< @deprecated use nb_outputs
-#endif
-    unsigned    nb_outputs;         ///< number of output pads
-
-    void *priv;                     ///< private data for use by the filter
-
-    struct AVFilterGraph *graph;    ///< filtergraph this filter belongs to
-
-    /**
-     * Type of multithreading being allowed/used. A combination of
-     * AVFILTER_THREAD_* flags.
-     *
-     * May be set by the caller before initializing the filter to forbid some
-     * or all kinds of multithreading for this filter. The default is allowing
-     * everything.
-     *
-     * When the filter is initialized, this field is combined using bit AND with
-     * AVFilterGraph.thread_type to get the final mask used for determining
-     * allowed threading types. I.e. a threading type needs to be set in both
-     * to be allowed.
-     *
-     * After the filter is initialized, libavfilter sets this field to the
-     * threading type that is actually used (0 for no multithreading).
-     */
-    int thread_type;
-
-    /**
-     * An opaque struct for libavfilter internal use.
-     */
-    AVFilterInternal *internal;
-
-    struct AVFilterCommand *command_queue;
-
-    char *enable_str;               ///< enable expression string
-    void *enable;                   ///< parsed expression (AVExpr*)
-    double *var_values;             ///< variable values for the enable expression
-    int is_disabled;                ///< the enabled state from the last expression evaluation
-};
-
-/**
- * A link between two filters. This contains pointers to the source and
- * destination filters between which this link exists, and the indexes of
- * the pads involved. In addition, this link also contains the parameters
- * which have been negotiated and agreed upon between the filter, such as
- * image dimensions, format, etc.
- */
-struct AVFilterLink {
-    AVFilterContext *src;       ///< source filter
-    AVFilterPad *srcpad;        ///< output pad on the source filter
-
-    AVFilterContext *dst;       ///< dest filter
-    AVFilterPad *dstpad;        ///< input pad on the dest filter
-
-    enum AVMediaType type;      ///< filter media type
-
-    /* These parameters apply only to video */
-    int w;                      ///< agreed upon image width
-    int h;                      ///< agreed upon image height
-    AVRational sample_aspect_ratio; ///< agreed upon sample aspect ratio
-    /* These parameters apply only to audio */
-    uint64_t channel_layout;    ///< channel layout of current buffer (see libavutil/channel_layout.h)
-    int sample_rate;            ///< samples per second
-
-    int format;                 ///< agreed upon media format
-
-    /**
-     * Define the time base used by the PTS of the frames/samples
-     * which will pass through this link.
-     * During the configuration stage, each filter is supposed to
-     * change only the output timebase, while the timebase of the
-     * input link is assumed to be an unchangeable property.
-     */
-    AVRational time_base;
-
-    /*****************************************************************
-     * All fields below this line are not part of the public API. They
-     * may not be used outside of libavfilter and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     */
-    /**
-     * Lists of formats and channel layouts supported by the input and output
-     * filters respectively. These lists are used for negotiating the format
-     * to actually be used, which will be loaded into the format and
-     * channel_layout members, above, when chosen.
-     *
-     */
-    AVFilterFormats *in_formats;
-    AVFilterFormats *out_formats;
-
-    /**
-     * Lists of channel layouts and sample rates used for automatic
-     * negotiation.
-     */
-    AVFilterFormats  *in_samplerates;
-    AVFilterFormats *out_samplerates;
-    struct AVFilterChannelLayouts  *in_channel_layouts;
-    struct AVFilterChannelLayouts *out_channel_layouts;
-
-    /**
-     * Audio only, the destination filter sets this to a non-zero value to
-     * request that buffers with the given number of samples should be sent to
-     * it. AVFilterPad.needs_fifo must also be set on the corresponding input
-     * pad.
-     * Last buffer before EOF will be padded with silence.
-     */
-    int request_samples;
-
-    /** stage of the initialization of the link properties (dimensions, etc) */
-    enum {
-        AVLINK_UNINIT = 0,      ///< not started
-        AVLINK_STARTINIT,       ///< started, but incomplete
-        AVLINK_INIT             ///< complete
-    } init_state;
-
-    struct AVFilterPool *pool;
-
-    /**
-     * Graph the filter belongs to.
-     */
-    struct AVFilterGraph *graph;
-
-    /**
-     * Current timestamp of the link, as defined by the most recent
-     * frame(s), in AV_TIME_BASE units.
-     */
-    int64_t current_pts;
-
-    /**
-     * Index in the age array.
-     */
-    int age_index;
-
-    /**
-     * Frame rate of the stream on the link, or 1/0 if unknown;
-     * if left to 0/0, will be automatically be copied from the first input
-     * of the source filter if it exists.
-     *
-     * Sources should set it to the best estimation of the real frame rate.
-     * Filters should update it if necessary depending on their function.
-     * Sinks can use it to set a default output frame rate.
-     * It is similar to the r_frame_rate field in AVStream.
-     */
-    AVRational frame_rate;
-
-    /**
-     * Buffer partially filled with samples to achieve a fixed/minimum size.
-     */
-    AVFrame *partial_buf;
-
-    /**
-     * Size of the partial buffer to allocate.
-     * Must be between min_samples and max_samples.
-     */
-    int partial_buf_size;
-
-    /**
-     * Minimum number of samples to filter at once. If filter_frame() is
-     * called with fewer samples, it will accumulate them in partial_buf.
-     * This field and the related ones must not be changed after filtering
-     * has started.
-     * If 0, all related fields are ignored.
-     */
-    int min_samples;
-
-    /**
-     * Maximum number of samples to filter at once. If filter_frame() is
-     * called with more samples, it will split them.
-     */
-    int max_samples;
-
-    /**
-     * The buffer reference currently being received across the link by the
-     * destination filter. This is used internally by the filter system to
-     * allow automatic copying of buffers which do not have sufficient
-     * permissions for the destination. This should not be accessed directly
-     * by the filters.
-     */
-    AVFilterBufferRef *cur_buf_copy;
-
-    /**
-     * True if the link is closed.
-     * If set, all attempts of start_frame, filter_frame or request_frame
-     * will fail with AVERROR_EOF, and if necessary the reference will be
-     * destroyed.
-     * If request_frame returns AVERROR_EOF, this flag is set on the
-     * corresponding link.
-     * It can be set also be set by either the source or the destination
-     * filter.
-     */
-    int closed;
-
-    /**
-     * Number of channels.
-     */
-    int channels;
-
-    /**
-     * True if a frame is being requested on the link.
-     * Used internally by the framework.
-     */
-    unsigned frame_requested;
-
-    /**
-     * Link processing flags.
-     */
-    unsigned flags;
-
-    /**
-     * Number of past frames sent through the link.
-     */
-    int64_t frame_count;
-};
-
-/**
- * Link two filters together.
- *
- * @param src    the source filter
- * @param srcpad index of the output pad on the source filter
- * @param dst    the destination filter
- * @param dstpad index of the input pad on the destination filter
- * @return       zero on success
- */
-int avfilter_link(AVFilterContext *src, unsigned srcpad,
-                  AVFilterContext *dst, unsigned dstpad);
-
-/**
- * Free the link in *link, and set its pointer to NULL.
- */
-void avfilter_link_free(AVFilterLink **link);
-
-/**
- * Get the number of channels of a link.
- */
-int avfilter_link_get_channels(AVFilterLink *link);
-
-/**
- * Set the closed field of a link.
- */
-void avfilter_link_set_closed(AVFilterLink *link, int closed);
-
-/**
- * Negotiate the media format, dimensions, etc of all inputs to a filter.
- *
- * @param filter the filter to negotiate the properties for its inputs
- * @return       zero on successful negotiation
- */
-int avfilter_config_links(AVFilterContext *filter);
-
-#if FF_API_AVFILTERBUFFER
-/**
- * Create a buffer reference wrapped around an already allocated image
- * buffer.
- *
- * @param data pointers to the planes of the image to reference
- * @param linesize linesizes for the planes of the image to reference
- * @param perms the required access permissions
- * @param w the width of the image specified by the data and linesize arrays
- * @param h the height of the image specified by the data and linesize arrays
- * @param format the pixel format of the image specified by the data and linesize arrays
- */
-attribute_deprecated
-AVFilterBufferRef *
-avfilter_get_video_buffer_ref_from_arrays(uint8_t * const data[4], const int linesize[4], int perms,
-                                          int w, int h, enum AVPixelFormat format);
-
-/**
- * Create an audio buffer reference wrapped around an already
- * allocated samples buffer.
- *
- * See avfilter_get_audio_buffer_ref_from_arrays_channels() for a version
- * that can handle unknown channel layouts.
- *
- * @param data           pointers to the samples plane buffers
- * @param linesize       linesize for the samples plane buffers
- * @param perms          the required access permissions
- * @param nb_samples     number of samples per channel
- * @param sample_fmt     the format of each sample in the buffer to allocate
- * @param channel_layout the channel layout of the buffer
- */
-attribute_deprecated
-AVFilterBufferRef *avfilter_get_audio_buffer_ref_from_arrays(uint8_t **data,
-                                                             int linesize,
-                                                             int perms,
-                                                             int nb_samples,
-                                                             enum AVSampleFormat sample_fmt,
-                                                             uint64_t channel_layout);
-/**
- * Create an audio buffer reference wrapped around an already
- * allocated samples buffer.
- *
- * @param data           pointers to the samples plane buffers
- * @param linesize       linesize for the samples plane buffers
- * @param perms          the required access permissions
- * @param nb_samples     number of samples per channel
- * @param sample_fmt     the format of each sample in the buffer to allocate
- * @param channels       the number of channels of the buffer
- * @param channel_layout the channel layout of the buffer,
- *                       must be either 0 or consistent with channels
- */
-attribute_deprecated
-AVFilterBufferRef *avfilter_get_audio_buffer_ref_from_arrays_channels(uint8_t **data,
-                                                                      int linesize,
-                                                                      int perms,
-                                                                      int nb_samples,
-                                                                      enum AVSampleFormat sample_fmt,
-                                                                      int channels,
-                                                                      uint64_t channel_layout);
-
-#endif
-
-
-#define AVFILTER_CMD_FLAG_ONE   1 ///< Stop once a filter understood the command (for target=all for example), fast filters are favored automatically
-#define AVFILTER_CMD_FLAG_FAST  2 ///< Only execute command when its fast (like a video out that supports contrast adjustment in hw)
-
-/**
- * Make the filter instance process a command.
- * It is recommended to use avfilter_graph_send_command().
- */
-int avfilter_process_command(AVFilterContext *filter, const char *cmd, const char *arg, char *res, int res_len, int flags);
-
-/** Initialize the filter system. Register all builtin filters. */
-void avfilter_register_all(void);
-
-#if FF_API_OLD_FILTER_REGISTER
-/** Uninitialize the filter system. Unregister all filters. */
-attribute_deprecated
-void avfilter_uninit(void);
-#endif
-
-/**
- * Register a filter. This is only needed if you plan to use
- * avfilter_get_by_name later to lookup the AVFilter structure by name. A
- * filter can still by instantiated with avfilter_graph_alloc_filter even if it
- * is not registered.
- *
- * @param filter the filter to register
- * @return 0 if the registration was successful, a negative value
- * otherwise
- */
-int avfilter_register(AVFilter *filter);
-
-/**
- * Get a filter definition matching the given name.
- *
- * @param name the filter name to find
- * @return     the filter definition, if any matching one is registered.
- *             NULL if none found.
- */
-#if !FF_API_NOCONST_GET_NAME
-const
-#endif
-AVFilter *avfilter_get_by_name(const char *name);
-
-/**
- * Iterate over all registered filters.
- * @return If prev is non-NULL, next registered filter after prev or NULL if
- * prev is the last filter. If prev is NULL, return the first registered filter.
- */
-const AVFilter *avfilter_next(const AVFilter *prev);
-
-#if FF_API_OLD_FILTER_REGISTER
-/**
- * If filter is NULL, returns a pointer to the first registered filter pointer,
- * if filter is non-NULL, returns the next pointer after filter.
- * If the returned pointer points to NULL, the last registered filter
- * was already reached.
- * @deprecated use avfilter_next()
- */
-attribute_deprecated
-AVFilter **av_filter_next(AVFilter **filter);
-#endif
-
-#if FF_API_AVFILTER_OPEN
-/**
- * Create a filter instance.
- *
- * @param filter_ctx put here a pointer to the created filter context
- * on success, NULL on failure
- * @param filter    the filter to create an instance of
- * @param inst_name Name to give to the new instance. Can be NULL for none.
- * @return >= 0 in case of success, a negative error code otherwise
- * @deprecated use avfilter_graph_alloc_filter() instead
- */
-attribute_deprecated
-int avfilter_open(AVFilterContext **filter_ctx, AVFilter *filter, const char *inst_name);
-#endif
-
-
-#if FF_API_AVFILTER_INIT_FILTER
-/**
- * Initialize a filter.
- *
- * @param filter the filter to initialize
- * @param args   A string of parameters to use when initializing the filter.
- *               The format and meaning of this string varies by filter.
- * @param opaque Any extra non-string data needed by the filter. The meaning
- *               of this parameter varies by filter.
- * @return       zero on success
- */
-attribute_deprecated
-int avfilter_init_filter(AVFilterContext *filter, const char *args, void *opaque);
-#endif
-
-/**
- * Initialize a filter with the supplied parameters.
- *
- * @param ctx  uninitialized filter context to initialize
- * @param args Options to initialize the filter with. This must be a
- *             ':'-separated list of options in the 'key=value' form.
- *             May be NULL if the options have been set directly using the
- *             AVOptions API or there are no options that need to be set.
- * @return 0 on success, a negative AVERROR on failure
- */
-int avfilter_init_str(AVFilterContext *ctx, const char *args);
-
-/**
- * Initialize a filter with the supplied dictionary of options.
- *
- * @param ctx     uninitialized filter context to initialize
- * @param options An AVDictionary filled with options for this filter. On
- *                return this parameter will be destroyed and replaced with
- *                a dict containing options that were not found. This dictionary
- *                must be freed by the caller.
- *                May be NULL, then this function is equivalent to
- *                avfilter_init_str() with the second parameter set to NULL.
- * @return 0 on success, a negative AVERROR on failure
- *
- * @note This function and avfilter_init_str() do essentially the same thing,
- * the difference is in manner in which the options are passed. It is up to the
- * calling code to choose whichever is more preferable. The two functions also
- * behave differently when some of the provided options are not declared as
- * supported by the filter. In such a case, avfilter_init_str() will fail, but
- * this function will leave those extra options in the options AVDictionary and
- * continue as usual.
- */
-int avfilter_init_dict(AVFilterContext *ctx, AVDictionary **options);
-
-/**
- * Free a filter context. This will also remove the filter from its
- * filtergraph's list of filters.
- *
- * @param filter the filter to free
- */
-void avfilter_free(AVFilterContext *filter);
-
-/**
- * Insert a filter in the middle of an existing link.
- *
- * @param link the link into which the filter should be inserted
- * @param filt the filter to be inserted
- * @param filt_srcpad_idx the input pad on the filter to connect
- * @param filt_dstpad_idx the output pad on the filter to connect
- * @return     zero on success
- */
-int avfilter_insert_filter(AVFilterLink *link, AVFilterContext *filt,
-                           unsigned filt_srcpad_idx, unsigned filt_dstpad_idx);
-
-#if FF_API_AVFILTERBUFFER
-/**
- * Copy the frame properties of src to dst, without copying the actual
- * image data.
- *
- * @return 0 on success, a negative number on error.
- */
-attribute_deprecated
-int avfilter_copy_frame_props(AVFilterBufferRef *dst, const AVFrame *src);
-
-/**
- * Copy the frame properties and data pointers of src to dst, without copying
- * the actual data.
- *
- * @return 0 on success, a negative number on error.
- */
-attribute_deprecated
-int avfilter_copy_buf_props(AVFrame *dst, const AVFilterBufferRef *src);
-#endif
-
-/**
- * @return AVClass for AVFilterContext.
- *
- * @see av_opt_find().
- */
-const AVClass *avfilter_get_class(void);
-
-typedef struct AVFilterGraphInternal AVFilterGraphInternal;
-
-/**
- * A function pointer passed to the @ref AVFilterGraph.execute callback to be
- * executed multiple times, possibly in parallel.
- *
- * @param ctx the filter context the job belongs to
- * @param arg an opaque parameter passed through from @ref
- *            AVFilterGraph.execute
- * @param jobnr the index of the job being executed
- * @param nb_jobs the total number of jobs
- *
- * @return 0 on success, a negative AVERROR on error
- */
-typedef int (avfilter_action_func)(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs);
-
-/**
- * A function executing multiple jobs, possibly in parallel.
- *
- * @param ctx the filter context to which the jobs belong
- * @param func the function to be called multiple times
- * @param arg the argument to be passed to func
- * @param ret a nb_jobs-sized array to be filled with return values from each
- *            invocation of func
- * @param nb_jobs the number of jobs to execute
- *
- * @return 0 on success, a negative AVERROR on error
- */
-typedef int (avfilter_execute_func)(AVFilterContext *ctx, avfilter_action_func *func,
-                                    void *arg, int *ret, int nb_jobs);
-
-typedef struct AVFilterGraph {
-    const AVClass *av_class;
-#if FF_API_FOO_COUNT
-    attribute_deprecated
-    unsigned filter_count_unused;
-#endif
-    AVFilterContext **filters;
-#if !FF_API_FOO_COUNT
-    unsigned nb_filters;
-#endif
-
-    char *scale_sws_opts; ///< sws options to use for the auto-inserted scale filters
-    char *resample_lavr_opts;   ///< libavresample options to use for the auto-inserted resample filters
-#if FF_API_FOO_COUNT
-    unsigned nb_filters;
-#endif
-
-    /**
-     * Type of multithreading allowed for filters in this graph. A combination
-     * of AVFILTER_THREAD_* flags.
-     *
-     * May be set by the caller at any point, the setting will apply to all
-     * filters initialized after that. The default is allowing everything.
-     *
-     * When a filter in this graph is initialized, this field is combined using
-     * bit AND with AVFilterContext.thread_type to get the final mask used for
-     * determining allowed threading types. I.e. a threading type needs to be
-     * set in both to be allowed.
-     */
-    int thread_type;
-
-    /**
-     * Maximum number of threads used by filters in this graph. May be set by
-     * the caller before adding any filters to the filtergraph. Zero (the
-     * default) means that the number of threads is determined automatically.
-     */
-    int nb_threads;
-
-    /**
-     * Opaque object for libavfilter internal use.
-     */
-    AVFilterGraphInternal *internal;
-
-    /**
-     * Opaque user data. May be set by the caller to an arbitrary value, e.g. to
-     * be used from callbacks like @ref AVFilterGraph.execute.
-     * Libavfilter will not touch this field in any way.
-     */
-    void *opaque;
-
-    /**
-     * This callback may be set by the caller immediately after allocating the
-     * graph and before adding any filters to it, to provide a custom
-     * multithreading implementation.
-     *
-     * If set, filters with slice threading capability will call this callback
-     * to execute multiple jobs in parallel.
-     *
-     * If this field is left unset, libavfilter will use its internal
-     * implementation, which may or may not be multithreaded depending on the
-     * platform and build options.
-     */
-    avfilter_execute_func *execute;
-
-    char *aresample_swr_opts; ///< swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions
-
-    /**
-     * Private fields
-     *
-     * The following fields are for internal use only.
-     * Their type, offset, number and semantic can change without notice.
-     */
-
-    AVFilterLink **sink_links;
-    int sink_links_count;
-
-    unsigned disable_auto_convert;
-} AVFilterGraph;
-
-/**
- * Allocate a filter graph.
- */
-AVFilterGraph *avfilter_graph_alloc(void);
-
-/**
- * Create a new filter instance in a filter graph.
- *
- * @param graph graph in which the new filter will be used
- * @param filter the filter to create an instance of
- * @param name Name to give to the new instance (will be copied to
- *             AVFilterContext.name). This may be used by the caller to identify
- *             different filters, libavfilter itself assigns no semantics to
- *             this parameter. May be NULL.
- *
- * @return the context of the newly created filter instance (note that it is
- *         also retrievable directly through AVFilterGraph.filters or with
- *         avfilter_graph_get_filter()) on success or NULL on failure.
- */
-AVFilterContext *avfilter_graph_alloc_filter(AVFilterGraph *graph,
-                                             const AVFilter *filter,
-                                             const char *name);
-
-/**
- * Get a filter instance identified by instance name from graph.
- *
- * @param graph filter graph to search through.
- * @param name filter instance name (should be unique in the graph).
- * @return the pointer to the found filter instance or NULL if it
- * cannot be found.
- */
-AVFilterContext *avfilter_graph_get_filter(AVFilterGraph *graph, const char *name);
-
-#if FF_API_AVFILTER_OPEN
-/**
- * Add an existing filter instance to a filter graph.
- *
- * @param graphctx  the filter graph
- * @param filter the filter to be added
- *
- * @deprecated use avfilter_graph_alloc_filter() to allocate a filter in a
- * filter graph
- */
-attribute_deprecated
-int avfilter_graph_add_filter(AVFilterGraph *graphctx, AVFilterContext *filter);
-#endif
-
-/**
- * Create and add a filter instance into an existing graph.
- * The filter instance is created from the filter filt and inited
- * with the parameters args and opaque.
- *
- * In case of success put in *filt_ctx the pointer to the created
- * filter instance, otherwise set *filt_ctx to NULL.
- *
- * @param name the instance name to give to the created filter instance
- * @param graph_ctx the filter graph
- * @return a negative AVERROR error code in case of failure, a non
- * negative value otherwise
- */
-int avfilter_graph_create_filter(AVFilterContext **filt_ctx, const AVFilter *filt,
-                                 const char *name, const char *args, void *opaque,
-                                 AVFilterGraph *graph_ctx);
-
-/**
- * Enable or disable automatic format conversion inside the graph.
- *
- * Note that format conversion can still happen inside explicitly inserted
- * scale and aresample filters.
- *
- * @param flags  any of the AVFILTER_AUTO_CONVERT_* constants
- */
-void avfilter_graph_set_auto_convert(AVFilterGraph *graph, unsigned flags);
-
-enum {
-    AVFILTER_AUTO_CONVERT_ALL  =  0, /**< all automatic conversions enabled */
-    AVFILTER_AUTO_CONVERT_NONE = -1, /**< all automatic conversions disabled */
-};
-
-/**
- * Check validity and configure all the links and formats in the graph.
- *
- * @param graphctx the filter graph
- * @param log_ctx context used for logging
- * @return >= 0 in case of success, a negative AVERROR code otherwise
- */
-int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx);
-
-/**
- * Free a graph, destroy its links, and set *graph to NULL.
- * If *graph is NULL, do nothing.
- */
-void avfilter_graph_free(AVFilterGraph **graph);
-
-/**
- * A linked-list of the inputs/outputs of the filter chain.
- *
- * This is mainly useful for avfilter_graph_parse() / avfilter_graph_parse2(),
- * where it is used to communicate open (unlinked) inputs and outputs from and
- * to the caller.
- * This struct specifies, per each not connected pad contained in the graph, the
- * filter context and the pad index required for establishing a link.
- */
-typedef struct AVFilterInOut {
-    /** unique name for this input/output in the list */
-    char *name;
-
-    /** filter context associated to this input/output */
-    AVFilterContext *filter_ctx;
-
-    /** index of the filt_ctx pad to use for linking */
-    int pad_idx;
-
-    /** next input/input in the list, NULL if this is the last */
-    struct AVFilterInOut *next;
-} AVFilterInOut;
-
-/**
- * Allocate a single AVFilterInOut entry.
- * Must be freed with avfilter_inout_free().
- * @return allocated AVFilterInOut on success, NULL on failure.
- */
-AVFilterInOut *avfilter_inout_alloc(void);
-
-/**
- * Free the supplied list of AVFilterInOut and set *inout to NULL.
- * If *inout is NULL, do nothing.
- */
-void avfilter_inout_free(AVFilterInOut **inout);
-
-#if AV_HAVE_INCOMPATIBLE_LIBAV_ABI || !FF_API_OLD_GRAPH_PARSE
-/**
- * Add a graph described by a string to a graph.
- *
- * @note The caller must provide the lists of inputs and outputs,
- * which therefore must be known before calling the function.
- *
- * @note The inputs parameter describes inputs of the already existing
- * part of the graph; i.e. from the point of view of the newly created
- * part, they are outputs. Similarly the outputs parameter describes
- * outputs of the already existing filters, which are provided as
- * inputs to the parsed filters.
- *
- * @param graph   the filter graph where to link the parsed graph context
- * @param filters string to be parsed
- * @param inputs  linked list to the inputs of the graph
- * @param outputs linked list to the outputs of the graph
- * @return zero on success, a negative AVERROR code on error
- */
-int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,
-                         AVFilterInOut *inputs, AVFilterInOut *outputs,
-                         void *log_ctx);
-#else
-/**
- * Add a graph described by a string to a graph.
- *
- * @param graph   the filter graph where to link the parsed graph context
- * @param filters string to be parsed
- * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.
- *                If non-NULL, *inputs is updated to contain the list of open inputs
- *                after the parsing, should be freed with avfilter_inout_free().
- * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.
- *                If non-NULL, *outputs is updated to contain the list of open outputs
- *                after the parsing, should be freed with avfilter_inout_free().
- * @return non negative on success, a negative AVERROR code on error
- * @deprecated Use avfilter_graph_parse_ptr() instead.
- */
-attribute_deprecated
-int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,
-                         AVFilterInOut **inputs, AVFilterInOut **outputs,
-                         void *log_ctx);
-#endif
-
-/**
- * Add a graph described by a string to a graph.
- *
- * @param graph   the filter graph where to link the parsed graph context
- * @param filters string to be parsed
- * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.
- *                If non-NULL, *inputs is updated to contain the list of open inputs
- *                after the parsing, should be freed with avfilter_inout_free().
- * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.
- *                If non-NULL, *outputs is updated to contain the list of open outputs
- *                after the parsing, should be freed with avfilter_inout_free().
- * @return non negative on success, a negative AVERROR code on error
- */
-int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters,
-                             AVFilterInOut **inputs, AVFilterInOut **outputs,
-                             void *log_ctx);
-
-/**
- * Add a graph described by a string to a graph.
- *
- * @param[in]  graph   the filter graph where to link the parsed graph context
- * @param[in]  filters string to be parsed
- * @param[out] inputs  a linked list of all free (unlinked) inputs of the
- *                     parsed graph will be returned here. It is to be freed
- *                     by the caller using avfilter_inout_free().
- * @param[out] outputs a linked list of all free (unlinked) outputs of the
- *                     parsed graph will be returned here. It is to be freed by the
- *                     caller using avfilter_inout_free().
- * @return zero on success, a negative AVERROR code on error
- *
- * @note This function returns the inputs and outputs that are left
- * unlinked after parsing the graph and the caller then deals with
- * them.
- * @note This function makes no reference whatsoever to already
- * existing parts of the graph and the inputs parameter will on return
- * contain inputs of the newly parsed part of the graph.  Analogously
- * the outputs parameter will contain outputs of the newly created
- * filters.
- */
-int avfilter_graph_parse2(AVFilterGraph *graph, const char *filters,
-                          AVFilterInOut **inputs,
-                          AVFilterInOut **outputs);
-
-/**
- * Send a command to one or more filter instances.
- *
- * @param graph  the filter graph
- * @param target the filter(s) to which the command should be sent
- *               "all" sends to all filters
- *               otherwise it can be a filter or filter instance name
- *               which will send the command to all matching filters.
- * @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only
- * @param arg    the argument for the command
- * @param res    a buffer with size res_size where the filter(s) can return a response.
- *
- * @returns >=0 on success otherwise an error code.
- *              AVERROR(ENOSYS) on unsupported commands
- */
-int avfilter_graph_send_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, char *res, int res_len, int flags);
-
-/**
- * Queue a command for one or more filter instances.
- *
- * @param graph  the filter graph
- * @param target the filter(s) to which the command should be sent
- *               "all" sends to all filters
- *               otherwise it can be a filter or filter instance name
- *               which will send the command to all matching filters.
- * @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only
- * @param arg    the argument for the command
- * @param ts     time at which the command should be sent to the filter
- *
- * @note As this executes commands after this function returns, no return code
- *       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.
- */
-int avfilter_graph_queue_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, int flags, double ts);
-
-
-/**
- * Dump a graph into a human-readable string representation.
- *
- * @param graph    the graph to dump
- * @param options  formatting options; currently ignored
- * @return  a string, or NULL in case of memory allocation failure;
- *          the string must be freed using av_free
- */
-char *avfilter_graph_dump(AVFilterGraph *graph, const char *options);
-
-/**
- * Request a frame on the oldest sink link.
- *
- * If the request returns AVERROR_EOF, try the next.
- *
- * Note that this function is not meant to be the sole scheduling mechanism
- * of a filtergraph, only a convenience function to help drain a filtergraph
- * in a balanced way under normal circumstances.
- *
- * Also note that AVERROR_EOF does not mean that frames did not arrive on
- * some of the sinks during the process.
- * When there are multiple sink links, in case the requested link
- * returns an EOF, this may cause a filter to flush pending frames
- * which are sent to another sink link, although unrequested.
- *
- * @return  the return value of ff_request_frame(),
- *          or AVERROR_EOF if all links returned AVERROR_EOF
- */
-int avfilter_graph_request_oldest(AVFilterGraph *graph);
-
-/**
- * @}
- */
-
-#endif /* AVFILTER_AVFILTER_H */
diff -pruN /usr/include/ffmpeg/libavfilter/buffersink.h csrc/libavfilter/buffersink.h
--- /usr/include/ffmpeg/libavfilter/buffersink.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavfilter/buffersink.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,204 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVFILTER_BUFFERSINK_H
-#define AVFILTER_BUFFERSINK_H
-
-/**
- * @file
- * @ingroup lavfi_buffersink
- * memory buffer sink API for audio and video
- */
-
-#include "avfilter.h"
-
-/**
- * @defgroup lavfi_buffersink Buffer sink API
- * @ingroup lavfi
- * @{
- */
-
-#if FF_API_AVFILTERBUFFER
-/**
- * Get an audio/video buffer data from buffer_sink and put it in bufref.
- *
- * This function works with both audio and video buffer sinks.
- *
- * @param buffer_sink pointer to a buffersink or abuffersink context
- * @param flags a combination of AV_BUFFERSINK_FLAG_* flags
- * @return >= 0 in case of success, a negative AVERROR code in case of
- * failure
- */
-attribute_deprecated
-int av_buffersink_get_buffer_ref(AVFilterContext *buffer_sink,
-                                 AVFilterBufferRef **bufref, int flags);
-
-/**
- * Get the number of immediately available frames.
- */
-attribute_deprecated
-int av_buffersink_poll_frame(AVFilterContext *ctx);
-
-/**
- * Get a buffer with filtered data from sink and put it in buf.
- *
- * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.
- * @param buf pointer to the buffer will be written here if buf is non-NULL. buf
- *            must be freed by the caller using avfilter_unref_buffer().
- *            Buf may also be NULL to query whether a buffer is ready to be
- *            output.
- *
- * @return >= 0 in case of success, a negative AVERROR code in case of
- *         failure.
- */
-attribute_deprecated
-int av_buffersink_read(AVFilterContext *ctx, AVFilterBufferRef **buf);
-
-/**
- * Same as av_buffersink_read, but with the ability to specify the number of
- * samples read. This function is less efficient than av_buffersink_read(),
- * because it copies the data around.
- *
- * @param ctx pointer to a context of the abuffersink AVFilter.
- * @param buf pointer to the buffer will be written here if buf is non-NULL. buf
- *            must be freed by the caller using avfilter_unref_buffer(). buf
- *            will contain exactly nb_samples audio samples, except at the end
- *            of stream, when it can contain less than nb_samples.
- *            Buf may also be NULL to query whether a buffer is ready to be
- *            output.
- *
- * @warning do not mix this function with av_buffersink_read(). Use only one or
- * the other with a single sink, not both.
- */
-attribute_deprecated
-int av_buffersink_read_samples(AVFilterContext *ctx, AVFilterBufferRef **buf,
-                               int nb_samples);
-#endif
-
-/**
- * Get a frame with filtered data from sink and put it in frame.
- *
- * @param ctx    pointer to a buffersink or abuffersink filter context.
- * @param frame  pointer to an allocated frame that will be filled with data.
- *               The data must be freed using av_frame_unref() / av_frame_free()
- * @param flags  a combination of AV_BUFFERSINK_FLAG_* flags
- *
- * @return  >= 0 in for success, a negative AVERROR code for failure.
- */
-int av_buffersink_get_frame_flags(AVFilterContext *ctx, AVFrame *frame, int flags);
-
-/**
- * Tell av_buffersink_get_buffer_ref() to read video/samples buffer
- * reference, but not remove it from the buffer. This is useful if you
- * need only to read a video/samples buffer, without to fetch it.
- */
-#define AV_BUFFERSINK_FLAG_PEEK 1
-
-/**
- * Tell av_buffersink_get_buffer_ref() not to request a frame from its input.
- * If a frame is already buffered, it is read (and removed from the buffer),
- * but if no frame is present, return AVERROR(EAGAIN).
- */
-#define AV_BUFFERSINK_FLAG_NO_REQUEST 2
-
-/**
- * Struct to use for initializing a buffersink context.
- */
-typedef struct {
-    const enum AVPixelFormat *pixel_fmts; ///< list of allowed pixel formats, terminated by AV_PIX_FMT_NONE
-} AVBufferSinkParams;
-
-/**
- * Create an AVBufferSinkParams structure.
- *
- * Must be freed with av_free().
- */
-AVBufferSinkParams *av_buffersink_params_alloc(void);
-
-/**
- * Struct to use for initializing an abuffersink context.
- */
-typedef struct {
-    const enum AVSampleFormat *sample_fmts; ///< list of allowed sample formats, terminated by AV_SAMPLE_FMT_NONE
-    const int64_t *channel_layouts;         ///< list of allowed channel layouts, terminated by -1
-    const int *channel_counts;              ///< list of allowed channel counts, terminated by -1
-    int all_channel_counts;                 ///< if not 0, accept any channel count or layout
-    int *sample_rates;                      ///< list of allowed sample rates, terminated by -1
-} AVABufferSinkParams;
-
-/**
- * Create an AVABufferSinkParams structure.
- *
- * Must be freed with av_free().
- */
-AVABufferSinkParams *av_abuffersink_params_alloc(void);
-
-/**
- * Set the frame size for an audio buffer sink.
- *
- * All calls to av_buffersink_get_buffer_ref will return a buffer with
- * exactly the specified number of samples, or AVERROR(EAGAIN) if there is
- * not enough. The last buffer at EOF will be padded with 0.
- */
-void av_buffersink_set_frame_size(AVFilterContext *ctx, unsigned frame_size);
-
-/**
- * Get the frame rate of the input.
- */
-AVRational av_buffersink_get_frame_rate(AVFilterContext *ctx);
-
-/**
- * Get a frame with filtered data from sink and put it in frame.
- *
- * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.
- * @param frame pointer to an allocated frame that will be filled with data.
- *              The data must be freed using av_frame_unref() / av_frame_free()
- *
- * @return
- *         - >= 0 if a frame was successfully returned.
- *         - AVERROR(EAGAIN) if no frames are available at this point; more
- *           input frames must be added to the filtergraph to get more output.
- *         - AVERROR_EOF if there will be no more output frames on this sink.
- *         - A different negative AVERROR code in other failure cases.
- */
-int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame);
-
-/**
- * Same as av_buffersink_get_frame(), but with the ability to specify the number
- * of samples read. This function is less efficient than
- * av_buffersink_get_frame(), because it copies the data around.
- *
- * @param ctx pointer to a context of the abuffersink AVFilter.
- * @param frame pointer to an allocated frame that will be filled with data.
- *              The data must be freed using av_frame_unref() / av_frame_free()
- *              frame will contain exactly nb_samples audio samples, except at
- *              the end of stream, when it can contain less than nb_samples.
- *
- * @return The return codes have the same meaning as for
- *         av_buffersink_get_samples().
- *
- * @warning do not mix this function with av_buffersink_get_frame(). Use only one or
- * the other with a single sink, not both.
- */
-int av_buffersink_get_samples(AVFilterContext *ctx, AVFrame *frame, int nb_samples);
-
-/**
- * @}
- */
-
-#endif /* AVFILTER_BUFFERSINK_H */
diff -pruN /usr/include/ffmpeg/libavfilter/buffersrc.h csrc/libavfilter/buffersrc.h
--- /usr/include/ffmpeg/libavfilter/buffersrc.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavfilter/buffersrc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,160 +0,0 @@
-/*
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVFILTER_BUFFERSRC_H
-#define AVFILTER_BUFFERSRC_H
-
-/**
- * @file
- * @ingroup lavfi_buffersrc
- * Memory buffer source API.
- */
-
-#include "libavcodec/avcodec.h"
-#include "avfilter.h"
-
-/**
- * @defgroup lavfi_buffersrc Buffer source API
- * @ingroup lavfi
- * @{
- */
-
-enum {
-
-    /**
-     * Do not check for format changes.
-     */
-    AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1,
-
-#if FF_API_AVFILTERBUFFER
-    /**
-     * Ignored
-     */
-    AV_BUFFERSRC_FLAG_NO_COPY = 2,
-#endif
-
-    /**
-     * Immediately push the frame to the output.
-     */
-    AV_BUFFERSRC_FLAG_PUSH = 4,
-
-    /**
-     * Keep a reference to the frame.
-     * If the frame if reference-counted, create a new reference; otherwise
-     * copy the frame data.
-     */
-    AV_BUFFERSRC_FLAG_KEEP_REF = 8,
-
-};
-
-/**
- * Add buffer data in picref to buffer_src.
- *
- * @param buffer_src  pointer to a buffer source context
- * @param picref      a buffer reference, or NULL to mark EOF
- * @param flags       a combination of AV_BUFFERSRC_FLAG_*
- * @return            >= 0 in case of success, a negative AVERROR code
- *                    in case of failure
- */
-int av_buffersrc_add_ref(AVFilterContext *buffer_src,
-                         AVFilterBufferRef *picref, int flags);
-
-/**
- * Get the number of failed requests.
- *
- * A failed request is when the request_frame method is called while no
- * frame is present in the buffer.
- * The number is reset when a frame is added.
- */
-unsigned av_buffersrc_get_nb_failed_requests(AVFilterContext *buffer_src);
-
-#if FF_API_AVFILTERBUFFER
-/**
- * Add a buffer to a filtergraph.
- *
- * @param ctx an instance of the buffersrc filter
- * @param buf buffer containing frame data to be passed down the filtergraph.
- * This function will take ownership of buf, the user must not free it.
- * A NULL buf signals EOF -- i.e. no more frames will be sent to this filter.
- *
- * @deprecated use av_buffersrc_write_frame() or av_buffersrc_add_frame()
- */
-attribute_deprecated
-int av_buffersrc_buffer(AVFilterContext *ctx, AVFilterBufferRef *buf);
-#endif
-
-/**
- * Add a frame to the buffer source.
- *
- * @param ctx   an instance of the buffersrc filter
- * @param frame frame to be added. If the frame is reference counted, this
- * function will make a new reference to it. Otherwise the frame data will be
- * copied.
- *
- * @return 0 on success, a negative AVERROR on error
- *
- * This function is equivalent to av_buffersrc_add_frame_flags() with the
- * AV_BUFFERSRC_FLAG_KEEP_REF flag.
- */
-int av_buffersrc_write_frame(AVFilterContext *ctx, const AVFrame *frame);
-
-/**
- * Add a frame to the buffer source.
- *
- * @param ctx   an instance of the buffersrc filter
- * @param frame frame to be added. If the frame is reference counted, this
- * function will take ownership of the reference(s) and reset the frame.
- * Otherwise the frame data will be copied. If this function returns an error,
- * the input frame is not touched.
- *
- * @return 0 on success, a negative AVERROR on error.
- *
- * @note the difference between this function and av_buffersrc_write_frame() is
- * that av_buffersrc_write_frame() creates a new reference to the input frame,
- * while this function takes ownership of the reference passed to it.
- *
- * This function is equivalent to av_buffersrc_add_frame_flags() without the
- * AV_BUFFERSRC_FLAG_KEEP_REF flag.
- */
-int av_buffersrc_add_frame(AVFilterContext *ctx, AVFrame *frame);
-
-/**
- * Add a frame to the buffer source.
- *
- * By default, if the frame is reference-counted, this function will take
- * ownership of the reference(s) and reset the frame. This can be controlled
- * using the flags.
- *
- * If this function returns an error, the input frame is not touched.
- *
- * @param buffer_src  pointer to a buffer source context
- * @param frame       a frame, or NULL to mark EOF
- * @param flags       a combination of AV_BUFFERSRC_FLAG_*
- * @return            >= 0 in case of success, a negative AVERROR code
- *                    in case of failure
- */
-int av_buffersrc_add_frame_flags(AVFilterContext *buffer_src,
-                                 AVFrame *frame, int flags);
-
-
-/**
- * @}
- */
-
-#endif /* AVFILTER_BUFFERSRC_H */
diff -pruN /usr/include/ffmpeg/libavfilter/version.h csrc/libavfilter/version.h
--- /usr/include/ffmpeg/libavfilter/version.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavfilter/version.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-/*
- * Version macros.
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVFILTER_VERSION_H
-#define AVFILTER_VERSION_H
-
-/**
- * @file
- * @ingroup lavfi
- * Libavfilter version macros
- */
-
-#include "libavutil/version.h"
-
-#define LIBAVFILTER_VERSION_MAJOR   4
-#define LIBAVFILTER_VERSION_MINOR  11
-#define LIBAVFILTER_VERSION_MICRO 100
-
-#define LIBAVFILTER_VERSION_INT AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, \
-                                               LIBAVFILTER_VERSION_MINOR, \
-                                               LIBAVFILTER_VERSION_MICRO)
-#define LIBAVFILTER_VERSION     AV_VERSION(LIBAVFILTER_VERSION_MAJOR,   \
-                                           LIBAVFILTER_VERSION_MINOR,   \
-                                           LIBAVFILTER_VERSION_MICRO)
-#define LIBAVFILTER_BUILD       LIBAVFILTER_VERSION_INT
-
-#define LIBAVFILTER_IDENT       "Lavfi" AV_STRINGIFY(LIBAVFILTER_VERSION)
-
-/**
- * FF_API_* defines may be placed below to indicate public API that will be
- * dropped at a future version bump. The defines themselves are not part of
- * the public API and may change, break or disappear at any time.
- */
-
-#ifndef FF_API_AVFILTERPAD_PUBLIC
-#define FF_API_AVFILTERPAD_PUBLIC           (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_FOO_COUNT
-#define FF_API_FOO_COUNT                    (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_FILL_FRAME
-#define FF_API_FILL_FRAME                   (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_BUFFERSRC_BUFFER
-#define FF_API_BUFFERSRC_BUFFER             (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_AVFILTERBUFFER
-#define FF_API_AVFILTERBUFFER               (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_OLD_FILTER_OPTS
-#define FF_API_OLD_FILTER_OPTS              (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_ACONVERT_FILTER
-#define FF_API_ACONVERT_FILTER              (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_AVFILTER_OPEN
-#define FF_API_AVFILTER_OPEN                (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_AVFILTER_INIT_FILTER
-#define FF_API_AVFILTER_INIT_FILTER         (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_OLD_FILTER_REGISTER
-#define FF_API_OLD_FILTER_REGISTER          (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_OLD_GRAPH_PARSE
-#define FF_API_OLD_GRAPH_PARSE              (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_DRAWTEXT_OLD_TIMELINE
-#define FF_API_DRAWTEXT_OLD_TIMELINE        (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_NOCONST_GET_NAME
-#define FF_API_NOCONST_GET_NAME             (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-#ifndef FF_API_INTERLACE_LOWPASS_SET
-#define FF_API_INTERLACE_LOWPASS_SET        (LIBAVFILTER_VERSION_MAJOR < 5)
-#endif
-
-#endif /* AVFILTER_VERSION_H */
diff -pruN /usr/include/ffmpeg/libavformat/avformat.h csrc/libavformat/avformat.h
--- /usr/include/ffmpeg/libavformat/avformat.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavformat/avformat.h	2014-10-20 16:40:47.952910826 +0200
@@ -337,37 +337,6 @@ struct AVDeviceCapabilitiesQuery;
  * @}
  */
 
-/* packet functions */
-
-
-/**
- * Allocate and read the payload of a packet and initialize its
- * fields with default values.
- *
- * @param s    associated IO context
- * @param pkt packet
- * @param size desired payload size
- * @return >0 (read size) if OK, AVERROR_xxx otherwise
- */
-int av_get_packet(AVIOContext *s, AVPacket *pkt, int size);
-
-
-/**
- * Read data and append it to the current content of the AVPacket.
- * If pkt->size is 0 this is identical to av_get_packet.
- * Note that this uses av_grow_packet and thus involves a realloc
- * which is inefficient. Thus this function should only be used
- * when there is no reasonable way to know (an upper bound of)
- * the final size.
- *
- * @param s    associated IO context
- * @param pkt packet
- * @param size amount of data to read
- * @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data
- *         will not be lost even if an error occurs.
- */
-int av_append_packet(AVIOContext *s, AVPacket *pkt, int size);
-
 #if FF_API_LAVF_FRAC
 /*************************************************/
 /* fractional numbers for exact pts handling */
@@ -390,9 +359,7 @@ struct AVCodecTag;
  * This structure contains the data a format has to probe a file.
  */
 typedef struct AVProbeData {
-    const char *filename;
-    unsigned char *buf; /**< Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero. */
-    int buf_size;       /**< Size of buf except extra allocated bytes */
+    int dummy;
 } AVProbeData;
 
 #define AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4)
@@ -444,106 +411,7 @@ typedef struct AVProbeData {
  * @{
  */
 typedef struct AVOutputFormat {
-    const char *name;
-    /**
-     * Descriptive name for the format, meant to be more human-readable
-     * than name. You should use the NULL_IF_CONFIG_SMALL() macro
-     * to define it.
-     */
-    const char *long_name;
-    const char *mime_type;
-    const char *extensions; /**< comma-separated filename extensions */
-    /* output support */
-    enum AVCodecID audio_codec;    /**< default audio codec */
-    enum AVCodecID video_codec;    /**< default video codec */
-    enum AVCodecID subtitle_codec; /**< default subtitle codec */
-    /**
-     * can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_RAWPICTURE,
-     * AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,
-     * AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,
-     * AVFMT_TS_NONSTRICT
-     */
-    int flags;
-
-    /**
-     * List of supported codec_id-codec_tag pairs, ordered by "better
-     * choice first". The arrays are all terminated by AV_CODEC_ID_NONE.
-     */
-    const struct AVCodecTag * const *codec_tag;
-
-
-    const AVClass *priv_class; ///< AVClass for the private context
-
-    /*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavformat and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     */
-    struct AVOutputFormat *next;
-    /**
-     * size of private data so that it can be allocated in the wrapper
-     */
-    int priv_data_size;
-
-    int (*write_header)(struct AVFormatContext *);
-    /**
-     * Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,
-     * pkt can be NULL in order to flush data buffered in the muxer.
-     * When flushing, return 0 if there still is more data to flush,
-     * or 1 if everything was flushed and there is no more buffered
-     * data.
-     */
-    int (*write_packet)(struct AVFormatContext *, AVPacket *pkt);
-    int (*write_trailer)(struct AVFormatContext *);
-    /**
-     * Currently only used to set pixel format if not YUV420P.
-     */
-    int (*interleave_packet)(struct AVFormatContext *, AVPacket *out,
-                             AVPacket *in, int flush);
-    /**
-     * Test if the given codec can be stored in this container.
-     *
-     * @return 1 if the codec is supported, 0 if it is not.
-     *         A negative number if unknown.
-     *         MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC
-     */
-    int (*query_codec)(enum AVCodecID id, int std_compliance);
-
-    void (*get_output_timestamp)(struct AVFormatContext *s, int stream,
-                                 int64_t *dts, int64_t *wall);
-    /**
-     * Allows sending messages from application to device.
-     */
-    int (*control_message)(struct AVFormatContext *s, int type,
-                           void *data, size_t data_size);
-
-    /**
-     * Write an uncoded AVFrame.
-     *
-     * See av_write_uncoded_frame() for details.
-     *
-     * The library will free *frame afterwards, but the muxer can prevent it
-     * by setting the pointer to NULL.
-     */
-    int (*write_uncoded_frame)(struct AVFormatContext *, int stream_index,
-                               AVFrame **frame, unsigned flags);
-    /**
-     * Returns device list with it properties.
-     * @see avdevice_list_devices() for more details.
-     */
-    int (*get_device_list)(struct AVFormatContext *s, struct AVDeviceInfoList *device_list);
-    /**
-     * Initialize device capabilities submodule.
-     * @see avdevice_capabilities_create() for more details.
-     */
-    int (*create_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);
-    /**
-     * Free device capabilities submodule.
-     * @see avdevice_capabilities_free() for more details.
-     */
-    int (*free_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);
+    int dummy;
 } AVOutputFormat;
 /**
  * @}
@@ -554,142 +422,7 @@ typedef struct AVOutputFormat {
  * @{
  */
 typedef struct AVInputFormat {
-    /**
-     * A comma separated list of short names for the format. New names
-     * may be appended with a minor bump.
-     */
-    const char *name;
-
-    /**
-     * Descriptive name for the format, meant to be more human-readable
-     * than name. You should use the NULL_IF_CONFIG_SMALL() macro
-     * to define it.
-     */
-    const char *long_name;
-
-    /**
-     * Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,
-     * AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,
-     * AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.
-     */
-    int flags;
-
-    /**
-     * If extensions are defined, then no probe is done. You should
-     * usually not use extension format guessing because it is not
-     * reliable enough
-     */
-    const char *extensions;
-
-    const struct AVCodecTag * const *codec_tag;
-
-    const AVClass *priv_class; ///< AVClass for the private context
-
-    /*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavformat and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     */
-    struct AVInputFormat *next;
-
-    /**
-     * Raw demuxers store their codec ID here.
-     */
-    int raw_codec_id;
-
-    /**
-     * Size of private data so that it can be allocated in the wrapper.
-     */
-    int priv_data_size;
-
-    /**
-     * Tell if a given file has a chance of being parsed as this format.
-     * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
-     * big so you do not have to check for that unless you need more.
-     */
-    int (*read_probe)(AVProbeData *);
-
-    /**
-     * Read the format header and initialize the AVFormatContext
-     * structure. Return 0 if OK. Only used in raw format right
-     * now. 'avformat_new_stream' should be called to create new streams.
-     */
-    int (*read_header)(struct AVFormatContext *);
-
-    /**
-     * Read one packet and put it in 'pkt'. pts and flags are also
-     * set. 'avformat_new_stream' can be called only if the flag
-     * AVFMTCTX_NOHEADER is used and only in the calling thread (not in a
-     * background thread).
-     * @return 0 on success, < 0 on error.
-     *         When returning an error, pkt must not have been allocated
-     *         or must be freed before returning
-     */
-    int (*read_packet)(struct AVFormatContext *, AVPacket *pkt);
-
-    /**
-     * Close the stream. The AVFormatContext and AVStreams are not
-     * freed by this function
-     */
-    int (*read_close)(struct AVFormatContext *);
-
-    /**
-     * Seek to a given timestamp relative to the frames in
-     * stream component stream_index.
-     * @param stream_index Must not be -1.
-     * @param flags Selects which direction should be preferred if no exact
-     *              match is available.
-     * @return >= 0 on success (but not necessarily the new offset)
-     */
-    int (*read_seek)(struct AVFormatContext *,
-                     int stream_index, int64_t timestamp, int flags);
-
-    /**
-     * Get the next timestamp in stream[stream_index].time_base units.
-     * @return the timestamp or AV_NOPTS_VALUE if an error occurred
-     */
-    int64_t (*read_timestamp)(struct AVFormatContext *s, int stream_index,
-                              int64_t *pos, int64_t pos_limit);
-
-    /**
-     * Start/resume playing - only meaningful if using a network-based format
-     * (RTSP).
-     */
-    int (*read_play)(struct AVFormatContext *);
-
-    /**
-     * Pause playing - only meaningful if using a network-based format
-     * (RTSP).
-     */
-    int (*read_pause)(struct AVFormatContext *);
-
-    /**
-     * Seek to timestamp ts.
-     * Seeking will be done so that the point from which all active streams
-     * can be presented successfully will be closest to ts and within min/max_ts.
-     * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
-     */
-    int (*read_seek2)(struct AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags);
-
-    /**
-     * Returns device list with it properties.
-     * @see avdevice_list_devices() for more details.
-     */
-    int (*get_device_list)(struct AVFormatContext *s, struct AVDeviceInfoList *device_list);
-
-    /**
-     * Initialize device capabilities submodule.
-     * @see avdevice_capabilities_create() for more details.
-     */
-    int (*create_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);
-
-    /**
-     * Free device capabilities submodule.
-     * @see avdevice_capabilities_free() for more details.
-     */
-    int (*free_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);
+    int dummy;
 } AVInputFormat;
 /**
  * @}
@@ -707,57 +440,9 @@ enum AVStreamParseType {
 };
 
 typedef struct AVIndexEntry {
-    int64_t pos;
-    int64_t timestamp;        /**<
-                               * Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available
-                               * when seeking to this entry. That means preferable PTS on keyframe based formats.
-                               * But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better
-                               * is known
-                               */
-#define AVINDEX_KEYFRAME 0x0001
-    int flags:2;
-    int size:30; //Yeah, trying to keep the size of this small to reduce memory requirements (it is 24 vs. 32 bytes due to possible 8-byte alignment).
-    int min_distance;         /**< Minimum distance between this and the previous keyframe, used to avoid unneeded searching. */
+    int dummy;
 } AVIndexEntry;
 
-#define AV_DISPOSITION_DEFAULT   0x0001
-#define AV_DISPOSITION_DUB       0x0002
-#define AV_DISPOSITION_ORIGINAL  0x0004
-#define AV_DISPOSITION_COMMENT   0x0008
-#define AV_DISPOSITION_LYRICS    0x0010
-#define AV_DISPOSITION_KARAOKE   0x0020
-
-/**
- * Track should be used during playback by default.
- * Useful for subtitle track that should be displayed
- * even when user did not explicitly ask for subtitles.
- */
-#define AV_DISPOSITION_FORCED    0x0040
-#define AV_DISPOSITION_HEARING_IMPAIRED  0x0080  /**< stream for hearing impaired audiences */
-#define AV_DISPOSITION_VISUAL_IMPAIRED   0x0100  /**< stream for visual impaired audiences */
-#define AV_DISPOSITION_CLEAN_EFFECTS     0x0200  /**< stream without voice */
-/**
- * The stream is stored in the file as an attached picture/"cover art" (e.g.
- * APIC frame in ID3v2). The single packet associated with it will be returned
- * among the first few packets read from the file unless seeking takes place.
- * It can also be accessed at any time in AVStream.attached_pic.
- */
-#define AV_DISPOSITION_ATTACHED_PIC      0x0400
-
-/**
- * To specify text track kind (different from subtitles default).
- */
-#define AV_DISPOSITION_CAPTIONS     0x10000
-#define AV_DISPOSITION_DESCRIPTIONS 0x20000
-#define AV_DISPOSITION_METADATA     0x40000
-
-/**
- * Options for behavior on timestamp wrap detection.
- */
-#define AV_PTS_WRAP_IGNORE      0   ///< ignore the wrap
-#define AV_PTS_WRAP_ADD_OFFSET  1   ///< add the format specific offset on wrap detection
-#define AV_PTS_WRAP_SUB_OFFSET  -1  ///< subtract the format specific offset on wrap detection
-
 /**
  * Stream structure.
  * New fields can be added to the end with minor version bumps.
@@ -767,31 +452,11 @@ typedef struct AVIndexEntry {
  */
 typedef struct AVStream {
     int index;    /**< stream index in AVFormatContext */
-    /**
-     * Format-specific stream ID.
-     * decoding: set by libavformat
-     * encoding: set by the user, replaced by libavformat if left unset
-     */
     int id;
-    /**
-     * Codec context associated with this stream. Allocated and freed by
-     * libavformat.
-     *
-     * - decoding: The demuxer exports codec information stored in the headers
-     *             here.
-     * - encoding: The user sets codec information, the muxer writes it to the
-     *             output. Mandatory fields as specified in AVCodecContext
-     *             documentation must be set even if this AVCodecContext is
-     *             not actually used for encoding.
-     */
     AVCodecContext *codec;
     void *priv_data;
 
 #if FF_API_LAVF_FRAC
-    /**
-     * @deprecated this field is unused
-     */
-    attribute_deprecated
     struct AVFrac pts;
 #endif
 
@@ -1067,17 +732,6 @@ typedef struct AVStream {
 
 } AVStream;
 
-AVRational av_stream_get_r_frame_rate(const AVStream *s);
-void       av_stream_set_r_frame_rate(AVStream *s, AVRational r);
-struct AVCodecParserContext *av_stream_get_parser(const AVStream *s);
-
-/**
- * Returns the pts of the last muxed packet + its duration
- *
- * the retuned value is undefined when used with a demuxer.
- */
-int64_t    av_stream_get_end_pts(const AVStream *st);
-
 #define AV_PROGRAM_RUNNING 1
 
 /**
@@ -1087,39 +741,11 @@ int64_t    av_stream_get_end_pts(const A
  * sizeof(AVProgram) must not be used outside libav*.
  */
 typedef struct AVProgram {
-    int            id;
-    int            flags;
-    enum AVDiscard discard;        ///< selects which program to discard and which to feed to the caller
-    unsigned int   *stream_index;
-    unsigned int   nb_stream_indexes;
-    AVDictionary *metadata;
-
-    int program_num;
-    int pmt_pid;
-    int pcr_pid;
-
-    /*****************************************************************
-     * All fields below this line are not part of the public API. They
-     * may not be used outside of libavformat and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     */
-    int64_t start_time;
-    int64_t end_time;
-
-    int64_t pts_wrap_reference;    ///< reference dts for wrap detection
-    int pts_wrap_behavior;         ///< behavior on wrap detection
+    int dummy;
 } AVProgram;
 
-#define AVFMTCTX_NOHEADER      0x0001 /**< signal that no header is present
-                                         (streams are added dynamically) */
-
 typedef struct AVChapter {
-    int id;                 ///< unique ID to identify the chapter
-    AVRational time_base;   ///< time base in which the start/end timestamps are specified
-    int64_t start, end;     ///< chapter start/end time in time_base units
-    AVDictionary *metadata;
+    int dummy;
 } AVChapter;
 
 
@@ -1140,7 +766,9 @@ enum AVDurationEstimationMethod {
     AVFMT_DURATION_FROM_BITRATE ///< Duration estimated from bitrate (less accurate)
 };
 
-typedef struct AVFormatInternal AVFormatInternal;
+typedef struct AVFormatInternal  {
+    int dummy;
+} AVFormatInternal;
 
 /**
  * Format I/O context.
@@ -1291,10 +919,6 @@ typedef struct AVFormatContext {
      */
     unsigned int probesize;
 
-    /**
-     * @deprecated deprecated in favor of max_analyze_duration2
-     */
-    attribute_deprecated
     int max_analyze_duration;
 
     const uint8_t *key;
@@ -1662,64 +1286,17 @@ typedef struct AVFormatContext {
     int64_t max_analyze_duration2;
 } AVFormatContext;
 
-int av_format_get_probe_score(const AVFormatContext *s);
-AVCodec * av_format_get_video_codec(const AVFormatContext *s);
-void      av_format_set_video_codec(AVFormatContext *s, AVCodec *c);
-AVCodec * av_format_get_audio_codec(const AVFormatContext *s);
-void      av_format_set_audio_codec(AVFormatContext *s, AVCodec *c);
-AVCodec * av_format_get_subtitle_codec(const AVFormatContext *s);
-void      av_format_set_subtitle_codec(AVFormatContext *s, AVCodec *c);
-int       av_format_get_metadata_header_padding(const AVFormatContext *s);
-void      av_format_set_metadata_header_padding(AVFormatContext *s, int c);
-void *    av_format_get_opaque(const AVFormatContext *s);
-void      av_format_set_opaque(AVFormatContext *s, void *opaque);
-av_format_control_message av_format_get_control_message_cb(const AVFormatContext *s);
-void      av_format_set_control_message_cb(AVFormatContext *s, av_format_control_message callback);
-
-/**
- * This function will cause global side data to be injected in the next packet
- * of each stream as well as after any subsequent seek.
- */
-void av_format_inject_global_side_data(AVFormatContext *s);
-
-/**
- * Returns the method used to set ctx->duration.
- *
- * @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.
- */
-enum AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(const AVFormatContext* ctx);
-
 typedef struct AVPacketList {
-    AVPacket pkt;
-    struct AVPacketList *next;
+    int dummy;
 } AVPacketList;
 
 
 /**
- * @defgroup lavf_core Core functions
- * @ingroup libavf
- *
- * Functions for querying libavformat capabilities, allocating core structures,
- * etc.
- * @{
- */
-
-/**
  * Return the LIBAVFORMAT_VERSION_INT constant.
  */
 unsigned avformat_version(void);
 
 /**
- * Return the libavformat build-time configuration.
- */
-const char *avformat_configuration(void);
-
-/**
- * Return the libavformat license.
- */
-const char *avformat_license(void);
-
-/**
  * Initialize libavformat and register all the muxers, demuxers and
  * protocols. If you do not call this function, then you can select
  * exactly which formats you want to support.
@@ -1729,38 +1306,6 @@ const char *avformat_license(void);
  */
 void av_register_all(void);
 
-void av_register_input_format(AVInputFormat *format);
-void av_register_output_format(AVOutputFormat *format);
-
-/**
- * Do global initialization of network components. This is optional,
- * but recommended, since it avoids the overhead of implicitly
- * doing the setup for each session.
- *
- * Calling this function will become mandatory if using network
- * protocols at some major version bump.
- */
-int avformat_network_init(void);
-
-/**
- * Undo the initialization done by avformat_network_init.
- */
-int avformat_network_deinit(void);
-
-/**
- * If f is NULL, returns the first registered input format,
- * if f is non-NULL, returns the next registered input format after f
- * or NULL if f is the last one.
- */
-AVInputFormat  *av_iformat_next(AVInputFormat  *f);
-
-/**
- * If f is NULL, returns the first registered output format,
- * if f is non-NULL, returns the next registered output format after f
- * or NULL if f is the last one.
- */
-AVOutputFormat *av_oformat_next(AVOutputFormat *f);
-
 /**
  * Allocate an AVFormatContext.
  * avformat_free_context() can be used to free the context and everything
@@ -1775,14 +1320,6 @@ AVFormatContext *avformat_alloc_context(
 void avformat_free_context(AVFormatContext *s);
 
 /**
- * Get the AVClass for AVFormatContext. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- */
-const AVClass *avformat_get_class(void);
-
-/**
  * Add a new stream to a media file.
  *
  * When demuxing, it is called by the demuxer in read_header(). If the
@@ -1804,34 +1341,6 @@ const AVClass *avformat_get_class(void);
 AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c);
 
 /**
- * Get side information from stream.
- *
- * @param stream stream
- * @param type desired side information type
- * @param size pointer for side information size to store (optional)
- * @return pointer to data if present or NULL otherwise
- */
-uint8_t *av_stream_get_side_data(AVStream *stream,
-                                 enum AVPacketSideDataType type, int *size);
-
-AVProgram *av_new_program(AVFormatContext *s, int id);
-
-/**
- * @}
- */
-
-
-#if FF_API_ALLOC_OUTPUT_CONTEXT
-/**
- * @deprecated deprecated in favor of avformat_alloc_output_context2()
- */
-attribute_deprecated
-AVFormatContext *avformat_alloc_output_context(const char *format,
-                                               AVOutputFormat *oformat,
-                                               const char *filename);
-#endif
-
-/**
  * Allocate an AVFormatContext for an output format.
  * avformat_free_context() can be used to free the context and
  * everything allocated by the framework within it.
@@ -1851,75 +1360,6 @@ int avformat_alloc_output_context2(AVFor
                                    const char *format_name, const char *filename);
 
 /**
- * @addtogroup lavf_decoding
- * @{
- */
-
-/**
- * Find AVInputFormat based on the short name of the input format.
- */
-AVInputFormat *av_find_input_format(const char *short_name);
-
-/**
- * Guess the file format.
- *
- * @param pd        data to be probed
- * @param is_opened Whether the file is already opened; determines whether
- *                  demuxers with or without AVFMT_NOFILE are probed.
- */
-AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened);
-
-/**
- * Guess the file format.
- *
- * @param pd        data to be probed
- * @param is_opened Whether the file is already opened; determines whether
- *                  demuxers with or without AVFMT_NOFILE are probed.
- * @param score_max A probe score larger that this is required to accept a
- *                  detection, the variable is set to the actual detection
- *                  score afterwards.
- *                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended
- *                  to retry with a larger probe buffer.
- */
-AVInputFormat *av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max);
-
-/**
- * Guess the file format.
- *
- * @param is_opened Whether the file is already opened; determines whether
- *                  demuxers with or without AVFMT_NOFILE are probed.
- * @param score_ret The score of the best detection.
- */
-AVInputFormat *av_probe_input_format3(AVProbeData *pd, int is_opened, int *score_ret);
-
-/**
- * Probe a bytestream to determine the input format. Each time a probe returns
- * with a score that is too low, the probe buffer size is increased and another
- * attempt is made. When the maximum probe size is reached, the input format
- * with the highest score is returned.
- *
- * @param pb the bytestream to probe
- * @param fmt the input format is put here
- * @param filename the filename of the stream
- * @param logctx the log context
- * @param offset the offset within the bytestream to probe from
- * @param max_probe_size the maximum probe buffer size (zero for default)
- * @return the score in case of success, a negative value corresponding to an
- *         the maximal score is AVPROBE_SCORE_MAX
- * AVERROR code otherwise
- */
-int av_probe_input_buffer2(AVIOContext *pb, AVInputFormat **fmt,
-                           const char *filename, void *logctx,
-                           unsigned int offset, unsigned int max_probe_size);
-
-/**
- * Like av_probe_input_buffer2() but returns 0 on success
- */
-int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
-                          const char *filename, void *logctx,
-                          unsigned int offset, unsigned int max_probe_size);
-
-/**
  * Open an input stream and read the header. The codecs are not opened.
  * The stream must be closed with avformat_close_input().
  *
@@ -1940,29 +1380,6 @@ int av_probe_input_buffer(AVIOContext *p
  */
 int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options);
 
-attribute_deprecated
-int av_demuxer_open(AVFormatContext *ic);
-
-#if FF_API_FORMAT_PARAMETERS
-/**
- * Read packets of a media file to get stream information. This
- * is useful for file formats with no headers such as MPEG. This
- * function also computes the real framerate in case of MPEG-2 repeat
- * frame mode.
- * The logical file position is not changed by this function;
- * examined packets may be buffered for later processing.
- *
- * @param ic media file handle
- * @return >=0 if OK, AVERROR_xxx on error
- * @todo Let the user decide somehow what information is needed so that
- *       we do not waste time getting stuff the user does not need.
- *
- * @deprecated use avformat_find_stream_info.
- */
-attribute_deprecated
-int av_find_stream_info(AVFormatContext *ic);
-#endif
-
 /**
  * Read packets of a media file to get stream information. This
  * is useful for file formats with no headers such as MPEG. This
@@ -1987,18 +1404,6 @@ int av_find_stream_info(AVFormatContext
 int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);
 
 /**
- * Find the programs which belong to a given stream.
- *
- * @param ic    media file handle
- * @param last  the last found program, the search will start after this
- *              program, or from the beginning if it is NULL
- * @param s     stream index
- * @return the next program which belongs to s, NULL if no program is found or
- *         the last program is not among the programs of ic.
- */
-AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s);
-
-/**
  * Find the "best" stream in the file.
  * The best stream is determined according to various heuristics as the most
  * likely to be what the user expects.
@@ -2029,24 +1434,6 @@ int av_find_best_stream(AVFormatContext
                         AVCodec **decoder_ret,
                         int flags);
 
-#if FF_API_READ_PACKET
-/**
- * @deprecated use AVFMT_FLAG_NOFILLIN | AVFMT_FLAG_NOPARSE to read raw
- * unprocessed packets
- *
- * Read a transport packet from a media file.
- *
- * This function is obsolete and should never be used.
- * Use av_read_frame() instead.
- *
- * @param s media file handle
- * @param pkt is filled
- * @return 0 if OK, AVERROR_xxx on error
- */
-attribute_deprecated
-int av_read_packet(AVFormatContext *s, AVPacket *pkt);
-#endif
-
 /**
  * Return the next frame of a stream.
  * This function returns what is stored in the file, and does not validate
@@ -2120,61 +1507,10 @@ int av_seek_frame(AVFormatContext *s, in
 int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags);
 
 /**
- * Start playing a network-based stream (e.g. RTSP stream) at the
- * current position.
- */
-int av_read_play(AVFormatContext *s);
-
-/**
- * Pause a network-based stream (e.g. RTSP stream).
- *
- * Use av_read_play() to resume it.
- */
-int av_read_pause(AVFormatContext *s);
-
-#if FF_API_CLOSE_INPUT_FILE
-/**
- * @deprecated use avformat_close_input()
- * Close a media file (but not its codecs).
- *
- * @param s media file handle
- */
-attribute_deprecated
-void av_close_input_file(AVFormatContext *s);
-#endif
-
-/**
  * Close an opened input AVFormatContext. Free it and all its contents
  * and set *s to NULL.
  */
 void avformat_close_input(AVFormatContext **s);
-/**
- * @}
- */
-
-#if FF_API_NEW_STREAM
-/**
- * Add a new stream to a media file.
- *
- * Can only be called in the read_header() function. If the flag
- * AVFMTCTX_NOHEADER is in the format context, then new streams
- * can be added in read_packet too.
- *
- * @param s media file handle
- * @param id file-format-dependent stream ID
- */
-attribute_deprecated
-AVStream *av_new_stream(AVFormatContext *s, int id);
-#endif
-
-#if FF_API_SET_PTS_INFO
-/**
- * @deprecated this function is not supposed to be called outside of lavf
- */
-attribute_deprecated
-void av_set_pts_info(AVStream *s, int pts_wrap_bits,
-                     unsigned int pts_num, unsigned int pts_den);
-#endif
 
 #define AVSEEK_FLAG_BACKWARD 1 ///< seek backward
 #define AVSEEK_FLAG_BYTE     2 ///< seeking based on position in bytes
@@ -2182,10 +1518,6 @@ void av_set_pts_info(AVStream *s, int pt
 #define AVSEEK_FLAG_FRAME    8 ///< seeking based on frame number
 
 /**
- * @addtogroup lavf_encoding
- * @{
- */
-/**
  * Allocate the stream private data and write the stream header to
  * an output media file.
  *
@@ -2270,44 +1602,6 @@ int av_write_frame(AVFormatContext *s, A
 int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt);
 
 /**
- * Write a uncoded frame to an output media file.
- *
- * The frame must be correctly interleaved according to the container
- * specification; if not, then av_interleaved_write_frame() must be used.
- *
- * See av_interleaved_write_frame() for details.
- */
-int av_write_uncoded_frame(AVFormatContext *s, int stream_index,
-                           AVFrame *frame);
-
-/**
- * Write a uncoded frame to an output media file.
- *
- * If the muxer supports it, this function allows to write an AVFrame
- * structure directly, without encoding it into a packet.
- * It is mostly useful for devices and similar special muxers that use raw
- * video or PCM data and will not serialize it into a byte stream.
- *
- * To test whether it is possible to use it with a given muxer and stream,
- * use av_write_uncoded_frame_query().
- *
- * The caller gives up ownership of the frame and must not access it
- * afterwards.
- *
- * @return  >=0 for success, a negative code on error
- */
-int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index,
-                                       AVFrame *frame);
-
-/**
- * Test whether a muxer supports uncoded frame.
- *
- * @return  >=0 if an uncoded frame can be written to that muxer and stream,
- *          <0 if not
- */
-int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index);
-
-/**
  * Write the stream trailer to an output media file and free the
  * file private data.
  *
@@ -2342,173 +1636,6 @@ enum AVCodecID av_guess_codec(AVOutputFo
                             enum AVMediaType type);
 
 /**
- * Get timing information for the data currently output.
- * The exact meaning of "currently output" depends on the format.
- * It is mostly relevant for devices that have an internal buffer and/or
- * work in real time.
- * @param s          media file handle
- * @param stream     stream in the media file
- * @param[out] dts   DTS of the last packet output for the stream, in stream
- *                   time_base units
- * @param[out] wall  absolute time when that packet whas output,
- *                   in microsecond
- * @return  0 if OK, AVERROR(ENOSYS) if the format does not support it
- * Note: some formats or devices may not allow to measure dts and wall
- * atomically.
- */
-int av_get_output_timestamp(struct AVFormatContext *s, int stream,
-                            int64_t *dts, int64_t *wall);
-
-
-/**
- * @}
- */
-
-
-/**
- * @defgroup lavf_misc Utility functions
- * @ingroup libavf
- * @{
- *
- * Miscellaneous utility functions related to both muxing and demuxing
- * (or neither).
- */
-
-/**
- * Send a nice hexadecimal dump of a buffer to the specified file stream.
- *
- * @param f The file stream pointer where the dump should be sent to.
- * @param buf buffer
- * @param size buffer size
- *
- * @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2
- */
-void av_hex_dump(FILE *f, const uint8_t *buf, int size);
-
-/**
- * Send a nice hexadecimal dump of a buffer to the log.
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- * pointer to an AVClass struct.
- * @param level The importance level of the message, lower values signifying
- * higher importance.
- * @param buf buffer
- * @param size buffer size
- *
- * @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2
- */
-void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size);
-
-/**
- * Send a nice dump of a packet to the specified file stream.
- *
- * @param f The file stream pointer where the dump should be sent to.
- * @param pkt packet to dump
- * @param dump_payload True if the payload must be displayed, too.
- * @param st AVStream that the packet belongs to
- */
-void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st);
-
-
-/**
- * Send a nice dump of a packet to the log.
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- * pointer to an AVClass struct.
- * @param level The importance level of the message, lower values signifying
- * higher importance.
- * @param pkt packet to dump
- * @param dump_payload True if the payload must be displayed, too.
- * @param st AVStream that the packet belongs to
- */
-void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload,
-                      const AVStream *st);
-
-/**
- * Get the AVCodecID for the given codec tag tag.
- * If no codec id is found returns AV_CODEC_ID_NONE.
- *
- * @param tags list of supported codec_id-codec_tag pairs, as stored
- * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
- * @param tag  codec tag to match to a codec ID
- */
-enum AVCodecID av_codec_get_id(const struct AVCodecTag * const *tags, unsigned int tag);
-
-/**
- * Get the codec tag for the given codec id id.
- * If no codec tag is found returns 0.
- *
- * @param tags list of supported codec_id-codec_tag pairs, as stored
- * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
- * @param id   codec ID to match to a codec tag
- */
-unsigned int av_codec_get_tag(const struct AVCodecTag * const *tags, enum AVCodecID id);
-
-/**
- * Get the codec tag for the given codec id.
- *
- * @param tags list of supported codec_id - codec_tag pairs, as stored
- * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
- * @param id codec id that should be searched for in the list
- * @param tag A pointer to the found tag
- * @return 0 if id was not found in tags, > 0 if it was found
- */
-int av_codec_get_tag2(const struct AVCodecTag * const *tags, enum AVCodecID id,
-                      unsigned int *tag);
-
-int av_find_default_stream_index(AVFormatContext *s);
-
-/**
- * Get the index for a specific timestamp.
- *
- * @param st        stream that the timestamp belongs to
- * @param timestamp timestamp to retrieve the index for
- * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond
- *                 to the timestamp which is <= the requested one, if backward
- *                 is 0, then it will be >=
- *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
- * @return < 0 if no such timestamp could be found
- */
-int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags);
-
-/**
- * Add an index entry into a sorted list. Update the entry if the list
- * already contains it.
- *
- * @param timestamp timestamp in the time base of the given stream
- */
-int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,
-                       int size, int distance, int flags);
-
-
-/**
- * Split a URL string into components.
- *
- * The pointers to buffers for storing individual components may be null,
- * in order to ignore that component. Buffers for components not found are
- * set to empty strings. If the port is not found, it is set to a negative
- * value.
- *
- * @param proto the buffer for the protocol
- * @param proto_size the size of the proto buffer
- * @param authorization the buffer for the authorization
- * @param authorization_size the size of the authorization buffer
- * @param hostname the buffer for the host name
- * @param hostname_size the size of the hostname buffer
- * @param port_ptr a pointer to store the port number in
- * @param path the buffer for the path
- * @param path_size the size of the path buffer
- * @param url the URL to split
- */
-void av_url_split(char *proto,         int proto_size,
-                  char *authorization, int authorization_size,
-                  char *hostname,      int hostname_size,
-                  int *port_ptr,
-                  char *path,          int path_size,
-                  const char *url);
-
-
-/**
  * Print detailed information about the input or output format, such as
  * duration, bitrate, streams, container, programs, metadata, side data,
  * codec and time base.
@@ -2523,152 +1650,4 @@ void av_dump_format(AVFormatContext *ic,
                     const char *url,
                     int is_output);
 
-/**
- * Return in 'buf' the path with '%d' replaced by a number.
- *
- * Also handles the '%0nd' format where 'n' is the total number
- * of digits and '%%'.
- *
- * @param buf destination buffer
- * @param buf_size destination buffer size
- * @param path numbered sequence string
- * @param number frame number
- * @return 0 if OK, -1 on format error
- */
-int av_get_frame_filename(char *buf, int buf_size,
-                          const char *path, int number);
-
-/**
- * Check whether filename actually is a numbered sequence generator.
- *
- * @param filename possible numbered sequence string
- * @return 1 if a valid numbered sequence string, 0 otherwise
- */
-int av_filename_number_test(const char *filename);
-
-/**
- * Generate an SDP for an RTP session.
- *
- * Note, this overwrites the id values of AVStreams in the muxer contexts
- * for getting unique dynamic payload types.
- *
- * @param ac array of AVFormatContexts describing the RTP streams. If the
- *           array is composed by only one context, such context can contain
- *           multiple AVStreams (one AVStream per RTP stream). Otherwise,
- *           all the contexts in the array (an AVCodecContext per RTP stream)
- *           must contain only one AVStream.
- * @param n_files number of AVCodecContexts contained in ac
- * @param buf buffer where the SDP will be stored (must be allocated by
- *            the caller)
- * @param size the size of the buffer
- * @return 0 if OK, AVERROR_xxx on error
- */
-int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size);
-
-/**
- * Return a positive value if the given filename has one of the given
- * extensions, 0 otherwise.
- *
- * @param filename   file name to check against the given extensions
- * @param extensions a comma-separated list of filename extensions
- */
-int av_match_ext(const char *filename, const char *extensions);
-
-/**
- * Test if the given container can store a codec.
- *
- * @param ofmt           container to check for compatibility
- * @param codec_id       codec to potentially store in container
- * @param std_compliance standards compliance level, one of FF_COMPLIANCE_*
- *
- * @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.
- *         A negative number if this information is not available.
- */
-int avformat_query_codec(AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance);
-
-/**
- * @defgroup riff_fourcc RIFF FourCCs
- * @{
- * Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are
- * meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the
- * following code:
- * @code
- * uint32_t tag = MKTAG('H', '2', '6', '4');
- * const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };
- * enum AVCodecID id = av_codec_get_id(table, tag);
- * @endcode
- */
-/**
- * @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.
- */
-const struct AVCodecTag *avformat_get_riff_video_tags(void);
-/**
- * @return the table mapping RIFF FourCCs for audio to AVCodecID.
- */
-const struct AVCodecTag *avformat_get_riff_audio_tags(void);
-/**
- * @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.
- */
-const struct AVCodecTag *avformat_get_mov_video_tags(void);
-/**
- * @return the table mapping MOV FourCCs for audio to AVCodecID.
- */
-const struct AVCodecTag *avformat_get_mov_audio_tags(void);
-
-/**
- * @}
- */
-
-/**
- * Guess the sample aspect ratio of a frame, based on both the stream and the
- * frame aspect ratio.
- *
- * Since the frame aspect ratio is set by the codec but the stream aspect ratio
- * is set by the demuxer, these two may not be equal. This function tries to
- * return the value that you should use if you would like to display the frame.
- *
- * Basic logic is to use the stream aspect ratio if it is set to something sane
- * otherwise use the frame aspect ratio. This way a container setting, which is
- * usually easy to modify can override the coded value in the frames.
- *
- * @param format the format context which the stream is part of
- * @param stream the stream which the frame is part of
- * @param frame the frame with the aspect ratio to be determined
- * @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea
- */
-AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, AVFrame *frame);
-
-/**
- * Guess the frame rate, based on both the container and codec information.
- *
- * @param ctx the format context which the stream is part of
- * @param stream the stream which the frame is part of
- * @param frame the frame for which the frame rate should be determined, may be NULL
- * @return the guessed (valid) frame rate, 0/1 if no idea
- */
-AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, AVFrame *frame);
-
-/**
- * Check if the stream st contained in s is matched by the stream specifier
- * spec.
- *
- * See the "stream specifiers" chapter in the documentation for the syntax
- * of spec.
- *
- * @return  >0 if st is matched by spec;
- *          0  if st is not matched by spec;
- *          AVERROR code if spec is invalid
- *
- * @note  A stream specifier can match several streams in the format.
- */
-int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st,
-                                    const char *spec);
-
-int avformat_queue_attached_pictures(AVFormatContext *s);
-
-
-/**
- * @}
- */
-
 #endif /* AVFORMAT_AVFORMAT_H */
diff -pruN /usr/include/ffmpeg/libavformat/avio.h csrc/libavformat/avio.h
--- /usr/include/ffmpeg/libavformat/avio.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavformat/avio.h	2014-10-20 11:49:45.750052283 +0200
@@ -20,14 +20,6 @@
 #ifndef AVFORMAT_AVIO_H
 #define AVFORMAT_AVIO_H
 
-/**
- * @file
- * @ingroup lavf_io
- * Buffered I/O operations
- */
-
-#include <stdint.h>
-
 #include "libavutil/common.h"
 #include "libavutil/dict.h"
 #include "libavutil/log.h"
@@ -35,8 +27,6 @@
 #include "libavformat/version.h"
 
 
-#define AVIO_SEEKABLE_NORMAL 0x0001 /**< Seeking works like for a local file */
-
 /**
  * Callback for checking whether to abort blocking functions.
  * AVERROR_EXIT is returned in this case by the interrupted
@@ -49,8 +39,7 @@
  * or AVIOContext.
  */
 typedef struct AVIOInterruptCB {
-    int (*callback)(void*);
-    void *opaque;
+    int dummy;
 } AVIOInterruptCB;
 
 /**
@@ -66,120 +55,9 @@ typedef struct AVIOInterruptCB {
  *       function pointers specified in avio_alloc_context()
  */
 typedef struct AVIOContext {
-    /**
-     * A class for private options.
-     *
-     * If this AVIOContext is created by avio_open2(), av_class is set and
-     * passes the options down to protocols.
-     *
-     * If this AVIOContext is manually allocated, then av_class may be set by
-     * the caller.
-     *
-     * warning -- this field can be NULL, be sure to not pass this AVIOContext
-     * to any av_opt_* functions in that case.
-     */
-    const AVClass *av_class;
-    unsigned char *buffer;  /**< Start of the buffer. */
-    int buffer_size;        /**< Maximum buffer size */
-    unsigned char *buf_ptr; /**< Current position in the buffer */
-    unsigned char *buf_end; /**< End of the data, may be less than
-                                 buffer+buffer_size if the read function returned
-                                 less data than requested, e.g. for streams where
-                                 no more data has been received yet. */
-    void *opaque;           /**< A private pointer, passed to the read/write/seek/...
-                                 functions. */
-    int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);
-    int (*write_packet)(void *opaque, uint8_t *buf, int buf_size);
-    int64_t (*seek)(void *opaque, int64_t offset, int whence);
-    int64_t pos;            /**< position in the file of the current buffer */
-    int must_flush;         /**< true if the next seek should flush */
-    int eof_reached;        /**< true if eof reached */
-    int write_flag;         /**< true if open for writing */
-    int max_packet_size;
-    unsigned long checksum;
-    unsigned char *checksum_ptr;
-    unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);
-    int error;              /**< contains the error code or 0 if no error happened */
-    /**
-     * Pause or resume playback for network streaming protocols - e.g. MMS.
-     */
-    int (*read_pause)(void *opaque, int pause);
-    /**
-     * Seek to a given timestamp in stream with the specified stream_index.
-     * Needed for some network streaming protocols which don't support seeking
-     * to byte position.
-     */
-    int64_t (*read_seek)(void *opaque, int stream_index,
-                         int64_t timestamp, int flags);
-    /**
-     * A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.
-     */
-    int seekable;
-
-    /**
-     * max filesize, used to limit allocations
-     * This field is internal to libavformat and access from outside is not allowed.
-     */
-    int64_t maxsize;
-
-    /**
-     * avio_read and avio_write should if possible be satisfied directly
-     * instead of going through a buffer, and avio_seek will always
-     * call the underlying seek function directly.
-     */
-    int direct;
-
-    /**
-     * Bytes read statistic
-     * This field is internal to libavformat and access from outside is not allowed.
-     */
-    int64_t bytes_read;
-
-    /**
-     * seek statistic
-     * This field is internal to libavformat and access from outside is not allowed.
-     */
-    int seek_count;
-
-    /**
-     * writeout statistic
-     * This field is internal to libavformat and access from outside is not allowed.
-     */
-    int writeout_count;
-
-    /**
-     * Original buffer size
-     * used internally after probing and ensure seekback to reset the buffer size
-     * This field is internal to libavformat and access from outside is not allowed.
-     */
-    int orig_buffer_size;
+    int dummy;
 } AVIOContext;
 
-/* unbuffered I/O */
-
-/**
- * Return the name of the protocol that will handle the passed URL.
- *
- * NULL is returned if no protocol could be found for the given URL.
- *
- * @return Name of the protocol or NULL.
- */
-const char *avio_find_protocol_name(const char *url);
-
-/**
- * Return AVIO_FLAG_* access flags corresponding to the access permissions
- * of the resource in url, or a negative value corresponding to an
- * AVERROR code in case of failure. The returned access flags are
- * masked by the value in flags.
- *
- * @note This function is intrinsically unsafe, in the sense that the
- * checked resource may change its existence or permission status from
- * one call to another. Thus you should not trust the returned value,
- * unless you are sure that no other processes are accessing the
- * checked resource.
- */
-int avio_check(const char *url, int flags);
-
 /**
  * Allocate and initialize an AVIOContext for buffered I/O. It must be later
  * freed with av_free().
@@ -206,298 +84,17 @@ AVIOContext *avio_alloc_context(
                   int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
                   int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
                   int64_t (*seek)(void *opaque, int64_t offset, int whence));
-
-void avio_w8(AVIOContext *s, int b);
-void avio_write(AVIOContext *s, const unsigned char *buf, int size);
-void avio_wl64(AVIOContext *s, uint64_t val);
-void avio_wb64(AVIOContext *s, uint64_t val);
-void avio_wl32(AVIOContext *s, unsigned int val);
-void avio_wb32(AVIOContext *s, unsigned int val);
-void avio_wl24(AVIOContext *s, unsigned int val);
-void avio_wb24(AVIOContext *s, unsigned int val);
-void avio_wl16(AVIOContext *s, unsigned int val);
-void avio_wb16(AVIOContext *s, unsigned int val);
-
-/**
- * Write a NULL-terminated string.
- * @return number of bytes written.
- */
-int avio_put_str(AVIOContext *s, const char *str);
-
-/**
- * Convert an UTF-8 string to UTF-16LE and write it.
- * @return number of bytes written.
- */
-int avio_put_str16le(AVIOContext *s, const char *str);
-
-/**
- * Passing this as the "whence" parameter to a seek function causes it to
- * return the filesize without seeking anywhere. Supporting this is optional.
- * If it is not supported then the seek function will return <0.
- */
-#define AVSEEK_SIZE 0x10000
-
-/**
- * Oring this flag as into the "whence" parameter to a seek function causes it to
- * seek by any means (like reopening and linear reading) or other normally unreasonable
- * means that can be extremely slow.
- * This may be ignored by the seek code.
- */
-#define AVSEEK_FORCE 0x20000
-
-/**
- * fseek() equivalent for AVIOContext.
- * @return new position or AVERROR.
- */
-int64_t avio_seek(AVIOContext *s, int64_t offset, int whence);
-
-/**
- * Skip given number of bytes forward
- * @return new position or AVERROR.
- */
-int64_t avio_skip(AVIOContext *s, int64_t offset);
-
-/**
- * ftell() equivalent for AVIOContext.
- * @return position or AVERROR.
- */
-static av_always_inline int64_t avio_tell(AVIOContext *s)
-{
-    return avio_seek(s, 0, SEEK_CUR);
-}
-
-/**
- * Get the filesize.
- * @return filesize or AVERROR
- */
-int64_t avio_size(AVIOContext *s);
-
-/**
- * feof() equivalent for AVIOContext.
- * @return non zero if and only if end of file
- */
-int url_feof(AVIOContext *s);
-
-/** @warning currently size is limited */
-int avio_printf(AVIOContext *s, const char *fmt, ...) av_printf_format(2, 3);
-
-/**
- * Force flushing of buffered data to the output s.
- *
- * Force the buffered data to be immediately written to the output,
- * without to wait to fill the internal buffer.
- */
 void avio_flush(AVIOContext *s);
 
-/**
- * Read size bytes from AVIOContext into buf.
- * @return number of bytes read or AVERROR
- */
-int avio_read(AVIOContext *s, unsigned char *buf, int size);
-
-/**
- * @name Functions for reading from AVIOContext
- * @{
- *
- * @note return 0 if EOF, so you cannot use it if EOF handling is
- *       necessary
- */
-int          avio_r8  (AVIOContext *s);
-unsigned int avio_rl16(AVIOContext *s);
-unsigned int avio_rl24(AVIOContext *s);
-unsigned int avio_rl32(AVIOContext *s);
-uint64_t     avio_rl64(AVIOContext *s);
-unsigned int avio_rb16(AVIOContext *s);
-unsigned int avio_rb24(AVIOContext *s);
-unsigned int avio_rb32(AVIOContext *s);
-uint64_t     avio_rb64(AVIOContext *s);
-/**
- * @}
- */
-
-/**
- * Read a string from pb into buf. The reading will terminate when either
- * a NULL character was encountered, maxlen bytes have been read, or nothing
- * more can be read from pb. The result is guaranteed to be NULL-terminated, it
- * will be truncated if buf is too small.
- * Note that the string is not interpreted or validated in any way, it
- * might get truncated in the middle of a sequence for multi-byte encodings.
- *
- * @return number of bytes read (is always <= maxlen).
- * If reading ends on EOF or error, the return value will be one more than
- * bytes actually read.
- */
-int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen);
-
-/**
- * Read a UTF-16 string from pb and convert it to UTF-8.
- * The reading will terminate when either a null or invalid character was
- * encountered or maxlen bytes have been read.
- * @return number of bytes read (is always <= maxlen)
- */
-int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen);
-int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen);
-
-
-/**
- * @name URL open modes
- * The flags argument to avio_open must be one of the following
- * constants, optionally ORed with other flags.
- * @{
- */
 #define AVIO_FLAG_READ  1                                      /**< read-only */
 #define AVIO_FLAG_WRITE 2                                      /**< write-only */
 #define AVIO_FLAG_READ_WRITE (AVIO_FLAG_READ|AVIO_FLAG_WRITE)  /**< read-write pseudo flag */
-/**
- * @}
- */
-
-/**
- * Use non-blocking mode.
- * If this flag is set, operations on the context will return
- * AVERROR(EAGAIN) if they can not be performed immediately.
- * If this flag is not set, operations on the context will never return
- * AVERROR(EAGAIN).
- * Note that this flag does not affect the opening/connecting of the
- * context. Connecting a protocol will always block if necessary (e.g. on
- * network protocols) but never hang (e.g. on busy devices).
- * Warning: non-blocking protocols is work-in-progress; this flag may be
- * silently ignored.
- */
 #define AVIO_FLAG_NONBLOCK 8
-
-/**
- * Use direct mode.
- * avio_read and avio_write should if possible be satisfied directly
- * instead of going through a buffer, and avio_seek will always
- * call the underlying seek function directly.
- */
 #define AVIO_FLAG_DIRECT 0x8000
 
-/**
- * Create and initialize a AVIOContext for accessing the
- * resource indicated by url.
- * @note When the resource indicated by url has been opened in
- * read+write mode, the AVIOContext can be used only for writing.
- *
- * @param s Used to return the pointer to the created AVIOContext.
- * In case of failure the pointed to value is set to NULL.
- * @param url resource to access
- * @param flags flags which control how the resource indicated by url
- * is to be opened
- * @return >= 0 in case of success, a negative value corresponding to an
- * AVERROR code in case of failure
- */
 int avio_open(AVIOContext **s, const char *url, int flags);
-
-/**
- * Create and initialize a AVIOContext for accessing the
- * resource indicated by url.
- * @note When the resource indicated by url has been opened in
- * read+write mode, the AVIOContext can be used only for writing.
- *
- * @param s Used to return the pointer to the created AVIOContext.
- * In case of failure the pointed to value is set to NULL.
- * @param url resource to access
- * @param flags flags which control how the resource indicated by url
- * is to be opened
- * @param int_cb an interrupt callback to be used at the protocols level
- * @param options  A dictionary filled with protocol-private options. On return
- * this parameter will be destroyed and replaced with a dict containing options
- * that were not found. May be NULL.
- * @return >= 0 in case of success, a negative value corresponding to an
- * AVERROR code in case of failure
- */
 int avio_open2(AVIOContext **s, const char *url, int flags,
                const AVIOInterruptCB *int_cb, AVDictionary **options);
-
-/**
- * Close the resource accessed by the AVIOContext s and free it.
- * This function can only be used if s was opened by avio_open().
- *
- * The internal buffer is automatically flushed before closing the
- * resource.
- *
- * @return 0 on success, an AVERROR < 0 on error.
- * @see avio_closep
- */
 int avio_close(AVIOContext *s);
 
-/**
- * Close the resource accessed by the AVIOContext *s, free it
- * and set the pointer pointing to it to NULL.
- * This function can only be used if s was opened by avio_open().
- *
- * The internal buffer is automatically flushed before closing the
- * resource.
- *
- * @return 0 on success, an AVERROR < 0 on error.
- * @see avio_close
- */
-int avio_closep(AVIOContext **s);
-
-
-/**
- * Open a write only memory stream.
- *
- * @param s new IO context
- * @return zero if no error.
- */
-int avio_open_dyn_buf(AVIOContext **s);
-
-/**
- * Return the written size and a pointer to the buffer. The buffer
- * must be freed with av_free().
- * Padding of FF_INPUT_BUFFER_PADDING_SIZE is added to the buffer.
- *
- * @param s IO context
- * @param pbuffer pointer to a byte buffer
- * @return the length of the byte buffer
- */
-int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer);
-
-/**
- * Iterate through names of available protocols.
- *
- * @param opaque A private pointer representing current protocol.
- *        It must be a pointer to NULL on first iteration and will
- *        be updated by successive calls to avio_enum_protocols.
- * @param output If set to 1, iterate over output protocols,
- *               otherwise over input protocols.
- *
- * @return A static string containing the name of current protocol or NULL
- */
-const char *avio_enum_protocols(void **opaque, int output);
-
-/**
- * Pause and resume playing - only meaningful if using a network streaming
- * protocol (e.g. MMS).
- *
- * @param h     IO context from which to call the read_pause function pointer
- * @param pause 1 for pause, 0 for resume
- */
-int     avio_pause(AVIOContext *h, int pause);
-
-/**
- * Seek to a given timestamp relative to some component stream.
- * Only meaningful if using a network streaming protocol (e.g. MMS.).
- *
- * @param h IO context from which to call the seek function pointers
- * @param stream_index The stream index that the timestamp is relative to.
- *        If stream_index is (-1) the timestamp should be in AV_TIME_BASE
- *        units from the beginning of the presentation.
- *        If a stream_index >= 0 is used and the protocol does not support
- *        seeking based on component streams, the call will fail.
- * @param timestamp timestamp in AVStream.time_base units
- *        or if there is no stream specified then in AV_TIME_BASE units.
- * @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE
- *        and AVSEEK_FLAG_ANY. The protocol may silently ignore
- *        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will
- *        fail if used and not supported.
- * @return >= 0 on success
- * @see AVInputFormat::read_seek
- */
-int64_t avio_seek_time(AVIOContext *h, int stream_index,
-                       int64_t timestamp, int flags);
-
 #endif /* AVFORMAT_AVIO_H */
diff -pruN /usr/include/ffmpeg/libavformat/version.h csrc/libavformat/version.h
--- /usr/include/ffmpeg/libavformat/version.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavformat/version.h	2014-10-20 16:55:48.952664461 +0200
@@ -1,32 +1,7 @@
-/*
- * Version macros.
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
 
 #ifndef AVFORMAT_VERSION_H
 #define AVFORMAT_VERSION_H
 
-/**
- * @file
- * @ingroup libavf
- * Libavformat version macros
- */
-
 #include "libavutil/version.h"
 
 #define LIBAVFORMAT_VERSION_MAJOR 55
@@ -41,7 +16,7 @@
                                            LIBAVFORMAT_VERSION_MICRO)
 #define LIBAVFORMAT_BUILD       LIBAVFORMAT_VERSION_INT
 
-#define LIBAVFORMAT_IDENT       "Lavf" AV_STRINGIFY(LIBAVFORMAT_VERSION)
+#define LIBAVFORMAT_IDENT       "Lavf55.48.100"
 
 /**
  * FF_API_* defines may be placed below to indicate public API that will be
diff -pruN /usr/include/ffmpeg/libavresample/avresample.h csrc/libavresample/avresample.h
--- /usr/include/ffmpeg/libavresample/avresample.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavresample/avresample.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,429 +0,0 @@
-/*
- * Copyright (c) 2012 Justin Ruggles <justin.ruggles@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVRESAMPLE_AVRESAMPLE_H
-#define AVRESAMPLE_AVRESAMPLE_H
-
-/**
- * @file
- * @ingroup lavr
- * external API header
- */
-
-/**
- * @defgroup lavr Libavresample
- * @{
- *
- * Libavresample (lavr) is a library that handles audio resampling, sample
- * format conversion and mixing.
- *
- * Interaction with lavr is done through AVAudioResampleContext, which is
- * allocated with avresample_alloc_context(). It is opaque, so all parameters
- * must be set with the @ref avoptions API.
- *
- * For example the following code will setup conversion from planar float sample
- * format to interleaved signed 16-bit integer, downsampling from 48kHz to
- * 44.1kHz and downmixing from 5.1 channels to stereo (using the default mixing
- * matrix):
- * @code
- * AVAudioResampleContext *avr = avresample_alloc_context();
- * av_opt_set_int(avr, "in_channel_layout",  AV_CH_LAYOUT_5POINT1, 0);
- * av_opt_set_int(avr, "out_channel_layout", AV_CH_LAYOUT_STEREO,  0);
- * av_opt_set_int(avr, "in_sample_rate",     48000,                0);
- * av_opt_set_int(avr, "out_sample_rate",    44100,                0);
- * av_opt_set_int(avr, "in_sample_fmt",      AV_SAMPLE_FMT_FLTP,   0);
- * av_opt_set_int(avr, "out_sample_fmt",     AV_SAMPLE_FMT_S16,    0);
- * @endcode
- *
- * Once the context is initialized, it must be opened with avresample_open(). If
- * you need to change the conversion parameters, you must close the context with
- * avresample_close(), change the parameters as described above, then reopen it
- * again.
- *
- * The conversion itself is done by repeatedly calling avresample_convert().
- * Note that the samples may get buffered in two places in lavr. The first one
- * is the output FIFO, where the samples end up if the output buffer is not
- * large enough. The data stored in there may be retrieved at any time with
- * avresample_read(). The second place is the resampling delay buffer,
- * applicable only when resampling is done. The samples in it require more input
- * before they can be processed. Their current amount is returned by
- * avresample_get_delay(). At the end of conversion the resampling buffer can be
- * flushed by calling avresample_convert() with NULL input.
- *
- * The following code demonstrates the conversion loop assuming the parameters
- * from above and caller-defined functions get_input() and handle_output():
- * @code
- * uint8_t **input;
- * int in_linesize, in_samples;
- *
- * while (get_input(&input, &in_linesize, &in_samples)) {
- *     uint8_t *output
- *     int out_linesize;
- *     int out_samples = avresample_get_out_samples(avr, in_samples);
- *
- *     av_samples_alloc(&output, &out_linesize, 2, out_samples,
- *                      AV_SAMPLE_FMT_S16, 0);
- *     out_samples = avresample_convert(avr, &output, out_linesize, out_samples,
- *                                      input, in_linesize, in_samples);
- *     handle_output(output, out_linesize, out_samples);
- *     av_freep(&output);
- *  }
- *  @endcode
- *
- *  When the conversion is finished and the FIFOs are flushed if required, the
- *  conversion context and everything associated with it must be freed with
- *  avresample_free().
- */
-
-#include "libavutil/avutil.h"
-#include "libavutil/channel_layout.h"
-#include "libavutil/dict.h"
-#include "libavutil/log.h"
-#include "libavutil/mathematics.h"
-
-#include "libavresample/version.h"
-
-#define AVRESAMPLE_MAX_CHANNELS 32
-
-typedef struct AVAudioResampleContext AVAudioResampleContext;
-
-/** Mixing Coefficient Types */
-enum AVMixCoeffType {
-    AV_MIX_COEFF_TYPE_Q8,   /** 16-bit 8.8 fixed-point                      */
-    AV_MIX_COEFF_TYPE_Q15,  /** 32-bit 17.15 fixed-point                    */
-    AV_MIX_COEFF_TYPE_FLT,  /** floating-point                              */
-    AV_MIX_COEFF_TYPE_NB,   /** Number of coeff types. Not part of ABI      */
-};
-
-/** Resampling Filter Types */
-enum AVResampleFilterType {
-    AV_RESAMPLE_FILTER_TYPE_CUBIC,              /**< Cubic */
-    AV_RESAMPLE_FILTER_TYPE_BLACKMAN_NUTTALL,   /**< Blackman Nuttall Windowed Sinc */
-    AV_RESAMPLE_FILTER_TYPE_KAISER,             /**< Kaiser Windowed Sinc */
-};
-
-enum AVResampleDitherMethod {
-    AV_RESAMPLE_DITHER_NONE,            /**< Do not use dithering */
-    AV_RESAMPLE_DITHER_RECTANGULAR,     /**< Rectangular Dither */
-    AV_RESAMPLE_DITHER_TRIANGULAR,      /**< Triangular Dither*/
-    AV_RESAMPLE_DITHER_TRIANGULAR_HP,   /**< Triangular Dither with High Pass */
-    AV_RESAMPLE_DITHER_TRIANGULAR_NS,   /**< Triangular Dither with Noise Shaping */
-    AV_RESAMPLE_DITHER_NB,              /**< Number of dither types. Not part of ABI. */
-};
-
-/**
- * Return the LIBAVRESAMPLE_VERSION_INT constant.
- */
-unsigned avresample_version(void);
-
-/**
- * Return the libavresample build-time configuration.
- * @return  configure string
- */
-const char *avresample_configuration(void);
-
-/**
- * Return the libavresample license.
- */
-const char *avresample_license(void);
-
-/**
- * Get the AVClass for AVAudioResampleContext.
- *
- * Can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options
- * without allocating a context.
- *
- * @see av_opt_find().
- *
- * @return AVClass for AVAudioResampleContext
- */
-const AVClass *avresample_get_class(void);
-
-/**
- * Allocate AVAudioResampleContext and set options.
- *
- * @return  allocated audio resample context, or NULL on failure
- */
-AVAudioResampleContext *avresample_alloc_context(void);
-
-/**
- * Initialize AVAudioResampleContext.
- *
- * @param avr  audio resample context
- * @return     0 on success, negative AVERROR code on failure
- */
-int avresample_open(AVAudioResampleContext *avr);
-
-/**
- * Check whether an AVAudioResampleContext is open or closed.
- *
- * @param avr AVAudioResampleContext to check
- * @return 1 if avr is open, 0 if avr is closed.
- */
-int avresample_is_open(AVAudioResampleContext *avr);
-
-/**
- * Close AVAudioResampleContext.
- *
- * This closes the context, but it does not change the parameters. The context
- * can be reopened with avresample_open(). It does, however, clear the output
- * FIFO and any remaining leftover samples in the resampling delay buffer. If
- * there was a custom matrix being used, that is also cleared.
- *
- * @see avresample_convert()
- * @see avresample_set_matrix()
- *
- * @param avr  audio resample context
- */
-void avresample_close(AVAudioResampleContext *avr);
-
-/**
- * Free AVAudioResampleContext and associated AVOption values.
- *
- * This also calls avresample_close() before freeing.
- *
- * @param avr  audio resample context
- */
-void avresample_free(AVAudioResampleContext **avr);
-
-/**
- * Generate a channel mixing matrix.
- *
- * This function is the one used internally by libavresample for building the
- * default mixing matrix. It is made public just as a utility function for
- * building custom matrices.
- *
- * @param in_layout           input channel layout
- * @param out_layout          output channel layout
- * @param center_mix_level    mix level for the center channel
- * @param surround_mix_level  mix level for the surround channel(s)
- * @param lfe_mix_level       mix level for the low-frequency effects channel
- * @param normalize           if 1, coefficients will be normalized to prevent
- *                            overflow. if 0, coefficients will not be
- *                            normalized.
- * @param[out] matrix         mixing coefficients; matrix[i + stride * o] is
- *                            the weight of input channel i in output channel o.
- * @param stride              distance between adjacent input channels in the
- *                            matrix array
- * @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)
- * @return                    0 on success, negative AVERROR code on failure
- */
-int avresample_build_matrix(uint64_t in_layout, uint64_t out_layout,
-                            double center_mix_level, double surround_mix_level,
-                            double lfe_mix_level, int normalize, double *matrix,
-                            int stride, enum AVMatrixEncoding matrix_encoding);
-
-/**
- * Get the current channel mixing matrix.
- *
- * If no custom matrix has been previously set or the AVAudioResampleContext is
- * not open, an error is returned.
- *
- * @param avr     audio resample context
- * @param matrix  mixing coefficients; matrix[i + stride * o] is the weight of
- *                input channel i in output channel o.
- * @param stride  distance between adjacent input channels in the matrix array
- * @return        0 on success, negative AVERROR code on failure
- */
-int avresample_get_matrix(AVAudioResampleContext *avr, double *matrix,
-                          int stride);
-
-/**
- * Set channel mixing matrix.
- *
- * Allows for setting a custom mixing matrix, overriding the default matrix
- * generated internally during avresample_open(). This function can be called
- * anytime on an allocated context, either before or after calling
- * avresample_open(), as long as the channel layouts have been set.
- * avresample_convert() always uses the current matrix.
- * Calling avresample_close() on the context will clear the current matrix.
- *
- * @see avresample_close()
- *
- * @param avr     audio resample context
- * @param matrix  mixing coefficients; matrix[i + stride * o] is the weight of
- *                input channel i in output channel o.
- * @param stride  distance between adjacent input channels in the matrix array
- * @return        0 on success, negative AVERROR code on failure
- */
-int avresample_set_matrix(AVAudioResampleContext *avr, const double *matrix,
-                          int stride);
-
-/**
- * Set a customized input channel mapping.
- *
- * This function can only be called when the allocated context is not open.
- * Also, the input channel layout must have already been set.
- *
- * Calling avresample_close() on the context will clear the channel mapping.
- *
- * The map for each input channel specifies the channel index in the source to
- * use for that particular channel, or -1 to mute the channel. Source channels
- * can be duplicated by using the same index for multiple input channels.
- *
- * Examples:
- *
- * Reordering 5.1 AAC order (C,L,R,Ls,Rs,LFE) to FFmpeg order (L,R,C,LFE,Ls,Rs):
- * { 1, 2, 0, 5, 3, 4 }
- *
- * Muting the 3rd channel in 4-channel input:
- * { 0, 1, -1, 3 }
- *
- * Duplicating the left channel of stereo input:
- * { 0, 0 }
- *
- * @param avr         audio resample context
- * @param channel_map customized input channel mapping
- * @return            0 on success, negative AVERROR code on failure
- */
-int avresample_set_channel_mapping(AVAudioResampleContext *avr,
-                                   const int *channel_map);
-
-/**
- * Set compensation for resampling.
- *
- * This can be called anytime after avresample_open(). If resampling is not
- * automatically enabled because of a sample rate conversion, the
- * "force_resampling" option must have been set to 1 when opening the context
- * in order to use resampling compensation.
- *
- * @param avr                    audio resample context
- * @param sample_delta           compensation delta, in samples
- * @param compensation_distance  compensation distance, in samples
- * @return                       0 on success, negative AVERROR code on failure
- */
-int avresample_set_compensation(AVAudioResampleContext *avr, int sample_delta,
-                                int compensation_distance);
-
-/**
- * Provide the upper bound on the number of samples the configured
- * conversion would output.
- *
- * @param avr           audio resample context
- * @param in_nb_samples number of input samples
- *
- * @return              number of samples or AVERROR(EINVAL) if the value
- *                      would exceed INT_MAX
- */
-
-int avresample_get_out_samples(AVAudioResampleContext *avr, int in_nb_samples);
-
-/**
- * Convert input samples and write them to the output FIFO.
- *
- * The upper bound on the number of output samples can be obtained through
- * avresample_get_out_samples().
- *
- * The output data can be NULL or have fewer allocated samples than required.
- * In this case, any remaining samples not written to the output will be added
- * to an internal FIFO buffer, to be returned at the next call to this function
- * or to avresample_read().
- *
- * If converting sample rate, there may be data remaining in the internal
- * resampling delay buffer. avresample_get_delay() tells the number of remaining
- * samples. To get this data as output, call avresample_convert() with NULL
- * input.
- *
- * At the end of the conversion process, there may be data remaining in the
- * internal FIFO buffer. avresample_available() tells the number of remaining
- * samples. To get this data as output, either call avresample_convert() with
- * NULL input or call avresample_read().
- *
- * @see avresample_get_out_samples()
- * @see avresample_read()
- * @see avresample_get_delay()
- *
- * @param avr             audio resample context
- * @param output          output data pointers
- * @param out_plane_size  output plane size, in bytes.
- *                        This can be 0 if unknown, but that will lead to
- *                        optimized functions not being used directly on the
- *                        output, which could slow down some conversions.
- * @param out_samples     maximum number of samples that the output buffer can hold
- * @param input           input data pointers
- * @param in_plane_size   input plane size, in bytes
- *                        This can be 0 if unknown, but that will lead to
- *                        optimized functions not being used directly on the
- *                        input, which could slow down some conversions.
- * @param in_samples      number of input samples to convert
- * @return                number of samples written to the output buffer,
- *                        not including converted samples added to the internal
- *                        output FIFO
- */
-int avresample_convert(AVAudioResampleContext *avr, uint8_t **output,
-                       int out_plane_size, int out_samples, uint8_t **input,
-                       int in_plane_size, int in_samples);
-
-/**
- * Return the number of samples currently in the resampling delay buffer.
- *
- * When resampling, there may be a delay between the input and output. Any
- * unconverted samples in each call are stored internally in a delay buffer.
- * This function allows the user to determine the current number of samples in
- * the delay buffer, which can be useful for synchronization.
- *
- * @see avresample_convert()
- *
- * @param avr  audio resample context
- * @return     number of samples currently in the resampling delay buffer
- */
-int avresample_get_delay(AVAudioResampleContext *avr);
-
-/**
- * Return the number of available samples in the output FIFO.
- *
- * During conversion, if the user does not specify an output buffer or
- * specifies an output buffer that is smaller than what is needed, remaining
- * samples that are not written to the output are stored to an internal FIFO
- * buffer. The samples in the FIFO can be read with avresample_read() or
- * avresample_convert().
- *
- * @see avresample_read()
- * @see avresample_convert()
- *
- * @param avr  audio resample context
- * @return     number of samples available for reading
- */
-int avresample_available(AVAudioResampleContext *avr);
-
-/**
- * Read samples from the output FIFO.
- *
- * During conversion, if the user does not specify an output buffer or
- * specifies an output buffer that is smaller than what is needed, remaining
- * samples that are not written to the output are stored to an internal FIFO
- * buffer. This function can be used to read samples from that internal FIFO.
- *
- * @see avresample_available()
- * @see avresample_convert()
- *
- * @param avr         audio resample context
- * @param output      output data pointers. May be NULL, in which case
- *                    nb_samples of data is discarded from output FIFO.
- * @param nb_samples  number of samples to read from the FIFO
- * @return            the number of samples written to output
- */
-int avresample_read(AVAudioResampleContext *avr, uint8_t **output, int nb_samples);
-
-/**
- * @}
- */
-
-#endif /* AVRESAMPLE_AVRESAMPLE_H */
diff -pruN /usr/include/ffmpeg/libavresample/version.h csrc/libavresample/version.h
--- /usr/include/ffmpeg/libavresample/version.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libavresample/version.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVRESAMPLE_VERSION_H
-#define AVRESAMPLE_VERSION_H
-
-/**
- * @file
- * @ingroup lavr
- * Libavresample version macros.
- */
-
-#include "libavutil/version.h"
-
-#define LIBAVRESAMPLE_VERSION_MAJOR  1
-#define LIBAVRESAMPLE_VERSION_MINOR  3
-#define LIBAVRESAMPLE_VERSION_MICRO  0
-
-#define LIBAVRESAMPLE_VERSION_INT  AV_VERSION_INT(LIBAVRESAMPLE_VERSION_MAJOR, \
-                                                  LIBAVRESAMPLE_VERSION_MINOR, \
-                                                  LIBAVRESAMPLE_VERSION_MICRO)
-#define LIBAVRESAMPLE_VERSION          AV_VERSION(LIBAVRESAMPLE_VERSION_MAJOR, \
-                                                  LIBAVRESAMPLE_VERSION_MINOR, \
-                                                  LIBAVRESAMPLE_VERSION_MICRO)
-#define LIBAVRESAMPLE_BUILD        LIBAVRESAMPLE_VERSION_INT
-
-#define LIBAVRESAMPLE_IDENT        "Lavr" AV_STRINGIFY(LIBAVRESAMPLE_VERSION)
-
-/**
- * FF_API_* defines may be placed below to indicate public API that will be
- * dropped at a future version bump. The defines themselves are not part of
- * the public API and may change, break or disappear at any time.
- */
-
-#ifndef FF_API_RESAMPLE_CLOSE_OPEN
-#define FF_API_RESAMPLE_CLOSE_OPEN (LIBAVRESAMPLE_VERSION_MAJOR < 2)
-#endif
-
-#endif /* AVRESAMPLE_VERSION_H */
diff -pruN /usr/include/ffmpeg/libavutil/adler32.h csrc/libavutil/adler32.h
--- /usr/include/ffmpeg/libavutil/adler32.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/adler32.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/*
- * copyright (c) 2006 Mans Rullgard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_ADLER32_H
-#define AVUTIL_ADLER32_H
-
-#include <stdint.h>
-#include "attributes.h"
-
-/**
- * @file
- * Public header for libavutil Adler32 hasher
- *
- * @defgroup lavu_adler32 Adler32
- * @ingroup lavu_crypto
- * @{
- */
-
-/**
- * Calculate the Adler32 checksum of a buffer.
- *
- * Passing the return value to a subsequent av_adler32_update() call
- * allows the checksum of multiple buffers to be calculated as though
- * they were concatenated.
- *
- * @param adler initial checksum value
- * @param buf   pointer to input buffer
- * @param len   size of input buffer
- * @return      updated checksum
- */
-unsigned long av_adler32_update(unsigned long adler, const uint8_t *buf,
-                                unsigned int len) av_pure;
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_ADLER32_H */
diff -pruN /usr/include/ffmpeg/libavutil/aes.h csrc/libavutil/aes.h
--- /usr/include/ffmpeg/libavutil/aes.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/aes.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-/*
- * copyright (c) 2007 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_AES_H
-#define AVUTIL_AES_H
-
-#include <stdint.h>
-
-#include "attributes.h"
-#include "version.h"
-
-/**
- * @defgroup lavu_aes AES
- * @ingroup lavu_crypto
- * @{
- */
-
-extern const int av_aes_size;
-
-struct AVAES;
-
-/**
- * Allocate an AVAES context.
- */
-struct AVAES *av_aes_alloc(void);
-
-/**
- * Initialize an AVAES context.
- * @param key_bits 128, 192 or 256
- * @param decrypt 0 for encryption, 1 for decryption
- */
-int av_aes_init(struct AVAES *a, const uint8_t *key, int key_bits, int decrypt);
-
-/**
- * Encrypt or decrypt a buffer using a previously initialized context.
- * @param count number of 16 byte blocks
- * @param dst destination array, can be equal to src
- * @param src source array, can be equal to dst
- * @param iv initialization vector for CBC mode, if NULL then ECB will be used
- * @param decrypt 0 for encryption, 1 for decryption
- */
-void av_aes_crypt(struct AVAES *a, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_AES_H */
diff -pruN /usr/include/ffmpeg/libavutil/attributes.h csrc/libavutil/attributes.h
--- /usr/include/ffmpeg/libavutil/attributes.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/attributes.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,160 +0,0 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * Macro definitions for various function/variable attributes
- */
-
-#ifndef AVUTIL_ATTRIBUTES_H
-#define AVUTIL_ATTRIBUTES_H
-
-#ifdef __GNUC__
-#    define AV_GCC_VERSION_AT_LEAST(x,y) (__GNUC__ > x || __GNUC__ == x && __GNUC_MINOR__ >= y)
-#else
-#    define AV_GCC_VERSION_AT_LEAST(x,y) 0
-#endif
-
-#ifndef av_always_inline
-#if AV_GCC_VERSION_AT_LEAST(3,1)
-#    define av_always_inline __attribute__((always_inline)) inline
-#elif defined(_MSC_VER)
-#    define av_always_inline __forceinline
-#else
-#    define av_always_inline inline
-#endif
-#endif
-
-#ifndef av_extern_inline
-#if defined(__ICL) && __ICL >= 1210 || defined(__GNUC_STDC_INLINE__)
-#    define av_extern_inline extern inline
-#else
-#    define av_extern_inline inline
-#endif
-#endif
-
-#if AV_GCC_VERSION_AT_LEAST(3,1)
-#    define av_noinline __attribute__((noinline))
-#elif defined(_MSC_VER)
-#    define av_noinline __declspec(noinline)
-#else
-#    define av_noinline
-#endif
-
-#if AV_GCC_VERSION_AT_LEAST(3,1)
-#    define av_pure __attribute__((pure))
-#else
-#    define av_pure
-#endif
-
-#if AV_GCC_VERSION_AT_LEAST(2,6)
-#    define av_const __attribute__((const))
-#else
-#    define av_const
-#endif
-
-#if AV_GCC_VERSION_AT_LEAST(4,3)
-#    define av_cold __attribute__((cold))
-#else
-#    define av_cold
-#endif
-
-#if AV_GCC_VERSION_AT_LEAST(4,1) && !defined(__llvm__)
-#    define av_flatten __attribute__((flatten))
-#else
-#    define av_flatten
-#endif
-
-#if AV_GCC_VERSION_AT_LEAST(3,1)
-#    define attribute_deprecated __attribute__((deprecated))
-#elif defined(_MSC_VER)
-#    define attribute_deprecated __declspec(deprecated)
-#else
-#    define attribute_deprecated
-#endif
-
-/**
- * Disable warnings about deprecated features
- * This is useful for sections of code kept for backward compatibility and
- * scheduled for removal.
- */
-#ifndef AV_NOWARN_DEPRECATED
-#if AV_GCC_VERSION_AT_LEAST(4,6)
-#    define AV_NOWARN_DEPRECATED(code) \
-        _Pragma("GCC diagnostic push") \
-        _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"") \
-        code \
-        _Pragma("GCC diagnostic pop")
-#elif defined(_MSC_VER)
-#    define AV_NOWARN_DEPRECATED(code) \
-        __pragma(warning(push)) \
-        __pragma(warning(disable : 4996)) \
-        code; \
-        __pragma(warning(pop))
-#else
-#    define AV_NOWARN_DEPRECATED(code) code
-#endif
-#endif
-
-
-#if defined(__GNUC__)
-#    define av_unused __attribute__((unused))
-#else
-#    define av_unused
-#endif
-
-/**
- * Mark a variable as used and prevent the compiler from optimizing it
- * away.  This is useful for variables accessed only from inline
- * assembler without the compiler being aware.
- */
-#if AV_GCC_VERSION_AT_LEAST(3,1)
-#    define av_used __attribute__((used))
-#else
-#    define av_used
-#endif
-
-#if AV_GCC_VERSION_AT_LEAST(3,3)
-#   define av_alias __attribute__((may_alias))
-#else
-#   define av_alias
-#endif
-
-#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && !defined(__clang__)
-#    define av_uninit(x) x=x
-#else
-#    define av_uninit(x) x
-#endif
-
-#ifdef __GNUC__
-#    define av_builtin_constant_p __builtin_constant_p
-#    define av_printf_format(fmtpos, attrpos) __attribute__((__format__(__printf__, fmtpos, attrpos)))
-#else
-#    define av_builtin_constant_p(x) 0
-#    define av_printf_format(fmtpos, attrpos)
-#endif
-
-#if AV_GCC_VERSION_AT_LEAST(2,5)
-#    define av_noreturn __attribute__((noreturn))
-#else
-#    define av_noreturn
-#endif
-
-#endif /* AVUTIL_ATTRIBUTES_H */
diff -pruN /usr/include/ffmpeg/libavutil/audioconvert.h csrc/libavutil/audioconvert.h
--- /usr/include/ffmpeg/libavutil/audioconvert.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/audioconvert.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-
-#include "version.h"
-
-#if FF_API_AUDIOCONVERT
-#include "channel_layout.h"
-#endif
diff -pruN /usr/include/ffmpeg/libavutil/audio_fifo.h csrc/libavutil/audio_fifo.h
--- /usr/include/ffmpeg/libavutil/audio_fifo.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/audio_fifo.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,153 +0,0 @@
-/*
- * Audio FIFO
- * Copyright (c) 2012 Justin Ruggles <justin.ruggles@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * Audio FIFO Buffer
- */
-
-#ifndef AVUTIL_AUDIO_FIFO_H
-#define AVUTIL_AUDIO_FIFO_H
-
-#include "avutil.h"
-#include "fifo.h"
-#include "samplefmt.h"
-
-/**
- * @addtogroup lavu_audio
- * @{
- *
- * @defgroup lavu_audiofifo Audio FIFO Buffer
- * @{
- */
-
-/**
- * Context for an Audio FIFO Buffer.
- *
- * - Operates at the sample level rather than the byte level.
- * - Supports multiple channels with either planar or packed sample format.
- * - Automatic reallocation when writing to a full buffer.
- */
-typedef struct AVAudioFifo AVAudioFifo;
-
-/**
- * Free an AVAudioFifo.
- *
- * @param af  AVAudioFifo to free
- */
-void av_audio_fifo_free(AVAudioFifo *af);
-
-/**
- * Allocate an AVAudioFifo.
- *
- * @param sample_fmt  sample format
- * @param channels    number of channels
- * @param nb_samples  initial allocation size, in samples
- * @return            newly allocated AVAudioFifo, or NULL on error
- */
-AVAudioFifo *av_audio_fifo_alloc(enum AVSampleFormat sample_fmt, int channels,
-                                 int nb_samples);
-
-/**
- * Reallocate an AVAudioFifo.
- *
- * @param af          AVAudioFifo to reallocate
- * @param nb_samples  new allocation size, in samples
- * @return            0 if OK, or negative AVERROR code on failure
- */
-int av_audio_fifo_realloc(AVAudioFifo *af, int nb_samples);
-
-/**
- * Write data to an AVAudioFifo.
- *
- * The AVAudioFifo will be reallocated automatically if the available space
- * is less than nb_samples.
- *
- * @see enum AVSampleFormat
- * The documentation for AVSampleFormat describes the data layout.
- *
- * @param af          AVAudioFifo to write to
- * @param data        audio data plane pointers
- * @param nb_samples  number of samples to write
- * @return            number of samples actually written, or negative AVERROR
- *                    code on failure. If successful, the number of samples
- *                    actually written will always be nb_samples.
- */
-int av_audio_fifo_write(AVAudioFifo *af, void **data, int nb_samples);
-
-/**
- * Read data from an AVAudioFifo.
- *
- * @see enum AVSampleFormat
- * The documentation for AVSampleFormat describes the data layout.
- *
- * @param af          AVAudioFifo to read from
- * @param data        audio data plane pointers
- * @param nb_samples  number of samples to read
- * @return            number of samples actually read, or negative AVERROR code
- *                    on failure. The number of samples actually read will not
- *                    be greater than nb_samples, and will only be less than
- *                    nb_samples if av_audio_fifo_size is less than nb_samples.
- */
-int av_audio_fifo_read(AVAudioFifo *af, void **data, int nb_samples);
-
-/**
- * Drain data from an AVAudioFifo.
- *
- * Removes the data without reading it.
- *
- * @param af          AVAudioFifo to drain
- * @param nb_samples  number of samples to drain
- * @return            0 if OK, or negative AVERROR code on failure
- */
-int av_audio_fifo_drain(AVAudioFifo *af, int nb_samples);
-
-/**
- * Reset the AVAudioFifo buffer.
- *
- * This empties all data in the buffer.
- *
- * @param af  AVAudioFifo to reset
- */
-void av_audio_fifo_reset(AVAudioFifo *af);
-
-/**
- * Get the current number of samples in the AVAudioFifo available for reading.
- *
- * @param af  the AVAudioFifo to query
- * @return    number of samples available for reading
- */
-int av_audio_fifo_size(AVAudioFifo *af);
-
-/**
- * Get the current number of samples in the AVAudioFifo available for writing.
- *
- * @param af  the AVAudioFifo to query
- * @return    number of samples available for writing
- */
-int av_audio_fifo_space(AVAudioFifo *af);
-
-/**
- * @}
- * @}
- */
-
-#endif /* AVUTIL_AUDIO_FIFO_H */
diff -pruN /usr/include/ffmpeg/libavutil/avassert.h csrc/libavutil/avassert.h
--- /usr/include/ffmpeg/libavutil/avassert.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/avassert.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-/*
- * copyright (c) 2010 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * simple assert() macros that are a bit more flexible than ISO C assert().
- * @author Michael Niedermayer <michaelni@gmx.at>
- */
-
-#ifndef AVUTIL_AVASSERT_H
-#define AVUTIL_AVASSERT_H
-
-#include <stdlib.h>
-#include "avutil.h"
-#include "log.h"
-
-/**
- * assert() equivalent, that is always enabled.
- */
-#define av_assert0(cond) do {                                           \
-    if (!(cond)) {                                                      \
-        av_log(NULL, AV_LOG_PANIC, "Assertion %s failed at %s:%d\n",    \
-               AV_STRINGIFY(cond), __FILE__, __LINE__);                 \
-        abort();                                                        \
-    }                                                                   \
-} while (0)
-
-
-/**
- * assert() equivalent, that does not lie in speed critical code.
- * These asserts() thus can be enabled without fearing speedloss.
- */
-#if defined(ASSERT_LEVEL) && ASSERT_LEVEL > 0
-#define av_assert1(cond) av_assert0(cond)
-#else
-#define av_assert1(cond) ((void)0)
-#endif
-
-
-/**
- * assert() equivalent, that does lie in speed critical code.
- */
-#if defined(ASSERT_LEVEL) && ASSERT_LEVEL > 1
-#define av_assert2(cond) av_assert0(cond)
-#else
-#define av_assert2(cond) ((void)0)
-#endif
-
-#endif /* AVUTIL_AVASSERT_H */
diff -pruN /usr/include/ffmpeg/libavutil/avconfig.h csrc/libavutil/avconfig.h
--- /usr/include/ffmpeg/libavutil/avconfig.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/avconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,7 +0,0 @@
-/* Generated by ffconf */
-#ifndef AVUTIL_AVCONFIG_H
-#define AVUTIL_AVCONFIG_H
-#define AV_HAVE_BIGENDIAN 0
-#define AV_HAVE_FAST_UNALIGNED 1
-#define AV_HAVE_INCOMPATIBLE_LIBAV_ABI 0
-#endif /* AVUTIL_AVCONFIG_H */
diff -pruN /usr/include/ffmpeg/libavutil/avstring.h csrc/libavutil/avstring.h
--- /usr/include/ffmpeg/libavutil/avstring.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/avstring.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,356 +0,0 @@
-/*
- * Copyright (c) 2007 Mans Rullgard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_AVSTRING_H
-#define AVUTIL_AVSTRING_H
-
-#include <stddef.h>
-#include <stdint.h>
-#include "attributes.h"
-
-/**
- * @addtogroup lavu_string
- * @{
- */
-
-/**
- * Return non-zero if pfx is a prefix of str. If it is, *ptr is set to
- * the address of the first character in str after the prefix.
- *
- * @param str input string
- * @param pfx prefix to test
- * @param ptr updated if the prefix is matched inside str
- * @return non-zero if the prefix matches, zero otherwise
- */
-int av_strstart(const char *str, const char *pfx, const char **ptr);
-
-/**
- * Return non-zero if pfx is a prefix of str independent of case. If
- * it is, *ptr is set to the address of the first character in str
- * after the prefix.
- *
- * @param str input string
- * @param pfx prefix to test
- * @param ptr updated if the prefix is matched inside str
- * @return non-zero if the prefix matches, zero otherwise
- */
-int av_stristart(const char *str, const char *pfx, const char **ptr);
-
-/**
- * Locate the first case-independent occurrence in the string haystack
- * of the string needle.  A zero-length string needle is considered to
- * match at the start of haystack.
- *
- * This function is a case-insensitive version of the standard strstr().
- *
- * @param haystack string to search in
- * @param needle   string to search for
- * @return         pointer to the located match within haystack
- *                 or a null pointer if no match
- */
-char *av_stristr(const char *haystack, const char *needle);
-
-/**
- * Locate the first occurrence of the string needle in the string haystack
- * where not more than hay_length characters are searched. A zero-length
- * string needle is considered to match at the start of haystack.
- *
- * This function is a length-limited version of the standard strstr().
- *
- * @param haystack   string to search in
- * @param needle     string to search for
- * @param hay_length length of string to search in
- * @return           pointer to the located match within haystack
- *                   or a null pointer if no match
- */
-char *av_strnstr(const char *haystack, const char *needle, size_t hay_length);
-
-/**
- * Copy the string src to dst, but no more than size - 1 bytes, and
- * null-terminate dst.
- *
- * This function is the same as BSD strlcpy().
- *
- * @param dst destination buffer
- * @param src source string
- * @param size size of destination buffer
- * @return the length of src
- *
- * @warning since the return value is the length of src, src absolutely
- * _must_ be a properly 0-terminated string, otherwise this will read beyond
- * the end of the buffer and possibly crash.
- */
-size_t av_strlcpy(char *dst, const char *src, size_t size);
-
-/**
- * Append the string src to the string dst, but to a total length of
- * no more than size - 1 bytes, and null-terminate dst.
- *
- * This function is similar to BSD strlcat(), but differs when
- * size <= strlen(dst).
- *
- * @param dst destination buffer
- * @param src source string
- * @param size size of destination buffer
- * @return the total length of src and dst
- *
- * @warning since the return value use the length of src and dst, these
- * absolutely _must_ be a properly 0-terminated strings, otherwise this
- * will read beyond the end of the buffer and possibly crash.
- */
-size_t av_strlcat(char *dst, const char *src, size_t size);
-
-/**
- * Append output to a string, according to a format. Never write out of
- * the destination buffer, and always put a terminating 0 within
- * the buffer.
- * @param dst destination buffer (string to which the output is
- *  appended)
- * @param size total size of the destination buffer
- * @param fmt printf-compatible format string, specifying how the
- *  following parameters are used
- * @return the length of the string that would have been generated
- *  if enough space had been available
- */
-size_t av_strlcatf(char *dst, size_t size, const char *fmt, ...) av_printf_format(3, 4);
-
-/**
- * Get the count of continuous non zero chars starting from the beginning.
- *
- * @param len maximum number of characters to check in the string, that
- *            is the maximum value which is returned by the function
- */
-static inline size_t av_strnlen(const char *s, size_t len)
-{
-    size_t i;
-    for (i = 0; i < len && s[i]; i++)
-        ;
-    return i;
-}
-
-/**
- * Print arguments following specified format into a large enough auto
- * allocated buffer. It is similar to GNU asprintf().
- * @param fmt printf-compatible format string, specifying how the
- *            following parameters are used.
- * @return the allocated string
- * @note You have to free the string yourself with av_free().
- */
-char *av_asprintf(const char *fmt, ...) av_printf_format(1, 2);
-
-/**
- * Convert a number to a av_malloced string.
- */
-char *av_d2str(double d);
-
-/**
- * Unescape the given string until a non escaped terminating char,
- * and return the token corresponding to the unescaped string.
- *
- * The normal \ and ' escaping is supported. Leading and trailing
- * whitespaces are removed, unless they are escaped with '\' or are
- * enclosed between ''.
- *
- * @param buf the buffer to parse, buf will be updated to point to the
- * terminating char
- * @param term a 0-terminated list of terminating chars
- * @return the malloced unescaped string, which must be av_freed by
- * the user, NULL in case of allocation failure
- */
-char *av_get_token(const char **buf, const char *term);
-
-/**
- * Split the string into several tokens which can be accessed by
- * successive calls to av_strtok().
- *
- * A token is defined as a sequence of characters not belonging to the
- * set specified in delim.
- *
- * On the first call to av_strtok(), s should point to the string to
- * parse, and the value of saveptr is ignored. In subsequent calls, s
- * should be NULL, and saveptr should be unchanged since the previous
- * call.
- *
- * This function is similar to strtok_r() defined in POSIX.1.
- *
- * @param s the string to parse, may be NULL
- * @param delim 0-terminated list of token delimiters, must be non-NULL
- * @param saveptr user-provided pointer which points to stored
- * information necessary for av_strtok() to continue scanning the same
- * string. saveptr is updated to point to the next character after the
- * first delimiter found, or to NULL if the string was terminated
- * @return the found token, or NULL when no token is found
- */
-char *av_strtok(char *s, const char *delim, char **saveptr);
-
-/**
- * Locale-independent conversion of ASCII isdigit.
- */
-int av_isdigit(int c);
-
-/**
- * Locale-independent conversion of ASCII isgraph.
- */
-int av_isgraph(int c);
-
-/**
- * Locale-independent conversion of ASCII isspace.
- */
-int av_isspace(int c);
-
-/**
- * Locale-independent conversion of ASCII characters to uppercase.
- */
-static inline int av_toupper(int c)
-{
-    if (c >= 'a' && c <= 'z')
-        c ^= 0x20;
-    return c;
-}
-
-/**
- * Locale-independent conversion of ASCII characters to lowercase.
- */
-static inline int av_tolower(int c)
-{
-    if (c >= 'A' && c <= 'Z')
-        c ^= 0x20;
-    return c;
-}
-
-/**
- * Locale-independent conversion of ASCII isxdigit.
- */
-int av_isxdigit(int c);
-
-/**
- * Locale-independent case-insensitive compare.
- * @note This means only ASCII-range characters are case-insensitive
- */
-int av_strcasecmp(const char *a, const char *b);
-
-/**
- * Locale-independent case-insensitive compare.
- * @note This means only ASCII-range characters are case-insensitive
- */
-int av_strncasecmp(const char *a, const char *b, size_t n);
-
-
-/**
- * Thread safe basename.
- * @param path the path, on DOS both \ and / are considered separators.
- * @return pointer to the basename substring.
- */
-const char *av_basename(const char *path);
-
-/**
- * Thread safe dirname.
- * @param path the path, on DOS both \ and / are considered separators.
- * @return the path with the separator replaced by the string terminator or ".".
- * @note the function may change the input string.
- */
-const char *av_dirname(char *path);
-
-enum AVEscapeMode {
-    AV_ESCAPE_MODE_AUTO,      ///< Use auto-selected escaping mode.
-    AV_ESCAPE_MODE_BACKSLASH, ///< Use backslash escaping.
-    AV_ESCAPE_MODE_QUOTE,     ///< Use single-quote escaping.
-};
-
-/**
- * Consider spaces special and escape them even in the middle of the
- * string.
- *
- * This is equivalent to adding the whitespace characters to the special
- * characters lists, except it is guaranteed to use the exact same list
- * of whitespace characters as the rest of libavutil.
- */
-#define AV_ESCAPE_FLAG_WHITESPACE 0x01
-
-/**
- * Escape only specified special characters.
- * Without this flag, escape also any characters that may be considered
- * special by av_get_token(), such as the single quote.
- */
-#define AV_ESCAPE_FLAG_STRICT 0x02
-
-/**
- * Escape string in src, and put the escaped string in an allocated
- * string in *dst, which must be freed with av_free().
- *
- * @param dst           pointer where an allocated string is put
- * @param src           string to escape, must be non-NULL
- * @param special_chars string containing the special characters which
- *                      need to be escaped, can be NULL
- * @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.
- *                      Any unknown value for mode will be considered equivalent to
- *                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without
- *                      notice.
- * @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros
- * @return the length of the allocated string, or a negative error code in case of error
- * @see av_bprint_escape()
- */
-int av_escape(char **dst, const char *src, const char *special_chars,
-              enum AVEscapeMode mode, int flags);
-
-#define AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES          1 ///< accept codepoints over 0x10FFFF
-#define AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS             2 ///< accept non-characters - 0xFFFE and 0xFFFF
-#define AV_UTF8_FLAG_ACCEPT_SURROGATES                 4 ///< accept UTF-16 surrogates codes
-#define AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES 8 ///< exclude control codes not accepted by XML
-
-#define AV_UTF8_FLAG_ACCEPT_ALL \
-    AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES|AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS|AV_UTF8_FLAG_ACCEPT_SURROGATES
-
-/**
- * Read and decode a single UTF-8 code point (character) from the
- * buffer in *buf, and update *buf to point to the next byte to
- * decode.
- *
- * In case of an invalid byte sequence, the pointer will be updated to
- * the next byte after the invalid sequence and the function will
- * return an error code.
- *
- * Depending on the specified flags, the function will also fail in
- * case the decoded code point does not belong to a valid range.
- *
- * @note For speed-relevant code a carefully implemented use of
- * GET_UTF8() may be preferred.
- *
- * @param codep   pointer used to return the parsed code in case of success.
- *                The value in *codep is set even in case the range check fails.
- * @param bufp    pointer to the address the first byte of the sequence
- *                to decode, updated by the function to point to the
- *                byte next after the decoded sequence
- * @param buf_end pointer to the end of the buffer, points to the next
- *                byte past the last in the buffer. This is used to
- *                avoid buffer overreads (in case of an unfinished
- *                UTF-8 sequence towards the end of the buffer).
- * @param flags   a collection of AV_UTF8_FLAG_* flags
- * @return >= 0 in case a sequence was successfully read, a negative
- * value in case of invalid sequence
- */
-int av_utf8_decode(int32_t *codep, const uint8_t **bufp, const uint8_t *buf_end,
-                   unsigned int flags);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_AVSTRING_H */
diff -pruN /usr/include/ffmpeg/libavutil/avutil.h csrc/libavutil/avutil.h
--- /usr/include/ffmpeg/libavutil/avutil.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/avutil.h	2014-10-20 12:19:07.721499510 +0200
@@ -199,69 +199,8 @@ enum AVMediaType {
     AVMEDIA_TYPE_NB
 };
 
-/**
- * Return a string describing the media_type enum, NULL if media_type
- * is unknown.
- */
 const char *av_get_media_type_string(enum AVMediaType media_type);
 
-/**
- * @defgroup lavu_const Constants
- * @{
- *
- * @defgroup lavu_enc Encoding specific
- *
- * @note those definition should move to avcodec
- * @{
- */
-
-#define FF_LAMBDA_SHIFT 7
-#define FF_LAMBDA_SCALE (1<<FF_LAMBDA_SHIFT)
-#define FF_QP2LAMBDA 118 ///< factor to convert from H.263 QP to lambda
-#define FF_LAMBDA_MAX (256*128-1)
-
-#define FF_QUALITY_SCALE FF_LAMBDA_SCALE //FIXME maybe remove
-
-/**
- * @}
- * @defgroup lavu_time Timestamp specific
- *
- * FFmpeg internal timebase and timestamp definitions
- *
- * @{
- */
-
-/**
- * @brief Undefined timestamp value
- *
- * Usually reported by demuxer that work on containers that do not provide
- * either pts or dts.
- */
-
-#define AV_NOPTS_VALUE          ((int64_t)UINT64_C(0x8000000000000000))
-
-/**
- * Internal time base represented as integer
- */
-
-#define AV_TIME_BASE            1000000
-
-/**
- * Internal time base represented as fractional value
- */
-
-#define AV_TIME_BASE_Q          (AVRational){1, AV_TIME_BASE}
-
-/**
- * @}
- * @}
- * @defgroup lavu_picture Image related
- *
- * AVPicture types, pixel formats and basic image planes manipulation.
- *
- * @{
- */
-
 enum AVPictureType {
     AV_PICTURE_TYPE_NONE = 0, ///< Undefined
     AV_PICTURE_TYPE_I,     ///< Intra
@@ -273,72 +212,4 @@ enum AVPictureType {
     AV_PICTURE_TYPE_BI,    ///< BI type
 };
 
-/**
- * Return a single letter to describe the given picture type
- * pict_type.
- *
- * @param[in] pict_type the picture type @return a single character
- * representing the picture type, '?' if pict_type is unknown
- */
-char av_get_picture_type_char(enum AVPictureType pict_type);
-
-/**
- * @}
- */
-
-#include "common.h"
-#include "error.h"
-#include "rational.h"
-#include "version.h"
-#include "macros.h"
-#include "mathematics.h"
-#include "log.h"
-#include "pixfmt.h"
-
-/**
- * Return x default pointer in case p is NULL.
- */
-static inline void *av_x_if_null(const void *p, const void *x)
-{
-    return (void *)(intptr_t)(p ? p : x);
-}
-
-/**
- * Compute the length of an integer list.
- *
- * @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)
- * @param term    list terminator (usually 0 or -1)
- * @param list    pointer to the list
- * @return  length of the list, in elements, not counting the terminator
- */
-unsigned av_int_list_length_for_size(unsigned elsize,
-                                     const void *list, uint64_t term) av_pure;
-
-/**
- * Compute the length of an integer list.
- *
- * @param term  list terminator (usually 0 or -1)
- * @param list  pointer to the list
- * @return  length of the list, in elements, not counting the terminator
- */
-#define av_int_list_length(list, term) \
-    av_int_list_length_for_size(sizeof(*(list)), list, term)
-
-/**
- * Open a file using a UTF-8 filename.
- * The API of this function matches POSIX fopen(), errors are returned through
- * errno.
- */
-FILE *av_fopen_utf8(const char *path, const char *mode);
-
-/**
- * Return the fractional representation of the internal time base.
- */
-AVRational av_get_time_base_q(void);
-
-/**
- * @}
- * @}
- */
-
 #endif /* AVUTIL_AVUTIL_H */
diff -pruN /usr/include/ffmpeg/libavutil/base64.h csrc/libavutil/base64.h
--- /usr/include/ffmpeg/libavutil/base64.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/base64.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-/*
- * Copyright (c) 2006 Ryan Martell. (rdm4@martellventures.com)
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_BASE64_H
-#define AVUTIL_BASE64_H
-
-#include <stdint.h>
-
-/**
- * @defgroup lavu_base64 Base64
- * @ingroup lavu_crypto
- * @{
- */
-
-
-/**
- * Decode a base64-encoded string.
- *
- * @param out      buffer for decoded data
- * @param in       null-terminated input string
- * @param out_size size in bytes of the out buffer, must be at
- *                 least 3/4 of the length of in
- * @return         number of bytes written, or a negative value in case of
- *                 invalid input
- */
-int av_base64_decode(uint8_t *out, const char *in, int out_size);
-
-/**
- * Encode data to base64 and null-terminate.
- *
- * @param out      buffer for encoded data
- * @param out_size size in bytes of the out buffer (including the
- *                 null terminator), must be at least AV_BASE64_SIZE(in_size)
- * @param in       input buffer containing the data to encode
- * @param in_size  size in bytes of the in buffer
- * @return         out or NULL in case of error
- */
-char *av_base64_encode(char *out, int out_size, const uint8_t *in, int in_size);
-
-/**
- * Calculate the output size needed to base64-encode x bytes to a
- * null-terminated string.
- */
-#define AV_BASE64_SIZE(x)  (((x)+2) / 3 * 4 + 1)
-
- /**
-  * @}
-  */
-
-#endif /* AVUTIL_BASE64_H */
diff -pruN /usr/include/ffmpeg/libavutil/blowfish.h csrc/libavutil/blowfish.h
--- /usr/include/ffmpeg/libavutil/blowfish.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/blowfish.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/*
- * Blowfish algorithm
- * Copyright (c) 2012 Samuel Pitoiset
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_BLOWFISH_H
-#define AVUTIL_BLOWFISH_H
-
-#include <stdint.h>
-
-/**
- * @defgroup lavu_blowfish Blowfish
- * @ingroup lavu_crypto
- * @{
- */
-
-#define AV_BF_ROUNDS 16
-
-typedef struct AVBlowfish {
-    uint32_t p[AV_BF_ROUNDS + 2];
-    uint32_t s[4][256];
-} AVBlowfish;
-
-/**
- * Initialize an AVBlowfish context.
- *
- * @param ctx an AVBlowfish context
- * @param key a key
- * @param key_len length of the key
- */
-void av_blowfish_init(struct AVBlowfish *ctx, const uint8_t *key, int key_len);
-
-/**
- * Encrypt or decrypt a buffer using a previously initialized context.
- *
- * @param ctx an AVBlowfish context
- * @param xl left four bytes halves of input to be encrypted
- * @param xr right four bytes halves of input to be encrypted
- * @param decrypt 0 for encryption, 1 for decryption
- */
-void av_blowfish_crypt_ecb(struct AVBlowfish *ctx, uint32_t *xl, uint32_t *xr,
-                           int decrypt);
-
-/**
- * Encrypt or decrypt a buffer using a previously initialized context.
- *
- * @param ctx an AVBlowfish context
- * @param dst destination array, can be equal to src
- * @param src source array, can be equal to dst
- * @param count number of 8 byte blocks
- * @param iv initialization vector for CBC mode, if NULL ECB will be used
- * @param decrypt 0 for encryption, 1 for decryption
- */
-void av_blowfish_crypt(struct AVBlowfish *ctx, uint8_t *dst, const uint8_t *src,
-                       int count, uint8_t *iv, int decrypt);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_BLOWFISH_H */
diff -pruN /usr/include/ffmpeg/libavutil/bprint.h csrc/libavutil/bprint.h
--- /usr/include/ffmpeg/libavutil/bprint.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/bprint.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,216 +0,0 @@
-/*
- * Copyright (c) 2012 Nicolas George
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_BPRINT_H
-#define AVUTIL_BPRINT_H
-
-#include <stdarg.h>
-
-#include "attributes.h"
-#include "avstring.h"
-
-/**
- * Define a structure with extra padding to a fixed size
- * This helps ensuring binary compatibility with future versions.
- */
-#define FF_PAD_STRUCTURE(size, ...) \
-    __VA_ARGS__ \
-    char reserved_padding[size - sizeof(struct { __VA_ARGS__ })];
-
-/**
- * Buffer to print data progressively
- *
- * The string buffer grows as necessary and is always 0-terminated.
- * The content of the string is never accessed, and thus is
- * encoding-agnostic and can even hold binary data.
- *
- * Small buffers are kept in the structure itself, and thus require no
- * memory allocation at all (unless the contents of the buffer is needed
- * after the structure goes out of scope). This is almost as lightweight as
- * declaring a local "char buf[512]".
- *
- * The length of the string can go beyond the allocated size: the buffer is
- * then truncated, but the functions still keep account of the actual total
- * length.
- *
- * In other words, buf->len can be greater than buf->size and records the
- * total length of what would have been to the buffer if there had been
- * enough memory.
- *
- * Append operations do not need to be tested for failure: if a memory
- * allocation fails, data stop being appended to the buffer, but the length
- * is still updated. This situation can be tested with
- * av_bprint_is_complete().
- *
- * The size_max field determines several possible behaviours:
- *
- * size_max = -1 (= UINT_MAX) or any large value will let the buffer be
- * reallocated as necessary, with an amortized linear cost.
- *
- * size_max = 0 prevents writing anything to the buffer: only the total
- * length is computed. The write operations can then possibly be repeated in
- * a buffer with exactly the necessary size
- * (using size_init = size_max = len + 1).
- *
- * size_max = 1 is automatically replaced by the exact size available in the
- * structure itself, thus ensuring no dynamic memory allocation. The
- * internal buffer is large enough to hold a reasonable paragraph of text,
- * such as the current paragraph.
- */
-typedef struct AVBPrint {
-    FF_PAD_STRUCTURE(1024,
-    char *str;         /**< string so far */
-    unsigned len;      /**< length so far */
-    unsigned size;     /**< allocated memory */
-    unsigned size_max; /**< maximum allocated memory */
-    char reserved_internal_buffer[1];
-    )
-} AVBPrint;
-
-/**
- * Convenience macros for special values for av_bprint_init() size_max
- * parameter.
- */
-#define AV_BPRINT_SIZE_UNLIMITED  ((unsigned)-1)
-#define AV_BPRINT_SIZE_AUTOMATIC  1
-#define AV_BPRINT_SIZE_COUNT_ONLY 0
-
-/**
- * Init a print buffer.
- *
- * @param buf        buffer to init
- * @param size_init  initial size (including the final 0)
- * @param size_max   maximum size;
- *                   0 means do not write anything, just count the length;
- *                   1 is replaced by the maximum value for automatic storage;
- *                   any large value means that the internal buffer will be
- *                   reallocated as needed up to that limit; -1 is converted to
- *                   UINT_MAX, the largest limit possible.
- *                   Check also AV_BPRINT_SIZE_* macros.
- */
-void av_bprint_init(AVBPrint *buf, unsigned size_init, unsigned size_max);
-
-/**
- * Init a print buffer using a pre-existing buffer.
- *
- * The buffer will not be reallocated.
- *
- * @param buf     buffer structure to init
- * @param buffer  byte buffer to use for the string data
- * @param size    size of buffer
- */
-void av_bprint_init_for_buffer(AVBPrint *buf, char *buffer, unsigned size);
-
-/**
- * Append a formatted string to a print buffer.
- */
-void av_bprintf(AVBPrint *buf, const char *fmt, ...) av_printf_format(2, 3);
-
-/**
- * Append a formatted string to a print buffer.
- */
-void av_vbprintf(AVBPrint *buf, const char *fmt, va_list vl_arg);
-
-/**
- * Append char c n times to a print buffer.
- */
-void av_bprint_chars(AVBPrint *buf, char c, unsigned n);
-
-/**
- * Append data to a print buffer.
- *
- * param buf  bprint buffer to use
- * param data pointer to data
- * param size size of data
- */
-void av_bprint_append_data(AVBPrint *buf, const char *data, unsigned size);
-
-struct tm;
-/**
- * Append a formatted date and time to a print buffer.
- *
- * param buf  bprint buffer to use
- * param fmt  date and time format string, see strftime()
- * param tm   broken-down time structure to translate
- *
- * @note due to poor design of the standard strftime function, it may
- * produce poor results if the format string expands to a very long text and
- * the bprint buffer is near the limit stated by the size_max option.
- */
-void av_bprint_strftime(AVBPrint *buf, const char *fmt, const struct tm *tm);
-
-/**
- * Allocate bytes in the buffer for external use.
- *
- * @param[in]  buf          buffer structure
- * @param[in]  size         required size
- * @param[out] mem          pointer to the memory area
- * @param[out] actual_size  size of the memory area after allocation;
- *                          can be larger or smaller than size
- */
-void av_bprint_get_buffer(AVBPrint *buf, unsigned size,
-                          unsigned char **mem, unsigned *actual_size);
-
-/**
- * Reset the string to "" but keep internal allocated data.
- */
-void av_bprint_clear(AVBPrint *buf);
-
-/**
- * Test if the print buffer is complete (not truncated).
- *
- * It may have been truncated due to a memory allocation failure
- * or the size_max limit (compare size and size_max if necessary).
- */
-static inline int av_bprint_is_complete(AVBPrint *buf)
-{
-    return buf->len < buf->size;
-}
-
-/**
- * Finalize a print buffer.
- *
- * The print buffer can no longer be used afterwards,
- * but the len and size fields are still valid.
- *
- * @arg[out] ret_str  if not NULL, used to return a permanent copy of the
- *                    buffer contents, or NULL if memory allocation fails;
- *                    if NULL, the buffer is discarded and freed
- * @return  0 for success or error code (probably AVERROR(ENOMEM))
- */
-int av_bprint_finalize(AVBPrint *buf, char **ret_str);
-
-/**
- * Escape the content in src and append it to dstbuf.
- *
- * @param dstbuf        already inited destination bprint buffer
- * @param src           string containing the text to escape
- * @param special_chars string containing the special characters which
- *                      need to be escaped, can be NULL
- * @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.
- *                      Any unknown value for mode will be considered equivalent to
- *                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without
- *                      notice.
- * @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros
- */
-void av_bprint_escape(AVBPrint *dstbuf, const char *src, const char *special_chars,
-                      enum AVEscapeMode mode, int flags);
-
-#endif /* AVUTIL_BPRINT_H */
diff -pruN /usr/include/ffmpeg/libavutil/bswap.h csrc/libavutil/bswap.h
--- /usr/include/ffmpeg/libavutil/bswap.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/bswap.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,111 +0,0 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * byte swapping routines
- */
-
-#ifndef AVUTIL_BSWAP_H
-#define AVUTIL_BSWAP_H
-
-#include <stdint.h>
-#include "libavutil/avconfig.h"
-#include "attributes.h"
-
-#ifdef HAVE_AV_CONFIG_H
-
-#include "config.h"
-
-#if   ARCH_AARCH64
-#   include "aarch64/bswap.h"
-#elif ARCH_ARM
-#   include "arm/bswap.h"
-#elif ARCH_AVR32
-#   include "avr32/bswap.h"
-#elif ARCH_BFIN
-#   include "bfin/bswap.h"
-#elif ARCH_SH4
-#   include "sh4/bswap.h"
-#elif ARCH_X86
-#   include "x86/bswap.h"
-#endif
-
-#endif /* HAVE_AV_CONFIG_H */
-
-#define AV_BSWAP16C(x) (((x) << 8 & 0xff00)  | ((x) >> 8 & 0x00ff))
-#define AV_BSWAP32C(x) (AV_BSWAP16C(x) << 16 | AV_BSWAP16C((x) >> 16))
-#define AV_BSWAP64C(x) (AV_BSWAP32C(x) << 32 | AV_BSWAP32C((x) >> 32))
-
-#define AV_BSWAPC(s, x) AV_BSWAP##s##C(x)
-
-#ifndef av_bswap16
-static av_always_inline av_const uint16_t av_bswap16(uint16_t x)
-{
-    x= (x>>8) | (x<<8);
-    return x;
-}
-#endif
-
-#ifndef av_bswap32
-static av_always_inline av_const uint32_t av_bswap32(uint32_t x)
-{
-    return AV_BSWAP32C(x);
-}
-#endif
-
-#ifndef av_bswap64
-static inline uint64_t av_const av_bswap64(uint64_t x)
-{
-    return (uint64_t)av_bswap32(x) << 32 | av_bswap32(x >> 32);
-}
-#endif
-
-// be2ne ... big-endian to native-endian
-// le2ne ... little-endian to native-endian
-
-#if AV_HAVE_BIGENDIAN
-#define av_be2ne16(x) (x)
-#define av_be2ne32(x) (x)
-#define av_be2ne64(x) (x)
-#define av_le2ne16(x) av_bswap16(x)
-#define av_le2ne32(x) av_bswap32(x)
-#define av_le2ne64(x) av_bswap64(x)
-#define AV_BE2NEC(s, x) (x)
-#define AV_LE2NEC(s, x) AV_BSWAPC(s, x)
-#else
-#define av_be2ne16(x) av_bswap16(x)
-#define av_be2ne32(x) av_bswap32(x)
-#define av_be2ne64(x) av_bswap64(x)
-#define av_le2ne16(x) (x)
-#define av_le2ne32(x) (x)
-#define av_le2ne64(x) (x)
-#define AV_BE2NEC(s, x) AV_BSWAPC(s, x)
-#define AV_LE2NEC(s, x) (x)
-#endif
-
-#define AV_BE2NE16C(x) AV_BE2NEC(16, x)
-#define AV_BE2NE32C(x) AV_BE2NEC(32, x)
-#define AV_BE2NE64C(x) AV_BE2NEC(64, x)
-#define AV_LE2NE16C(x) AV_LE2NEC(16, x)
-#define AV_LE2NE32C(x) AV_LE2NEC(32, x)
-#define AV_LE2NE64C(x) AV_LE2NEC(64, x)
-
-#endif /* AVUTIL_BSWAP_H */
diff -pruN /usr/include/ffmpeg/libavutil/buffer.h csrc/libavutil/buffer.h
--- /usr/include/ffmpeg/libavutil/buffer.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/buffer.h	2014-10-20 10:36:35.400496046 +0200
@@ -1,274 +1,9 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * @ingroup lavu_buffer
- * refcounted data buffer API
- */
 
 #ifndef AVUTIL_BUFFER_H
 #define AVUTIL_BUFFER_H
 
-#include <stdint.h>
-
-/**
- * @defgroup lavu_buffer AVBuffer
- * @ingroup lavu_data
- *
- * @{
- * AVBuffer is an API for reference-counted data buffers.
- *
- * There are two core objects in this API -- AVBuffer and AVBufferRef. AVBuffer
- * represents the data buffer itself; it is opaque and not meant to be accessed
- * by the caller directly, but only through AVBufferRef. However, the caller may
- * e.g. compare two AVBuffer pointers to check whether two different references
- * are describing the same data buffer. AVBufferRef represents a single
- * reference to an AVBuffer and it is the object that may be manipulated by the
- * caller directly.
- *
- * There are two functions provided for creating a new AVBuffer with a single
- * reference -- av_buffer_alloc() to just allocate a new buffer, and
- * av_buffer_create() to wrap an existing array in an AVBuffer. From an existing
- * reference, additional references may be created with av_buffer_ref().
- * Use av_buffer_unref() to free a reference (this will automatically free the
- * data once all the references are freed).
- *
- * The convention throughout this API and the rest of FFmpeg is such that the
- * buffer is considered writable if there exists only one reference to it (and
- * it has not been marked as read-only). The av_buffer_is_writable() function is
- * provided to check whether this is true and av_buffer_make_writable() will
- * automatically create a new writable buffer when necessary.
- * Of course nothing prevents the calling code from violating this convention,
- * however that is safe only when all the existing references are under its
- * control.
- *
- * @note Referencing and unreferencing the buffers is thread-safe and thus
- * may be done from multiple threads simultaneously without any need for
- * additional locking.
- *
- * @note Two different references to the same buffer can point to different
- * parts of the buffer (i.e. their AVBufferRef.data will not be equal).
- */
-
-/**
- * A reference counted buffer type. It is opaque and is meant to be used through
- * references (AVBufferRef).
- */
-typedef struct AVBuffer AVBuffer;
-
-/**
- * A reference to a data buffer.
- *
- * The size of this struct is not a part of the public ABI and it is not meant
- * to be allocated directly.
- */
 typedef struct AVBufferRef {
-    AVBuffer *buffer;
-
-    /**
-     * The data buffer. It is considered writable if and only if
-     * this is the only reference to the buffer, in which case
-     * av_buffer_is_writable() returns 1.
-     */
-    uint8_t *data;
-    /**
-     * Size of data in bytes.
-     */
-    int      size;
+    int dummy;
 } AVBufferRef;
 
-/**
- * Allocate an AVBuffer of the given size using av_malloc().
- *
- * @return an AVBufferRef of given size or NULL when out of memory
- */
-AVBufferRef *av_buffer_alloc(int size);
-
-/**
- * Same as av_buffer_alloc(), except the returned buffer will be initialized
- * to zero.
- */
-AVBufferRef *av_buffer_allocz(int size);
-
-/**
- * Always treat the buffer as read-only, even when it has only one
- * reference.
- */
-#define AV_BUFFER_FLAG_READONLY (1 << 0)
-
-/**
- * Create an AVBuffer from an existing array.
- *
- * If this function is successful, data is owned by the AVBuffer. The caller may
- * only access data through the returned AVBufferRef and references derived from
- * it.
- * If this function fails, data is left untouched.
- * @param data   data array
- * @param size   size of data in bytes
- * @param free   a callback for freeing this buffer's data
- * @param opaque parameter to be got for processing or passed to free
- * @param flags  a combination of AV_BUFFER_FLAG_*
- *
- * @return an AVBufferRef referring to data on success, NULL on failure.
- */
-AVBufferRef *av_buffer_create(uint8_t *data, int size,
-                              void (*free)(void *opaque, uint8_t *data),
-                              void *opaque, int flags);
-
-/**
- * Default free callback, which calls av_free() on the buffer data.
- * This function is meant to be passed to av_buffer_create(), not called
- * directly.
- */
-void av_buffer_default_free(void *opaque, uint8_t *data);
-
-/**
- * Create a new reference to an AVBuffer.
- *
- * @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on
- * failure.
- */
-AVBufferRef *av_buffer_ref(AVBufferRef *buf);
-
-/**
- * Free a given reference and automatically free the buffer if there are no more
- * references to it.
- *
- * @param buf the reference to be freed. The pointer is set to NULL on return.
- */
-void av_buffer_unref(AVBufferRef **buf);
-
-/**
- * @return 1 if the caller may write to the data referred to by buf (which is
- * true if and only if buf is the only reference to the underlying AVBuffer).
- * Return 0 otherwise.
- * A positive answer is valid until av_buffer_ref() is called on buf.
- */
-int av_buffer_is_writable(const AVBufferRef *buf);
-
-/**
- * @return the opaque parameter set by av_buffer_create.
- */
-void *av_buffer_get_opaque(const AVBufferRef *buf);
-
-int av_buffer_get_ref_count(const AVBufferRef *buf);
-
-/**
- * Create a writable reference from a given buffer reference, avoiding data copy
- * if possible.
- *
- * @param buf buffer reference to make writable. On success, buf is either left
- *            untouched, or it is unreferenced and a new writable AVBufferRef is
- *            written in its place. On failure, buf is left untouched.
- * @return 0 on success, a negative AVERROR on failure.
- */
-int av_buffer_make_writable(AVBufferRef **buf);
-
-/**
- * Reallocate a given buffer.
- *
- * @param buf  a buffer reference to reallocate. On success, buf will be
- *             unreferenced and a new reference with the required size will be
- *             written in its place. On failure buf will be left untouched. *buf
- *             may be NULL, then a new buffer is allocated.
- * @param size required new buffer size.
- * @return 0 on success, a negative AVERROR on failure.
- *
- * @note the buffer is actually reallocated with av_realloc() only if it was
- * initially allocated through av_buffer_realloc(NULL) and there is only one
- * reference to it (i.e. the one passed to this function). In all other cases
- * a new buffer is allocated and the data is copied.
- */
-int av_buffer_realloc(AVBufferRef **buf, int size);
-
-/**
- * @}
- */
-
-/**
- * @defgroup lavu_bufferpool AVBufferPool
- * @ingroup lavu_data
- *
- * @{
- * AVBufferPool is an API for a lock-free thread-safe pool of AVBuffers.
- *
- * Frequently allocating and freeing large buffers may be slow. AVBufferPool is
- * meant to solve this in cases when the caller needs a set of buffers of the
- * same size (the most obvious use case being buffers for raw video or audio
- * frames).
- *
- * At the beginning, the user must call av_buffer_pool_init() to create the
- * buffer pool. Then whenever a buffer is needed, call av_buffer_pool_get() to
- * get a reference to a new buffer, similar to av_buffer_alloc(). This new
- * reference works in all aspects the same way as the one created by
- * av_buffer_alloc(). However, when the last reference to this buffer is
- * unreferenced, it is returned to the pool instead of being freed and will be
- * reused for subsequent av_buffer_pool_get() calls.
- *
- * When the caller is done with the pool and no longer needs to allocate any new
- * buffers, av_buffer_pool_uninit() must be called to mark the pool as freeable.
- * Once all the buffers are released, it will automatically be freed.
- *
- * Allocating and releasing buffers with this API is thread-safe as long as
- * either the default alloc callback is used, or the user-supplied one is
- * thread-safe.
- */
-
-/**
- * The buffer pool. This structure is opaque and not meant to be accessed
- * directly. It is allocated with av_buffer_pool_init() and freed with
- * av_buffer_pool_uninit().
- */
-typedef struct AVBufferPool AVBufferPool;
-
-/**
- * Allocate and initialize a buffer pool.
- *
- * @param size size of each buffer in this pool
- * @param alloc a function that will be used to allocate new buffers when the
- * pool is empty. May be NULL, then the default allocator will be used
- * (av_buffer_alloc()).
- * @return newly created buffer pool on success, NULL on error.
- */
-AVBufferPool *av_buffer_pool_init(int size, AVBufferRef* (*alloc)(int size));
-
-/**
- * Mark the pool as being available for freeing. It will actually be freed only
- * once all the allocated buffers associated with the pool are released. Thus it
- * is safe to call this function while some of the allocated buffers are still
- * in use.
- *
- * @param pool pointer to the pool to be freed. It will be set to NULL.
- * @see av_buffer_pool_can_uninit()
- */
-void av_buffer_pool_uninit(AVBufferPool **pool);
-
-/**
- * Allocate a new AVBuffer, reusing an old buffer from the pool when available.
- * This function may be called simultaneously from multiple threads.
- *
- * @return a reference to the new buffer on success, NULL on error.
- */
-AVBufferRef *av_buffer_pool_get(AVBufferPool *pool);
-
-/**
- * @}
- */
-
 #endif /* AVUTIL_BUFFER_H */
diff -pruN /usr/include/ffmpeg/libavutil/channel_layout.h csrc/libavutil/channel_layout.h
--- /usr/include/ffmpeg/libavutil/channel_layout.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/channel_layout.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,222 +0,0 @@
-/*
- * Copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (c) 2008 Peter Ross
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_CHANNEL_LAYOUT_H
-#define AVUTIL_CHANNEL_LAYOUT_H
-
-#include <stdint.h>
-
-/**
- * @file
- * audio channel layout utility functions
- */
-
-/**
- * @addtogroup lavu_audio
- * @{
- */
-
-/**
- * @defgroup channel_masks Audio channel masks
- *
- * A channel layout is a 64-bits integer with a bit set for every channel.
- * The number of bits set must be equal to the number of channels.
- * The value 0 means that the channel layout is not known.
- * @note this data structure is not powerful enough to handle channels
- * combinations that have the same channel multiple times, such as
- * dual-mono.
- *
- * @{
- */
-#define AV_CH_FRONT_LEFT             0x00000001
-#define AV_CH_FRONT_RIGHT            0x00000002
-#define AV_CH_FRONT_CENTER           0x00000004
-#define AV_CH_LOW_FREQUENCY          0x00000008
-#define AV_CH_BACK_LEFT              0x00000010
-#define AV_CH_BACK_RIGHT             0x00000020
-#define AV_CH_FRONT_LEFT_OF_CENTER   0x00000040
-#define AV_CH_FRONT_RIGHT_OF_CENTER  0x00000080
-#define AV_CH_BACK_CENTER            0x00000100
-#define AV_CH_SIDE_LEFT              0x00000200
-#define AV_CH_SIDE_RIGHT             0x00000400
-#define AV_CH_TOP_CENTER             0x00000800
-#define AV_CH_TOP_FRONT_LEFT         0x00001000
-#define AV_CH_TOP_FRONT_CENTER       0x00002000
-#define AV_CH_TOP_FRONT_RIGHT        0x00004000
-#define AV_CH_TOP_BACK_LEFT          0x00008000
-#define AV_CH_TOP_BACK_CENTER        0x00010000
-#define AV_CH_TOP_BACK_RIGHT         0x00020000
-#define AV_CH_STEREO_LEFT            0x20000000  ///< Stereo downmix.
-#define AV_CH_STEREO_RIGHT           0x40000000  ///< See AV_CH_STEREO_LEFT.
-#define AV_CH_WIDE_LEFT              0x0000000080000000ULL
-#define AV_CH_WIDE_RIGHT             0x0000000100000000ULL
-#define AV_CH_SURROUND_DIRECT_LEFT   0x0000000200000000ULL
-#define AV_CH_SURROUND_DIRECT_RIGHT  0x0000000400000000ULL
-#define AV_CH_LOW_FREQUENCY_2        0x0000000800000000ULL
-
-/** Channel mask value used for AVCodecContext.request_channel_layout
-    to indicate that the user requests the channel order of the decoder output
-    to be the native codec channel order. */
-#define AV_CH_LAYOUT_NATIVE          0x8000000000000000ULL
-
-/**
- * @}
- * @defgroup channel_mask_c Audio channel layouts
- * @{
- * */
-#define AV_CH_LAYOUT_MONO              (AV_CH_FRONT_CENTER)
-#define AV_CH_LAYOUT_STEREO            (AV_CH_FRONT_LEFT|AV_CH_FRONT_RIGHT)
-#define AV_CH_LAYOUT_2POINT1           (AV_CH_LAYOUT_STEREO|AV_CH_LOW_FREQUENCY)
-#define AV_CH_LAYOUT_2_1               (AV_CH_LAYOUT_STEREO|AV_CH_BACK_CENTER)
-#define AV_CH_LAYOUT_SURROUND          (AV_CH_LAYOUT_STEREO|AV_CH_FRONT_CENTER)
-#define AV_CH_LAYOUT_3POINT1           (AV_CH_LAYOUT_SURROUND|AV_CH_LOW_FREQUENCY)
-#define AV_CH_LAYOUT_4POINT0           (AV_CH_LAYOUT_SURROUND|AV_CH_BACK_CENTER)
-#define AV_CH_LAYOUT_4POINT1           (AV_CH_LAYOUT_4POINT0|AV_CH_LOW_FREQUENCY)
-#define AV_CH_LAYOUT_2_2               (AV_CH_LAYOUT_STEREO|AV_CH_SIDE_LEFT|AV_CH_SIDE_RIGHT)
-#define AV_CH_LAYOUT_QUAD              (AV_CH_LAYOUT_STEREO|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)
-#define AV_CH_LAYOUT_5POINT0           (AV_CH_LAYOUT_SURROUND|AV_CH_SIDE_LEFT|AV_CH_SIDE_RIGHT)
-#define AV_CH_LAYOUT_5POINT1           (AV_CH_LAYOUT_5POINT0|AV_CH_LOW_FREQUENCY)
-#define AV_CH_LAYOUT_5POINT0_BACK      (AV_CH_LAYOUT_SURROUND|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)
-#define AV_CH_LAYOUT_5POINT1_BACK      (AV_CH_LAYOUT_5POINT0_BACK|AV_CH_LOW_FREQUENCY)
-#define AV_CH_LAYOUT_6POINT0           (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_CENTER)
-#define AV_CH_LAYOUT_6POINT0_FRONT     (AV_CH_LAYOUT_2_2|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)
-#define AV_CH_LAYOUT_HEXAGONAL         (AV_CH_LAYOUT_5POINT0_BACK|AV_CH_BACK_CENTER)
-#define AV_CH_LAYOUT_6POINT1           (AV_CH_LAYOUT_5POINT1|AV_CH_BACK_CENTER)
-#define AV_CH_LAYOUT_6POINT1_BACK      (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_BACK_CENTER)
-#define AV_CH_LAYOUT_6POINT1_FRONT     (AV_CH_LAYOUT_6POINT0_FRONT|AV_CH_LOW_FREQUENCY)
-#define AV_CH_LAYOUT_7POINT0           (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)
-#define AV_CH_LAYOUT_7POINT0_FRONT     (AV_CH_LAYOUT_5POINT0|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)
-#define AV_CH_LAYOUT_7POINT1           (AV_CH_LAYOUT_5POINT1|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)
-#define AV_CH_LAYOUT_7POINT1_WIDE      (AV_CH_LAYOUT_5POINT1|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)
-#define AV_CH_LAYOUT_7POINT1_WIDE_BACK (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)
-#define AV_CH_LAYOUT_OCTAGONAL         (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_LEFT|AV_CH_BACK_CENTER|AV_CH_BACK_RIGHT)
-#define AV_CH_LAYOUT_STEREO_DOWNMIX    (AV_CH_STEREO_LEFT|AV_CH_STEREO_RIGHT)
-
-enum AVMatrixEncoding {
-    AV_MATRIX_ENCODING_NONE,
-    AV_MATRIX_ENCODING_DOLBY,
-    AV_MATRIX_ENCODING_DPLII,
-    AV_MATRIX_ENCODING_DPLIIX,
-    AV_MATRIX_ENCODING_DPLIIZ,
-    AV_MATRIX_ENCODING_DOLBYEX,
-    AV_MATRIX_ENCODING_DOLBYHEADPHONE,
-    AV_MATRIX_ENCODING_NB
-};
-
-/**
- * Return a channel layout id that matches name, or 0 if no match is found.
- *
- * name can be one or several of the following notations,
- * separated by '+' or '|':
- * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,
- *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);
- * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,
- *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);
- * - a number of channels, in decimal, optionally followed by 'c', yielding
- *   the default channel layout for that number of channels (@see
- *   av_get_default_channel_layout);
- * - a channel layout mask, in hexadecimal starting with "0x" (see the
- *   AV_CH_* macros).
- *
- * @warning Starting from the next major bump the trailing character
- * 'c' to specify a number of channels will be required, while a
- * channel layout mask could also be specified as a decimal number
- * (if and only if not followed by "c").
- *
- * Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"
- */
-uint64_t av_get_channel_layout(const char *name);
-
-/**
- * Return a description of a channel layout.
- * If nb_channels is <= 0, it is guessed from the channel_layout.
- *
- * @param buf put here the string containing the channel layout
- * @param buf_size size in bytes of the buffer
- */
-void av_get_channel_layout_string(char *buf, int buf_size, int nb_channels, uint64_t channel_layout);
-
-struct AVBPrint;
-/**
- * Append a description of a channel layout to a bprint buffer.
- */
-void av_bprint_channel_layout(struct AVBPrint *bp, int nb_channels, uint64_t channel_layout);
-
-/**
- * Return the number of channels in the channel layout.
- */
-int av_get_channel_layout_nb_channels(uint64_t channel_layout);
-
-/**
- * Return default channel layout for a given number of channels.
- */
-int64_t av_get_default_channel_layout(int nb_channels);
-
-/**
- * Get the index of a channel in channel_layout.
- *
- * @param channel a channel layout describing exactly one channel which must be
- *                present in channel_layout.
- *
- * @return index of channel in channel_layout on success, a negative AVERROR
- *         on error.
- */
-int av_get_channel_layout_channel_index(uint64_t channel_layout,
-                                        uint64_t channel);
-
-/**
- * Get the channel with the given index in channel_layout.
- */
-uint64_t av_channel_layout_extract_channel(uint64_t channel_layout, int index);
-
-/**
- * Get the name of a given channel.
- *
- * @return channel name on success, NULL on error.
- */
-const char *av_get_channel_name(uint64_t channel);
-
-/**
- * Get the description of a given channel.
- *
- * @param channel  a channel layout with a single channel
- * @return  channel description on success, NULL on error
- */
-const char *av_get_channel_description(uint64_t channel);
-
-/**
- * Get the value and name of a standard channel layout.
- *
- * @param[in]  index   index in an internal list, starting at 0
- * @param[out] layout  channel layout mask
- * @param[out] name    name of the layout
- * @return  0  if the layout exists,
- *          <0 if index is beyond the limits
- */
-int av_get_standard_channel_layout(unsigned index, uint64_t *layout,
-                                   const char **name);
-
-/**
- * @}
- * @}
- */
-
-#endif /* AVUTIL_CHANNEL_LAYOUT_H */
diff -pruN /usr/include/ffmpeg/libavutil/common.h csrc/libavutil/common.h
--- /usr/include/ffmpeg/libavutil/common.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/common.h	2014-10-20 10:36:36.461494755 +0200
@@ -1,469 +1,9 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * common internal and external API header
- */
 
 #ifndef AVUTIL_COMMON_H
 #define AVUTIL_COMMON_H
 
-#if defined(__cplusplus) && !defined(__STDC_CONSTANT_MACROS) && !defined(UINT64_C)
-#error missing -D__STDC_CONSTANT_MACROS / #define __STDC_CONSTANT_MACROS
-#endif
-
-#include <errno.h>
-#include <inttypes.h>
-#include <limits.h>
-#include <math.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "attributes.h"
-#include "version.h"
-#include "libavutil/avconfig.h"
-
-#if AV_HAVE_BIGENDIAN
-#   define AV_NE(be, le) (be)
-#else
-#   define AV_NE(be, le) (le)
-#endif
-
-//rounded division & shift
-#define RSHIFT(a,b) ((a) > 0 ? ((a) + ((1<<(b))>>1))>>(b) : ((a) + ((1<<(b))>>1)-1)>>(b))
-/* assume b>0 */
-#define ROUNDED_DIV(a,b) (((a)>0 ? (a) + ((b)>>1) : (a) - ((b)>>1))/(b))
-/* assume a>0 and b>0 */
-#define FF_CEIL_RSHIFT(a,b) (!av_builtin_constant_p(b) ? -((-(a)) >> (b)) \
-                                                       : ((a) + (1<<(b)) - 1) >> (b))
-#define FFUDIV(a,b) (((a)>0 ?(a):(a)-(b)+1) / (b))
-#define FFUMOD(a,b) ((a)-(b)*FFUDIV(a,b))
-#define FFABS(a) ((a) >= 0 ? (a) : (-(a)))
-#define FFSIGN(a) ((a) > 0 ? 1 : -1)
-
 #define FFMAX(a,b) ((a) > (b) ? (a) : (b))
-#define FFMAX3(a,b,c) FFMAX(FFMAX(a,b),c)
-#define FFMIN(a,b) ((a) > (b) ? (b) : (a))
-#define FFMIN3(a,b,c) FFMIN(FFMIN(a,b),c)
-
-#define FFSWAP(type,a,b) do{type SWAP_tmp= b; b= a; a= SWAP_tmp;}while(0)
-#define FF_ARRAY_ELEMS(a) (sizeof(a) / sizeof((a)[0]))
-#define FFALIGN(x, a) (((x)+(a)-1)&~((a)-1))
-
-/* misc math functions */
-
-/**
- * Reverse the order of the bits of an 8-bits unsigned integer.
- */
-#if FF_API_AV_REVERSE
-extern attribute_deprecated const uint8_t av_reverse[256];
-#endif
-
-#ifdef HAVE_AV_CONFIG_H
-#   include "config.h"
-#   include "intmath.h"
-#endif
-
-/* Pull in unguarded fallback defines at the end of this file. */
-#include "common.h"
-
-#ifndef av_log2
-av_const int av_log2(unsigned v);
-#endif
-
-#ifndef av_log2_16bit
-av_const int av_log2_16bit(unsigned v);
-#endif
-
-/**
- * Clip a signed integer value into the amin-amax range.
- * @param a value to clip
- * @param amin minimum value of the clip range
- * @param amax maximum value of the clip range
- * @return clipped value
- */
-static av_always_inline av_const int av_clip_c(int a, int amin, int amax)
-{
-#if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
-    if (amin > amax) abort();
-#endif
-    if      (a < amin) return amin;
-    else if (a > amax) return amax;
-    else               return a;
-}
-
-/**
- * Clip a signed 64bit integer value into the amin-amax range.
- * @param a value to clip
- * @param amin minimum value of the clip range
- * @param amax maximum value of the clip range
- * @return clipped value
- */
-static av_always_inline av_const int64_t av_clip64_c(int64_t a, int64_t amin, int64_t amax)
-{
-#if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
-    if (amin > amax) abort();
-#endif
-    if      (a < amin) return amin;
-    else if (a > amax) return amax;
-    else               return a;
-}
-
-/**
- * Clip a signed integer value into the 0-255 range.
- * @param a value to clip
- * @return clipped value
- */
-static av_always_inline av_const uint8_t av_clip_uint8_c(int a)
-{
-    if (a&(~0xFF)) return (-a)>>31;
-    else           return a;
-}
-
-/**
- * Clip a signed integer value into the -128,127 range.
- * @param a value to clip
- * @return clipped value
- */
-static av_always_inline av_const int8_t av_clip_int8_c(int a)
-{
-    if ((a+0x80) & ~0xFF) return (a>>31) ^ 0x7F;
-    else                  return a;
-}
-
-/**
- * Clip a signed integer value into the 0-65535 range.
- * @param a value to clip
- * @return clipped value
- */
-static av_always_inline av_const uint16_t av_clip_uint16_c(int a)
-{
-    if (a&(~0xFFFF)) return (-a)>>31;
-    else             return a;
-}
-
-/**
- * Clip a signed integer value into the -32768,32767 range.
- * @param a value to clip
- * @return clipped value
- */
-static av_always_inline av_const int16_t av_clip_int16_c(int a)
-{
-    if ((a+0x8000) & ~0xFFFF) return (a>>31) ^ 0x7FFF;
-    else                      return a;
-}
-
-/**
- * Clip a signed 64-bit integer value into the -2147483648,2147483647 range.
- * @param a value to clip
- * @return clipped value
- */
-static av_always_inline av_const int32_t av_clipl_int32_c(int64_t a)
-{
-    if ((a+0x80000000u) & ~UINT64_C(0xFFFFFFFF)) return (int32_t)((a>>63) ^ 0x7FFFFFFF);
-    else                                         return (int32_t)a;
-}
-
-/**
- * Clip a signed integer to an unsigned power of two range.
- * @param  a value to clip
- * @param  p bit position to clip at
- * @return clipped value
- */
-static av_always_inline av_const unsigned av_clip_uintp2_c(int a, int p)
-{
-    if (a & ~((1<<p) - 1)) return -a >> 31 & ((1<<p) - 1);
-    else                   return  a;
-}
-
-/**
- * Add two signed 32-bit values with saturation.
- *
- * @param  a one value
- * @param  b another value
- * @return sum with signed saturation
- */
-static av_always_inline int av_sat_add32_c(int a, int b)
-{
-    return av_clipl_int32((int64_t)a + b);
-}
-
-/**
- * Add a doubled value to another value with saturation at both stages.
- *
- * @param  a first value
- * @param  b value doubled and added to a
- * @return sum with signed saturation
- */
-static av_always_inline int av_sat_dadd32_c(int a, int b)
-{
-    return av_sat_add32(a, av_sat_add32(b, b));
-}
-
-/**
- * Clip a float value into the amin-amax range.
- * @param a value to clip
- * @param amin minimum value of the clip range
- * @param amax maximum value of the clip range
- * @return clipped value
- */
-static av_always_inline av_const float av_clipf_c(float a, float amin, float amax)
-{
-#if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
-    if (amin > amax) abort();
-#endif
-    if      (a < amin) return amin;
-    else if (a > amax) return amax;
-    else               return a;
-}
-
-/**
- * Clip a double value into the amin-amax range.
- * @param a value to clip
- * @param amin minimum value of the clip range
- * @param amax maximum value of the clip range
- * @return clipped value
- */
-static av_always_inline av_const double av_clipd_c(double a, double amin, double amax)
-{
-#if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
-    if (amin > amax) abort();
-#endif
-    if      (a < amin) return amin;
-    else if (a > amax) return amax;
-    else               return a;
-}
-
-/** Compute ceil(log2(x)).
- * @param x value used to compute ceil(log2(x))
- * @return computed ceiling of log2(x)
- */
-static av_always_inline av_const int av_ceil_log2_c(int x)
-{
-    return av_log2((x - 1) << 1);
-}
-
-/**
- * Count number of bits set to one in x
- * @param x value to count bits of
- * @return the number of bits set to one in x
- */
-static av_always_inline av_const int av_popcount_c(uint32_t x)
-{
-    x -= (x >> 1) & 0x55555555;
-    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
-    x = (x + (x >> 4)) & 0x0F0F0F0F;
-    x += x >> 8;
-    return (x + (x >> 16)) & 0x3F;
-}
-
-/**
- * Count number of bits set to one in x
- * @param x value to count bits of
- * @return the number of bits set to one in x
- */
-static av_always_inline av_const int av_popcount64_c(uint64_t x)
-{
-    return av_popcount((uint32_t)x) + av_popcount((uint32_t)(x >> 32));
-}
-
 #define MKTAG(a,b,c,d) ((a) | ((b) << 8) | ((c) << 16) | ((unsigned)(d) << 24))
 #define MKBETAG(a,b,c,d) ((d) | ((c) << 8) | ((b) << 16) | ((unsigned)(a) << 24))
 
-/**
- * Convert a UTF-8 character (up to 4 bytes) to its 32-bit UCS-4 encoded form.
- *
- * @param val      Output value, must be an lvalue of type uint32_t.
- * @param GET_BYTE Expression reading one byte from the input.
- *                 Evaluated up to 7 times (4 for the currently
- *                 assigned Unicode range).  With a memory buffer
- *                 input, this could be *ptr++.
- * @param ERROR    Expression to be evaluated on invalid input,
- *                 typically a goto statement.
- *
- * @warning ERROR should not contain a loop control statement which
- * could interact with the internal while loop, and should force an
- * exit from the macro code (e.g. through a goto or a return) in order
- * to prevent undefined results.
- */
-#define GET_UTF8(val, GET_BYTE, ERROR)\
-    val= GET_BYTE;\
-    {\
-        uint32_t top = (val & 128) >> 1;\
-        if ((val & 0xc0) == 0x80 || val >= 0xFE)\
-            ERROR\
-        while (val & top) {\
-            int tmp= GET_BYTE - 128;\
-            if(tmp>>6)\
-                ERROR\
-            val= (val<<6) + tmp;\
-            top <<= 5;\
-        }\
-        val &= (top << 1) - 1;\
-    }
-
-/**
- * Convert a UTF-16 character (2 or 4 bytes) to its 32-bit UCS-4 encoded form.
- *
- * @param val       Output value, must be an lvalue of type uint32_t.
- * @param GET_16BIT Expression returning two bytes of UTF-16 data converted
- *                  to native byte order.  Evaluated one or two times.
- * @param ERROR     Expression to be evaluated on invalid input,
- *                  typically a goto statement.
- */
-#define GET_UTF16(val, GET_16BIT, ERROR)\
-    val = GET_16BIT;\
-    {\
-        unsigned int hi = val - 0xD800;\
-        if (hi < 0x800) {\
-            val = GET_16BIT - 0xDC00;\
-            if (val > 0x3FFU || hi > 0x3FFU)\
-                ERROR\
-            val += (hi<<10) + 0x10000;\
-        }\
-    }\
-
-/**
- * @def PUT_UTF8(val, tmp, PUT_BYTE)
- * Convert a 32-bit Unicode character to its UTF-8 encoded form (up to 4 bytes long).
- * @param val is an input-only argument and should be of type uint32_t. It holds
- * a UCS-4 encoded Unicode character that is to be converted to UTF-8. If
- * val is given as a function it is executed only once.
- * @param tmp is a temporary variable and should be of type uint8_t. It
- * represents an intermediate value during conversion that is to be
- * output by PUT_BYTE.
- * @param PUT_BYTE writes the converted UTF-8 bytes to any proper destination.
- * It could be a function or a statement, and uses tmp as the input byte.
- * For example, PUT_BYTE could be "*output++ = tmp;" PUT_BYTE will be
- * executed up to 4 times for values in the valid UTF-8 range and up to
- * 7 times in the general case, depending on the length of the converted
- * Unicode character.
- */
-#define PUT_UTF8(val, tmp, PUT_BYTE)\
-    {\
-        int bytes, shift;\
-        uint32_t in = val;\
-        if (in < 0x80) {\
-            tmp = in;\
-            PUT_BYTE\
-        } else {\
-            bytes = (av_log2(in) + 4) / 5;\
-            shift = (bytes - 1) * 6;\
-            tmp = (256 - (256 >> bytes)) | (in >> shift);\
-            PUT_BYTE\
-            while (shift >= 6) {\
-                shift -= 6;\
-                tmp = 0x80 | ((in >> shift) & 0x3f);\
-                PUT_BYTE\
-            }\
-        }\
-    }
-
-/**
- * @def PUT_UTF16(val, tmp, PUT_16BIT)
- * Convert a 32-bit Unicode character to its UTF-16 encoded form (2 or 4 bytes).
- * @param val is an input-only argument and should be of type uint32_t. It holds
- * a UCS-4 encoded Unicode character that is to be converted to UTF-16. If
- * val is given as a function it is executed only once.
- * @param tmp is a temporary variable and should be of type uint16_t. It
- * represents an intermediate value during conversion that is to be
- * output by PUT_16BIT.
- * @param PUT_16BIT writes the converted UTF-16 data to any proper destination
- * in desired endianness. It could be a function or a statement, and uses tmp
- * as the input byte.  For example, PUT_BYTE could be "*output++ = tmp;"
- * PUT_BYTE will be executed 1 or 2 times depending on input character.
- */
-#define PUT_UTF16(val, tmp, PUT_16BIT)\
-    {\
-        uint32_t in = val;\
-        if (in < 0x10000) {\
-            tmp = in;\
-            PUT_16BIT\
-        } else {\
-            tmp = 0xD800 | ((in - 0x10000) >> 10);\
-            PUT_16BIT\
-            tmp = 0xDC00 | ((in - 0x10000) & 0x3FF);\
-            PUT_16BIT\
-        }\
-    }\
-
-
-
-#include "mem.h"
-
-#ifdef HAVE_AV_CONFIG_H
-#    include "internal.h"
-#endif /* HAVE_AV_CONFIG_H */
-
 #endif /* AVUTIL_COMMON_H */
-
-/*
- * The following definitions are outside the multiple inclusion guard
- * to ensure they are immediately available in intmath.h.
- */
-
-#ifndef av_ceil_log2
-#   define av_ceil_log2     av_ceil_log2_c
-#endif
-#ifndef av_clip
-#   define av_clip          av_clip_c
-#endif
-#ifndef av_clip64
-#   define av_clip64        av_clip64_c
-#endif
-#ifndef av_clip_uint8
-#   define av_clip_uint8    av_clip_uint8_c
-#endif
-#ifndef av_clip_int8
-#   define av_clip_int8     av_clip_int8_c
-#endif
-#ifndef av_clip_uint16
-#   define av_clip_uint16   av_clip_uint16_c
-#endif
-#ifndef av_clip_int16
-#   define av_clip_int16    av_clip_int16_c
-#endif
-#ifndef av_clipl_int32
-#   define av_clipl_int32   av_clipl_int32_c
-#endif
-#ifndef av_clip_uintp2
-#   define av_clip_uintp2   av_clip_uintp2_c
-#endif
-#ifndef av_sat_add32
-#   define av_sat_add32     av_sat_add32_c
-#endif
-#ifndef av_sat_dadd32
-#   define av_sat_dadd32    av_sat_dadd32_c
-#endif
-#ifndef av_clipf
-#   define av_clipf         av_clipf_c
-#endif
-#ifndef av_clipd
-#   define av_clipd         av_clipd_c
-#endif
-#ifndef av_popcount
-#   define av_popcount      av_popcount_c
-#endif
-#ifndef av_popcount64
-#   define av_popcount64    av_popcount64_c
-#endif
diff -pruN /usr/include/ffmpeg/libavutil/cpu.h csrc/libavutil/cpu.h
--- /usr/include/ffmpeg/libavutil/cpu.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/cpu.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-/*
- * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_CPU_H
-#define AVUTIL_CPU_H
-
-#include "attributes.h"
-
-#define AV_CPU_FLAG_FORCE    0x80000000 /* force usage of selected flags (OR) */
-
-    /* lower 16 bits - CPU features */
-#define AV_CPU_FLAG_MMX          0x0001 ///< standard MMX
-#define AV_CPU_FLAG_MMXEXT       0x0002 ///< SSE integer functions or AMD MMX ext
-#define AV_CPU_FLAG_MMX2         0x0002 ///< SSE integer functions or AMD MMX ext
-#define AV_CPU_FLAG_3DNOW        0x0004 ///< AMD 3DNOW
-#define AV_CPU_FLAG_SSE          0x0008 ///< SSE functions
-#define AV_CPU_FLAG_SSE2         0x0010 ///< PIV SSE2 functions
-#define AV_CPU_FLAG_SSE2SLOW 0x40000000 ///< SSE2 supported, but usually not faster
-                                        ///< than regular MMX/SSE (e.g. Core1)
-#define AV_CPU_FLAG_3DNOWEXT     0x0020 ///< AMD 3DNowExt
-#define AV_CPU_FLAG_SSE3         0x0040 ///< Prescott SSE3 functions
-#define AV_CPU_FLAG_SSE3SLOW 0x20000000 ///< SSE3 supported, but usually not faster
-                                        ///< than regular MMX/SSE (e.g. Core1)
-#define AV_CPU_FLAG_SSSE3        0x0080 ///< Conroe SSSE3 functions
-#define AV_CPU_FLAG_ATOM     0x10000000 ///< Atom processor, some SSSE3 instructions are slower
-#define AV_CPU_FLAG_SSE4         0x0100 ///< Penryn SSE4.1 functions
-#define AV_CPU_FLAG_SSE42        0x0200 ///< Nehalem SSE4.2 functions
-#define AV_CPU_FLAG_AVX          0x4000 ///< AVX functions: requires OS support even if YMM registers aren't used
-#define AV_CPU_FLAG_XOP          0x0400 ///< Bulldozer XOP functions
-#define AV_CPU_FLAG_FMA4         0x0800 ///< Bulldozer FMA4 functions
-// #if LIBAVUTIL_VERSION_MAJOR <52
-#define AV_CPU_FLAG_CMOV      0x1001000 ///< supports cmov instruction
-// #else
-// #define AV_CPU_FLAG_CMOV         0x1000 ///< supports cmov instruction
-// #endif
-#define AV_CPU_FLAG_AVX2         0x8000 ///< AVX2 functions: requires OS support even if YMM registers aren't used
-#define AV_CPU_FLAG_FMA3        0x10000 ///< Haswell FMA3 functions
-#define AV_CPU_FLAG_BMI1        0x20000 ///< Bit Manipulation Instruction Set 1
-#define AV_CPU_FLAG_BMI2        0x40000 ///< Bit Manipulation Instruction Set 2
-
-#define AV_CPU_FLAG_ALTIVEC      0x0001 ///< standard
-
-#define AV_CPU_FLAG_ARMV5TE      (1 << 0)
-#define AV_CPU_FLAG_ARMV6        (1 << 1)
-#define AV_CPU_FLAG_ARMV6T2      (1 << 2)
-#define AV_CPU_FLAG_VFP          (1 << 3)
-#define AV_CPU_FLAG_VFPV3        (1 << 4)
-#define AV_CPU_FLAG_NEON         (1 << 5)
-#define AV_CPU_FLAG_ARMV8        (1 << 6)
-
-/**
- * Return the flags which specify extensions supported by the CPU.
- * The returned value is affected by av_force_cpu_flags() if that was used
- * before. So av_get_cpu_flags() can easily be used in a application to
- * detect the enabled cpu flags.
- */
-int av_get_cpu_flags(void);
-
-/**
- * Disables cpu detection and forces the specified flags.
- * -1 is a special case that disables forcing of specific flags.
- */
-void av_force_cpu_flags(int flags);
-
-/**
- * Set a mask on flags returned by av_get_cpu_flags().
- * This function is mainly useful for testing.
- * Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible
- *
- * @warning this function is not thread safe.
- */
-attribute_deprecated void av_set_cpu_flags_mask(int mask);
-
-/**
- * Parse CPU flags from a string.
- *
- * The returned flags contain the specified flags as well as related unspecified flags.
- *
- * This function exists only for compatibility with libav.
- * Please use av_parse_cpu_caps() when possible.
- * @return a combination of AV_CPU_* flags, negative on error.
- */
-attribute_deprecated
-int av_parse_cpu_flags(const char *s);
-
-/**
- * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.
- *
- * @return negative on error.
- */
-int av_parse_cpu_caps(unsigned *flags, const char *s);
-
-/**
- * @return the number of logical CPU cores present.
- */
-int av_cpu_count(void);
-
-#endif /* AVUTIL_CPU_H */
diff -pruN /usr/include/ffmpeg/libavutil/crc.h csrc/libavutil/crc.h
--- /usr/include/ffmpeg/libavutil/crc.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/crc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_CRC_H
-#define AVUTIL_CRC_H
-
-#include <stdint.h>
-#include <stddef.h>
-#include "attributes.h"
-
-/**
- * @defgroup lavu_crc32 CRC32
- * @ingroup lavu_crypto
- * @{
- */
-
-typedef uint32_t AVCRC;
-
-typedef enum {
-    AV_CRC_8_ATM,
-    AV_CRC_16_ANSI,
-    AV_CRC_16_CCITT,
-    AV_CRC_32_IEEE,
-    AV_CRC_32_IEEE_LE,  /*< reversed bitorder version of AV_CRC_32_IEEE */
-    AV_CRC_16_ANSI_LE,  /*< reversed bitorder version of AV_CRC_16_ANSI */
-    AV_CRC_24_IEEE = 12,
-    AV_CRC_MAX,         /*< Not part of public API! Do not use outside libavutil. */
-}AVCRCId;
-
-/**
- * Initialize a CRC table.
- * @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024
- * @param le If 1, the lowest bit represents the coefficient for the highest
- *           exponent of the corresponding polynomial (both for poly and
- *           actual CRC).
- *           If 0, you must swap the CRC parameter and the result of av_crc
- *           if you need the standard representation (can be simplified in
- *           most cases to e.g. bswap16):
- *           av_bswap32(crc << (32-bits))
- * @param bits number of bits for the CRC
- * @param poly generator polynomial without the x**bits coefficient, in the
- *             representation as specified by le
- * @param ctx_size size of ctx in bytes
- * @return <0 on failure
- */
-int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size);
-
-/**
- * Get an initialized standard CRC table.
- * @param crc_id ID of a standard CRC
- * @return a pointer to the CRC table or NULL on failure
- */
-const AVCRC *av_crc_get_table(AVCRCId crc_id);
-
-/**
- * Calculate the CRC of a block.
- * @param crc CRC of previous blocks if any or initial value for CRC
- * @return CRC updated with the data from the given block
- *
- * @see av_crc_init() "le" parameter
- */
-uint32_t av_crc(const AVCRC *ctx, uint32_t crc,
-                const uint8_t *buffer, size_t length) av_pure;
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_CRC_H */
diff -pruN /usr/include/ffmpeg/libavutil/dict.h csrc/libavutil/dict.h
--- /usr/include/ffmpeg/libavutil/dict.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/dict.h	2014-10-20 12:21:52.248146678 +0200
@@ -77,70 +77,11 @@
 #define AV_DICT_APPEND         32   /**< If the entry already exists, append to it.  Note that no
                                       delimiter is added, the strings are simply concatenated. */
 
-typedef struct AVDictionaryEntry {
-    char *key;
-    char *value;
-} AVDictionaryEntry;
+typedef struct AVDictionaryEntry;
 
-typedef struct AVDictionary AVDictionary;
-
-/**
- * Get a dictionary entry with matching key.
- *
- * The returned entry key or value must not be changed, or it will
- * cause undefined behavior.
- *
- * To iterate through all the dictionary entries, you can set the matching key
- * to the null string "" and set the AV_DICT_IGNORE_SUFFIX flag.
- *
- * @param prev Set to the previous matching element to find the next.
- *             If set to NULL the first matching element is returned.
- * @param key matching key
- * @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved
- * @return found entry or NULL in case no matching entry was found in the dictionary
- */
-AVDictionaryEntry *av_dict_get(FF_CONST_AVUTIL53 AVDictionary *m, const char *key,
-                               const AVDictionaryEntry *prev, int flags);
-
-/**
- * Get number of entries in dictionary.
- *
- * @param m dictionary
- * @return  number of entries in dictionary
- */
-int av_dict_count(const AVDictionary *m);
-
-/**
- * Set the given entry in *pm, overwriting an existing entry.
- *
- * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL
- * a dictionary struct is allocated and put in *pm.
- * @param key entry key to add to *pm (will be av_strduped depending on flags)
- * @param value entry value to add to *pm (will be av_strduped depending on flags).
- *        Passing a NULL value will cause an existing entry to be deleted.
- * @return >= 0 on success otherwise an error code <0
- */
-int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags);
-
-/**
- * Parse the key/value pairs list and add the parsed entries to a dictionary.
- *
- * In case of failure, all the successfully set entries are stored in
- * *pm. You may need to manually free the created dictionary.
- *
- * @param key_val_sep  a 0-terminated list of characters used to separate
- *                     key from value
- * @param pairs_sep    a 0-terminated list of characters used to separate
- *                     two pairs from each other
- * @param flags        flags to use when adding to dictionary.
- *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL
- *                     are ignored since the key/value tokens will always
- *                     be duplicated.
- * @return             0 on success, negative AVERROR code on failure
- */
-int av_dict_parse_string(AVDictionary **pm, const char *str,
-                         const char *key_val_sep, const char *pairs_sep,
-                         int flags);
+typedef struct AVDictionary {
+    int dummy;
+} AVDictionary;
 
 /**
  * Copy entries from one AVDictionary struct into another.
@@ -158,8 +99,4 @@ void av_dict_copy(AVDictionary **dst, FF
  */
 void av_dict_free(AVDictionary **m);
 
-/**
- * @}
- */
-
 #endif /* AVUTIL_DICT_H */
diff -pruN /usr/include/ffmpeg/libavutil/display.h csrc/libavutil/display.h
--- /usr/include/ffmpeg/libavutil/display.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/display.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2014 Vittorio Giovara <vittorio.giovara@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_DISPLAY_H
-#define AVUTIL_DISPLAY_H
-
-#include <stdint.h>
-
-/**
- * The display transformation matrix specifies an affine transformation that
- * should be applied to video frames for correct presentation. It is compatible
- * with the matrices stored in the ISO/IEC 14496-12 container format.
- *
- * The data is a 3x3 matrix represented as a 9-element array:
- *
- *                                  | a b u |
- *   (a, b, u, c, d, v, x, y, w) -> | c d v |
- *                                  | x y w |
- *
- * All numbers are stored in native endianness, as 16.16 fixed-point values,
- * except for u, v and w, which are stored as 2.30 fixed-point values.
- *
- * The transformation maps a point (p, q) in the source (pre-transformation)
- * frame to the point (p', q') in the destination (post-transformation) frame as
- * follows:
- *               | a b u |
- *   (p, q, 1) . | c d v | = z * (p', q', 1)
- *               | x y w |
- *
- * The transformation can also be more explicitly written in components as
- * follows:
- *   p' = (a * p + c * q + x) / z;
- *   q' = (b * p + d * q + y) / z;
- *   z  =  u * p + v * q + w
- */
-
-/**
- * Extract the rotation component of the transformation matrix.
- *
- * @param matrix the transformation matrix
- * @return the angle (in degrees) by which the transformation rotates the frame.
- *         The angle will be in range [-180.0, 180.0], or NaN if the matrix is
- *         singular.
- *
- * @note floating point numbers are inherently inexact, so callers are
- *       recommended to round the return value to nearest integer before use.
- */
-double av_display_rotation_get(const int32_t matrix[9]);
-
-/**
- * Initialize a transformation matrix describing a pure rotation by the
- * specified angle (in degrees).
- *
- * @param matrix an allocated transformation matrix (will be fully overwritten
- *               by this function)
- * @param angle rotation angle in degrees.
- */
-void av_display_rotation_set(int32_t matrix[9], double angle);
-
-/**
- * Flip the input matrix horizontally and/or vertically.
- *
- * @param matrix an allocated transformation matrix
- * @param hflip whether the matrix should be flipped horizontally
- * @param vflip whether the matrix should be flipped vertically
- */
-void av_display_matrix_flip(int32_t matrix[9], int hflip, int vflip);
-
-#endif /* AVUTIL_DISPLAY_H */
diff -pruN /usr/include/ffmpeg/libavutil/downmix_info.h csrc/libavutil/downmix_info.h
--- /usr/include/ffmpeg/libavutil/downmix_info.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/downmix_info.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-/*
- * Copyright (c) 2014 Tim Walker <tdskywalker@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_DOWNMIX_INFO_H
-#define AVUTIL_DOWNMIX_INFO_H
-
-#include "frame.h"
-
-/**
- * @file
- * audio downmix medatata
- */
-
-/**
- * @addtogroup lavu_audio
- * @{
- */
-
-/**
- * @defgroup downmix_info Audio downmix metadata
- * @{
- */
-
-/**
- * Possible downmix types.
- */
-enum AVDownmixType {
-    AV_DOWNMIX_TYPE_UNKNOWN, /**< Not indicated. */
-    AV_DOWNMIX_TYPE_LORO,    /**< Lo/Ro 2-channel downmix (Stereo). */
-    AV_DOWNMIX_TYPE_LTRT,    /**< Lt/Rt 2-channel downmix, Dolby Surround compatible. */
-    AV_DOWNMIX_TYPE_DPLII,   /**< Lt/Rt 2-channel downmix, Dolby Pro Logic II compatible. */
-    AV_DOWNMIX_TYPE_NB       /**< Number of downmix types. Not part of ABI. */
-};
-
-/**
- * This structure describes optional metadata relevant to a downmix procedure.
- *
- * All fields are set by the decoder to the value indicated in the audio
- * bitstream (if present), or to a "sane" default otherwise.
- */
-typedef struct AVDownmixInfo {
-    /**
-     * Type of downmix preferred by the mastering engineer.
-     */
-    enum AVDownmixType preferred_downmix_type;
-
-    /**
-     * Absolute scale factor representing the nominal level of the center
-     * channel during a regular downmix.
-     */
-    double center_mix_level;
-
-    /**
-     * Absolute scale factor representing the nominal level of the center
-     * channel during an Lt/Rt compatible downmix.
-     */
-    double center_mix_level_ltrt;
-
-    /**
-     * Absolute scale factor representing the nominal level of the surround
-     * channels during a regular downmix.
-     */
-    double surround_mix_level;
-
-    /**
-     * Absolute scale factor representing the nominal level of the surround
-     * channels during an Lt/Rt compatible downmix.
-     */
-    double surround_mix_level_ltrt;
-
-    /**
-     * Absolute scale factor representing the level at which the LFE data is
-     * mixed into L/R channels during downmixing.
-     */
-    double lfe_mix_level;
-} AVDownmixInfo;
-
-/**
- * Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing.
- *
- * If the side data is absent, it is created and added to the frame.
- *
- * @param frame the frame for which the side data is to be obtained or created
- *
- * @return the AVDownmixInfo structure to be edited by the caller, or NULL if
- *         the structure cannot be allocated.
- */
-AVDownmixInfo *av_downmix_info_update_side_data(AVFrame *frame);
-
-/**
- * @}
- */
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_DOWNMIX_INFO_H */
diff -pruN /usr/include/ffmpeg/libavutil/error.h csrc/libavutil/error.h
--- /usr/include/ffmpeg/libavutil/error.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/error.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,117 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * error code definitions
- */
-
-#ifndef AVUTIL_ERROR_H
-#define AVUTIL_ERROR_H
-
-#include <errno.h>
-#include <stddef.h>
-
-/**
- * @addtogroup lavu_error
- *
- * @{
- */
-
-
-/* error handling */
-#if EDOM > 0
-#define AVERROR(e) (-(e))   ///< Returns a negative error code from a POSIX error code, to return from library functions.
-#define AVUNERROR(e) (-(e)) ///< Returns a POSIX error code from a library function error return value.
-#else
-/* Some platforms have E* and errno already negated. */
-#define AVERROR(e) (e)
-#define AVUNERROR(e) (e)
-#endif
-
-#define FFERRTAG(a, b, c, d) (-(int)MKTAG(a, b, c, d))
-
-#define AVERROR_BSF_NOT_FOUND      FFERRTAG(0xF8,'B','S','F') ///< Bitstream filter not found
-#define AVERROR_BUG                FFERRTAG( 'B','U','G','!') ///< Internal bug, also see AVERROR_BUG2
-#define AVERROR_BUFFER_TOO_SMALL   FFERRTAG( 'B','U','F','S') ///< Buffer too small
-#define AVERROR_DECODER_NOT_FOUND  FFERRTAG(0xF8,'D','E','C') ///< Decoder not found
-#define AVERROR_DEMUXER_NOT_FOUND  FFERRTAG(0xF8,'D','E','M') ///< Demuxer not found
-#define AVERROR_ENCODER_NOT_FOUND  FFERRTAG(0xF8,'E','N','C') ///< Encoder not found
-#define AVERROR_EOF                FFERRTAG( 'E','O','F',' ') ///< End of file
-#define AVERROR_EXIT               FFERRTAG( 'E','X','I','T') ///< Immediate exit was requested; the called function should not be restarted
-#define AVERROR_EXTERNAL           FFERRTAG( 'E','X','T',' ') ///< Generic error in an external library
-#define AVERROR_FILTER_NOT_FOUND   FFERRTAG(0xF8,'F','I','L') ///< Filter not found
-#define AVERROR_INVALIDDATA        FFERRTAG( 'I','N','D','A') ///< Invalid data found when processing input
-#define AVERROR_MUXER_NOT_FOUND    FFERRTAG(0xF8,'M','U','X') ///< Muxer not found
-#define AVERROR_OPTION_NOT_FOUND   FFERRTAG(0xF8,'O','P','T') ///< Option not found
-#define AVERROR_PATCHWELCOME       FFERRTAG( 'P','A','W','E') ///< Not yet implemented in FFmpeg, patches welcome
-#define AVERROR_PROTOCOL_NOT_FOUND FFERRTAG(0xF8,'P','R','O') ///< Protocol not found
-
-#define AVERROR_STREAM_NOT_FOUND   FFERRTAG(0xF8,'S','T','R') ///< Stream not found
-/**
- * This is semantically identical to AVERROR_BUG
- * it has been introduced in Libav after our AVERROR_BUG and with a modified value.
- */
-#define AVERROR_BUG2               FFERRTAG( 'B','U','G',' ')
-#define AVERROR_UNKNOWN            FFERRTAG( 'U','N','K','N') ///< Unknown error, typically from an external library
-#define AVERROR_EXPERIMENTAL       (-0x2bb2afa8) ///< Requested feature is flagged experimental. Set strict_std_compliance if you really want to use it.
-
-#define AV_ERROR_MAX_STRING_SIZE 64
-
-/**
- * Put a description of the AVERROR code errnum in errbuf.
- * In case of failure the global variable errno is set to indicate the
- * error. Even in case of failure av_strerror() will print a generic
- * error message indicating the errnum provided to errbuf.
- *
- * @param errnum      error code to describe
- * @param errbuf      buffer to which description is written
- * @param errbuf_size the size in bytes of errbuf
- * @return 0 on success, a negative value if a description for errnum
- * cannot be found
- */
-int av_strerror(int errnum, char *errbuf, size_t errbuf_size);
-
-/**
- * Fill the provided buffer with a string containing an error string
- * corresponding to the AVERROR code errnum.
- *
- * @param errbuf         a buffer
- * @param errbuf_size    size in bytes of errbuf
- * @param errnum         error code to describe
- * @return the buffer in input, filled with the error description
- * @see av_strerror()
- */
-static inline char *av_make_error_string(char *errbuf, size_t errbuf_size, int errnum)
-{
-    av_strerror(errnum, errbuf, errbuf_size);
-    return errbuf;
-}
-
-/**
- * Convenience macro, the return value should be used only directly in
- * function arguments but never stand-alone.
- */
-#define av_err2str(errnum) \
-    av_make_error_string((char[AV_ERROR_MAX_STRING_SIZE]){0}, AV_ERROR_MAX_STRING_SIZE, errnum)
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_ERROR_H */
diff -pruN /usr/include/ffmpeg/libavutil/eval.h csrc/libavutil/eval.h
--- /usr/include/ffmpeg/libavutil/eval.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/eval.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,113 +0,0 @@
-/*
- * Copyright (c) 2002 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * simple arithmetic expression evaluator
- */
-
-#ifndef AVUTIL_EVAL_H
-#define AVUTIL_EVAL_H
-
-#include "avutil.h"
-
-typedef struct AVExpr AVExpr;
-
-/**
- * Parse and evaluate an expression.
- * Note, this is significantly slower than av_expr_eval().
- *
- * @param res a pointer to a double where is put the result value of
- * the expression, or NAN in case of error
- * @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
- * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
- * @param const_values a zero terminated array of values for the identifiers from const_names
- * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
- * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
- * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
- * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
- * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
- * @param log_ctx parent logging context
- * @return >= 0 in case of success, a negative value corresponding to an
- * AVERROR code otherwise
- */
-int av_expr_parse_and_eval(double *res, const char *s,
-                           const char * const *const_names, const double *const_values,
-                           const char * const *func1_names, double (* const *funcs1)(void *, double),
-                           const char * const *func2_names, double (* const *funcs2)(void *, double, double),
-                           void *opaque, int log_offset, void *log_ctx);
-
-/**
- * Parse an expression.
- *
- * @param expr a pointer where is put an AVExpr containing the parsed
- * value in case of successful parsing, or NULL otherwise.
- * The pointed to AVExpr must be freed with av_expr_free() by the user
- * when it is not needed anymore.
- * @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
- * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
- * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
- * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
- * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
- * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
- * @param log_ctx parent logging context
- * @return >= 0 in case of success, a negative value corresponding to an
- * AVERROR code otherwise
- */
-int av_expr_parse(AVExpr **expr, const char *s,
-                  const char * const *const_names,
-                  const char * const *func1_names, double (* const *funcs1)(void *, double),
-                  const char * const *func2_names, double (* const *funcs2)(void *, double, double),
-                  int log_offset, void *log_ctx);
-
-/**
- * Evaluate a previously parsed expression.
- *
- * @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names
- * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
- * @return the value of the expression
- */
-double av_expr_eval(AVExpr *e, const double *const_values, void *opaque);
-
-/**
- * Free a parsed expression previously created with av_expr_parse().
- */
-void av_expr_free(AVExpr *e);
-
-/**
- * Parse the string in numstr and return its value as a double. If
- * the string is empty, contains only whitespaces, or does not contain
- * an initial substring that has the expected syntax for a
- * floating-point number, no conversion is performed. In this case,
- * returns a value of zero and the value returned in tail is the value
- * of numstr.
- *
- * @param numstr a string representing a number, may contain one of
- * the International System number postfixes, for example 'K', 'M',
- * 'G'. If 'i' is appended after the postfix, powers of 2 are used
- * instead of powers of 10. The 'B' postfix multiplies the value for
- * 8, and can be appended after another postfix or used alone. This
- * allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.
- * @param tail if non-NULL puts here the pointer to the char next
- * after the last parsed character
- */
-double av_strtod(const char *numstr, char **tail);
-
-#endif /* AVUTIL_EVAL_H */
diff -pruN /usr/include/ffmpeg/libavutil/fifo.h csrc/libavutil/fifo.h
--- /usr/include/ffmpeg/libavutil/fifo.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/fifo.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,158 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * a very simple circular buffer FIFO implementation
- */
-
-#ifndef AVUTIL_FIFO_H
-#define AVUTIL_FIFO_H
-
-#include <stdint.h>
-#include "avutil.h"
-#include "attributes.h"
-
-typedef struct AVFifoBuffer {
-    uint8_t *buffer;
-    uint8_t *rptr, *wptr, *end;
-    uint32_t rndx, wndx;
-} AVFifoBuffer;
-
-/**
- * Initialize an AVFifoBuffer.
- * @param size of FIFO
- * @return AVFifoBuffer or NULL in case of memory allocation failure
- */
-AVFifoBuffer *av_fifo_alloc(unsigned int size);
-
-/**
- * Initialize an AVFifoBuffer.
- * @param nmemb number of elements
- * @param size  size of the single element
- * @return AVFifoBuffer or NULL in case of memory allocation failure
- */
-AVFifoBuffer *av_fifo_alloc_array(size_t nmemb, size_t size);
-
-/**
- * Free an AVFifoBuffer.
- * @param f AVFifoBuffer to free
- */
-void av_fifo_free(AVFifoBuffer *f);
-
-/**
- * Free an AVFifoBuffer and reset pointer to NULL.
- * @param f AVFifoBuffer to free
- */
-void av_fifo_freep(AVFifoBuffer **f);
-
-/**
- * Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.
- * @param f AVFifoBuffer to reset
- */
-void av_fifo_reset(AVFifoBuffer *f);
-
-/**
- * Return the amount of data in bytes in the AVFifoBuffer, that is the
- * amount of data you can read from it.
- * @param f AVFifoBuffer to read from
- * @return size
- */
-int av_fifo_size(FF_CONST_AVUTIL53 AVFifoBuffer *f);
-
-/**
- * Return the amount of space in bytes in the AVFifoBuffer, that is the
- * amount of data you can write into it.
- * @param f AVFifoBuffer to write into
- * @return size
- */
-int av_fifo_space(FF_CONST_AVUTIL53 AVFifoBuffer *f);
-
-/**
- * Feed data from an AVFifoBuffer to a user-supplied callback.
- * @param f AVFifoBuffer to read from
- * @param buf_size number of bytes to read
- * @param func generic read function
- * @param dest data destination
- */
-int av_fifo_generic_read(AVFifoBuffer *f, void *dest, int buf_size, void (*func)(void*, void*, int));
-
-/**
- * Feed data from a user-supplied callback to an AVFifoBuffer.
- * @param f AVFifoBuffer to write to
- * @param src data source; non-const since it may be used as a
- * modifiable context by the function defined in func
- * @param size number of bytes to write
- * @param func generic write function; the first parameter is src,
- * the second is dest_buf, the third is dest_buf_size.
- * func must return the number of bytes written to dest_buf, or <= 0 to
- * indicate no more data available to write.
- * If func is NULL, src is interpreted as a simple byte array for source data.
- * @return the number of bytes written to the FIFO
- */
-int av_fifo_generic_write(AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int));
-
-/**
- * Resize an AVFifoBuffer.
- * In case of reallocation failure, the old FIFO is kept unchanged.
- *
- * @param f AVFifoBuffer to resize
- * @param size new AVFifoBuffer size in bytes
- * @return <0 for failure, >=0 otherwise
- */
-int av_fifo_realloc2(AVFifoBuffer *f, unsigned int size);
-
-/**
- * Enlarge an AVFifoBuffer.
- * In case of reallocation failure, the old FIFO is kept unchanged.
- * The new fifo size may be larger than the requested size.
- *
- * @param f AVFifoBuffer to resize
- * @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()
- * @return <0 for failure, >=0 otherwise
- */
-int av_fifo_grow(AVFifoBuffer *f, unsigned int additional_space);
-
-/**
- * Read and discard the specified amount of data from an AVFifoBuffer.
- * @param f AVFifoBuffer to read from
- * @param size amount of data to read in bytes
- */
-void av_fifo_drain(AVFifoBuffer *f, int size);
-
-/**
- * Return a pointer to the data stored in a FIFO buffer at a certain offset.
- * The FIFO buffer is not modified.
- *
- * @param f    AVFifoBuffer to peek at, f must be non-NULL
- * @param offs an offset in bytes, its absolute value must be less
- *             than the used buffer size or the returned pointer will
- *             point outside to the buffer data.
- *             The used buffer size can be checked with av_fifo_size().
- */
-static inline uint8_t *av_fifo_peek2(const AVFifoBuffer *f, int offs)
-{
-    uint8_t *ptr = f->rptr + offs;
-    if (ptr >= f->end)
-        ptr = f->buffer + (ptr - f->end);
-    else if (ptr < f->buffer)
-        ptr = f->end - (f->buffer - ptr);
-    return ptr;
-}
-
-#endif /* AVUTIL_FIFO_H */
diff -pruN /usr/include/ffmpeg/libavutil/file.h csrc/libavutil/file.h
--- /usr/include/ffmpeg/libavutil/file.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/file.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_FILE_H
-#define AVUTIL_FILE_H
-
-#include <stdint.h>
-
-#include "avutil.h"
-
-/**
- * @file
- * Misc file utilities.
- */
-
-/**
- * Read the file with name filename, and put its content in a newly
- * allocated buffer or map it with mmap() when available.
- * In case of success set *bufptr to the read or mmapped buffer, and
- * *size to the size in bytes of the buffer in *bufptr.
- * The returned buffer must be released with av_file_unmap().
- *
- * @param log_offset loglevel offset used for logging
- * @param log_ctx context used for logging
- * @return a non negative number in case of success, a negative value
- * corresponding to an AVERROR error code in case of failure
- */
-int av_file_map(const char *filename, uint8_t **bufptr, size_t *size,
-                int log_offset, void *log_ctx);
-
-/**
- * Unmap or free the buffer bufptr created by av_file_map().
- *
- * @param size size in bytes of bufptr, must be the same as returned
- * by av_file_map()
- */
-void av_file_unmap(uint8_t *bufptr, size_t size);
-
-/**
- * Wrapper to work around the lack of mkstemp() on mingw.
- * Also, tries to create file in /tmp first, if possible.
- * *prefix can be a character constant; *filename will be allocated internally.
- * @return file descriptor of opened file (or -1 on error)
- * and opened file name in **filename.
- * @note On very old libcs it is necessary to set a secure umask before
- *       calling this, av_tempfile() can't call umask itself as it is used in
- *       libraries and could interfere with the calling application.
- */
-int av_tempfile(const char *prefix, char **filename, int log_offset, void *log_ctx);
-
-#endif /* AVUTIL_FILE_H */
diff -pruN /usr/include/ffmpeg/libavutil/frame.h csrc/libavutil/frame.h
--- /usr/include/ffmpeg/libavutil/frame.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/frame.h	2014-10-20 12:29:23.177883182 +0200
@@ -1,27 +1,3 @@
-/*
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * @ingroup lavu_frame
- * reference-counted frame API
- */
 
 #ifndef AVUTIL_FRAME_H
 #define AVUTIL_FRAME_H
@@ -85,10 +61,7 @@ enum AVFrameSideDataType {
 };
 
 typedef struct AVFrameSideData {
-    enum AVFrameSideDataType type;
-    uint8_t *data;
-    int      size;
-    AVDictionary *metadata;
+    int dummy;
 } AVFrameSideData;
 
 /**
@@ -194,7 +167,6 @@ typedef struct AVFrame {
     enum AVPictureType pict_type;
 
 #if FF_API_AVFRAME_LAVC
-    attribute_deprecated
     uint8_t *base[AV_NUM_DATA_POINTERS];
 #endif
 
@@ -235,28 +207,23 @@ typedef struct AVFrame {
     int quality;
 
 #if FF_API_AVFRAME_LAVC
-    attribute_deprecated
     int reference;
 
     /**
      * QP table
      */
-    attribute_deprecated
     int8_t *qscale_table;
     /**
      * QP store stride
      */
-    attribute_deprecated
     int qstride;
 
-    attribute_deprecated
     int qscale_type;
 
     /**
      * mbskip_table[mb]>=1 if MB didn't change
      * stride= mb_width = (width+15)>>4
      */
-    attribute_deprecated
     uint8_t *mbskip_table;
 
     /**
@@ -275,20 +242,17 @@ typedef struct AVFrame {
      * macroblock type table
      * mb_type_base + mb_width + 2
      */
-    attribute_deprecated
     uint32_t *mb_type;
 
     /**
      * DCT coefficients
      */
-    attribute_deprecated
     short *dct_coeff;
 
     /**
      * motion reference frame index
      * the order in which these are stored can depend on the codec.
      */
-    attribute_deprecated
     int8_t *ref_index[2];
 #endif
 
@@ -303,7 +267,6 @@ typedef struct AVFrame {
     uint64_t error[AV_NUM_DATA_POINTERS];
 
 #if FF_API_AVFRAME_LAVC
-    attribute_deprecated
     int type;
 #endif
 
@@ -329,13 +292,11 @@ typedef struct AVFrame {
     int palette_has_changed;
 
 #if FF_API_AVFRAME_LAVC
-    attribute_deprecated
     int buffer_hints;
 
     /**
      * Pan scan.
      */
-    attribute_deprecated
     struct AVPanScan *pan_scan;
 #endif
 
@@ -354,11 +315,9 @@ typedef struct AVFrame {
     /**
      * @deprecated this field is unused
      */
-    attribute_deprecated void *hwaccel_picture_private;
+    void *hwaccel_picture_private;
 
-    attribute_deprecated
     struct AVCodecContext *owner;
-    attribute_deprecated
     void *thread_opaque;
 
     /**
@@ -532,203 +491,4 @@ typedef struct AVFrame {
     AVBufferRef *qp_table_buf;
 } AVFrame;
 
-/**
- * Accessors for some AVFrame fields.
- * The position of these field in the structure is not part of the ABI,
- * they should not be accessed directly outside libavcodec.
- */
-int64_t av_frame_get_best_effort_timestamp(const AVFrame *frame);
-void    av_frame_set_best_effort_timestamp(AVFrame *frame, int64_t val);
-int64_t av_frame_get_pkt_duration         (const AVFrame *frame);
-void    av_frame_set_pkt_duration         (AVFrame *frame, int64_t val);
-int64_t av_frame_get_pkt_pos              (const AVFrame *frame);
-void    av_frame_set_pkt_pos              (AVFrame *frame, int64_t val);
-int64_t av_frame_get_channel_layout       (const AVFrame *frame);
-void    av_frame_set_channel_layout       (AVFrame *frame, int64_t val);
-int     av_frame_get_channels             (const AVFrame *frame);
-void    av_frame_set_channels             (AVFrame *frame, int     val);
-int     av_frame_get_sample_rate          (const AVFrame *frame);
-void    av_frame_set_sample_rate          (AVFrame *frame, int     val);
-AVDictionary *av_frame_get_metadata       (const AVFrame *frame);
-void          av_frame_set_metadata       (AVFrame *frame, AVDictionary *val);
-int     av_frame_get_decode_error_flags   (const AVFrame *frame);
-void    av_frame_set_decode_error_flags   (AVFrame *frame, int     val);
-int     av_frame_get_pkt_size(const AVFrame *frame);
-void    av_frame_set_pkt_size(AVFrame *frame, int val);
-AVDictionary **avpriv_frame_get_metadatap(AVFrame *frame);
-int8_t *av_frame_get_qp_table(AVFrame *f, int *stride, int *type);
-int av_frame_set_qp_table(AVFrame *f, AVBufferRef *buf, int stride, int type);
-enum AVColorSpace av_frame_get_colorspace(const AVFrame *frame);
-void    av_frame_set_colorspace(AVFrame *frame, enum AVColorSpace val);
-enum AVColorRange av_frame_get_color_range(const AVFrame *frame);
-void    av_frame_set_color_range(AVFrame *frame, enum AVColorRange val);
-
-/**
- * Get the name of a colorspace.
- * @return a static string identifying the colorspace; can be NULL.
- */
-const char *av_get_colorspace_name(enum AVColorSpace val);
-
-/**
- * Allocate an AVFrame and set its fields to default values.  The resulting
- * struct must be freed using av_frame_free().
- *
- * @return An AVFrame filled with default values or NULL on failure.
- *
- * @note this only allocates the AVFrame itself, not the data buffers. Those
- * must be allocated through other means, e.g. with av_frame_get_buffer() or
- * manually.
- */
-AVFrame *av_frame_alloc(void);
-
-/**
- * Free the frame and any dynamically allocated objects in it,
- * e.g. extended_data. If the frame is reference counted, it will be
- * unreferenced first.
- *
- * @param frame frame to be freed. The pointer will be set to NULL.
- */
-void av_frame_free(AVFrame **frame);
-
-/**
- * Set up a new reference to the data described by the source frame.
- *
- * Copy frame properties from src to dst and create a new reference for each
- * AVBufferRef from src.
- *
- * If src is not reference counted, new buffers are allocated and the data is
- * copied.
- *
- * @return 0 on success, a negative AVERROR on error
- */
-int av_frame_ref(AVFrame *dst, const AVFrame *src);
-
-/**
- * Create a new frame that references the same data as src.
- *
- * This is a shortcut for av_frame_alloc()+av_frame_ref().
- *
- * @return newly created AVFrame on success, NULL on error.
- */
-AVFrame *av_frame_clone(const AVFrame *src);
-
-/**
- * Unreference all the buffers referenced by frame and reset the frame fields.
- */
-void av_frame_unref(AVFrame *frame);
-
-/**
- * Move everythnig contained in src to dst and reset src.
- */
-void av_frame_move_ref(AVFrame *dst, AVFrame *src);
-
-/**
- * Allocate new buffer(s) for audio or video data.
- *
- * The following fields must be set on frame before calling this function:
- * - format (pixel format for video, sample format for audio)
- * - width and height for video
- * - nb_samples and channel_layout for audio
- *
- * This function will fill AVFrame.data and AVFrame.buf arrays and, if
- * necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.
- * For planar formats, one buffer will be allocated for each plane.
- *
- * @param frame frame in which to store the new buffers.
- * @param align required buffer size alignment
- *
- * @return 0 on success, a negative AVERROR on error.
- */
-int av_frame_get_buffer(AVFrame *frame, int align);
-
-/**
- * Check if the frame data is writable.
- *
- * @return A positive value if the frame data is writable (which is true if and
- * only if each of the underlying buffers has only one reference, namely the one
- * stored in this frame). Return 0 otherwise.
- *
- * If 1 is returned the answer is valid until av_buffer_ref() is called on any
- * of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).
- *
- * @see av_frame_make_writable(), av_buffer_is_writable()
- */
-int av_frame_is_writable(AVFrame *frame);
-
-/**
- * Ensure that the frame data is writable, avoiding data copy if possible.
- *
- * Do nothing if the frame is writable, allocate new buffers and copy the data
- * if it is not.
- *
- * @return 0 on success, a negative AVERROR on error.
- *
- * @see av_frame_is_writable(), av_buffer_is_writable(),
- * av_buffer_make_writable()
- */
-int av_frame_make_writable(AVFrame *frame);
-
-/**
- * Copy the frame data from src to dst.
- *
- * This function does not allocate anything, dst must be already initialized and
- * allocated with the same parameters as src.
- *
- * This function only copies the frame data (i.e. the contents of the data /
- * extended data arrays), not any other properties.
- *
- * @return >= 0 on success, a negative AVERROR on error.
- */
-int av_frame_copy(AVFrame *dst, const AVFrame *src);
-
-/**
- * Copy only "metadata" fields from src to dst.
- *
- * Metadata for the purpose of this function are those fields that do not affect
- * the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample
- * aspect ratio (for video), but not width/height or channel layout.
- * Side data is also copied.
- */
-int av_frame_copy_props(AVFrame *dst, const AVFrame *src);
-
-/**
- * Get the buffer reference a given data plane is stored in.
- *
- * @param plane index of the data plane of interest in frame->extended_data.
- *
- * @return the buffer reference that contains the plane or NULL if the input
- * frame is not valid.
- */
-AVBufferRef *av_frame_get_plane_buffer(AVFrame *frame, int plane);
-
-/**
- * Add a new side data to a frame.
- *
- * @param frame a frame to which the side data should be added
- * @param type type of the added side data
- * @param size size of the side data
- *
- * @return newly added side data on success, NULL on error
- */
-AVFrameSideData *av_frame_new_side_data(AVFrame *frame,
-                                        enum AVFrameSideDataType type,
-                                        int size);
-
-/**
- * @return a pointer to the side data of a given type on success, NULL if there
- * is no side data with such type in this frame.
- */
-AVFrameSideData *av_frame_get_side_data(const AVFrame *frame,
-                                        enum AVFrameSideDataType type);
-
-/**
- * If side data of the supplied type exists in the frame, free it and remove it
- * from the frame.
- */
-void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type);
-
-/**
- * @}
- */
-
 #endif /* AVUTIL_FRAME_H */
diff -pruN /usr/include/ffmpeg/libavutil/hash.h csrc/libavutil/hash.h
--- /usr/include/ffmpeg/libavutil/hash.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/hash.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2013 Reimar Dffinger <Reimar.Doeffinger@gmx.de>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_HASH_H
-#define AVUTIL_HASH_H
-
-#include <stdint.h>
-
-struct AVHashContext;
-
-/**
- * Allocate a hash context for the algorithm specified by name.
- *
- * @return  >= 0 for success, a negative error code for failure
- * @note  The context is not initialized, you must call av_hash_init().
- */
-int av_hash_alloc(struct AVHashContext **ctx, const char *name);
-
-/**
- * Get the names of available hash algorithms.
- *
- * This function can be used to enumerate the algorithms.
- *
- * @param i  index of the hash algorithm, starting from 0
- * @return   a pointer to a static string or NULL if i is out of range
- */
-const char *av_hash_names(int i);
-
-/**
- * Get the name of the algorithm corresponding to the given hash context.
- */
-const char *av_hash_get_name(const struct AVHashContext *ctx);
-
-/**
- * Maximum value that av_hash_get_size will currently return.
- *
- * You can use this if you absolutely want or need to use static allocation
- * and are fine with not supporting hashes newly added to libavutil without
- * recompilation.
- * Note that you still need to check against av_hash_get_size, adding new hashes
- * with larger sizes will not be considered an ABI change and should not cause
- * your code to overflow a buffer.
- */
-#define AV_HASH_MAX_SIZE 64
-
-/**
- * Get the size of the resulting hash value in bytes.
- *
- * The pointer passed to av_hash_final have space for at least this many bytes.
- */
-int av_hash_get_size(const struct AVHashContext *ctx);
-
-/**
- * Initialize or reset a hash context.
- */
-void av_hash_init(struct AVHashContext *ctx);
-
-/**
- * Update a hash context with additional data.
- */
-void av_hash_update(struct AVHashContext *ctx, const uint8_t *src, int len);
-
-/**
- * Finalize a hash context and compute the actual hash value.
- */
-void av_hash_final(struct AVHashContext *ctx, uint8_t *dst);
-
-/**
- * Finalize a hash context and compute the actual hash value.
- * If size is smaller than the hash size, the hash is truncated;
- * if size is larger, the buffer is padded with 0.
- */
-void av_hash_final_bin(struct AVHashContext *ctx, uint8_t *dst, int size);
-
-/**
- * Finalize a hash context and compute the actual hash value as a hex string.
- * The string is always 0-terminated.
- * If size is smaller than 2 * hash_size + 1, the hex string is truncated.
- */
-void av_hash_final_hex(struct AVHashContext *ctx, uint8_t *dst, int size);
-
-/**
- * Finalize a hash context and compute the actual hash value as a base64 string.
- * The string is always 0-terminated.
- * If size is smaller than AV_BASE64_SIZE(hash_size), the base64 string is
- * truncated.
- */
-void av_hash_final_b64(struct AVHashContext *ctx, uint8_t *dst, int size);
-
-/**
- * Free hash context.
- */
-void av_hash_freep(struct AVHashContext **ctx);
-
-#endif /* AVUTIL_HASH_H */
diff -pruN /usr/include/ffmpeg/libavutil/hmac.h csrc/libavutil/hmac.h
--- /usr/include/ffmpeg/libavutil/hmac.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/hmac.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2012 Martin Storsjo
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_HMAC_H
-#define AVUTIL_HMAC_H
-
-#include <stdint.h>
-
-/**
- * @defgroup lavu_hmac HMAC
- * @ingroup lavu_crypto
- * @{
- */
-
-enum AVHMACType {
-    AV_HMAC_MD5,
-    AV_HMAC_SHA1,
-    AV_HMAC_SHA224 = 10,
-    AV_HMAC_SHA256,
-    AV_HMAC_SHA384,
-    AV_HMAC_SHA512,
-};
-
-typedef struct AVHMAC AVHMAC;
-
-/**
- * Allocate an AVHMAC context.
- * @param type The hash function used for the HMAC.
- */
-AVHMAC *av_hmac_alloc(enum AVHMACType type);
-
-/**
- * Free an AVHMAC context.
- * @param ctx The context to free, may be NULL
- */
-void av_hmac_free(AVHMAC *ctx);
-
-/**
- * Initialize an AVHMAC context with an authentication key.
- * @param ctx    The HMAC context
- * @param key    The authentication key
- * @param keylen The length of the key, in bytes
- */
-void av_hmac_init(AVHMAC *ctx, const uint8_t *key, unsigned int keylen);
-
-/**
- * Hash data with the HMAC.
- * @param ctx  The HMAC context
- * @param data The data to hash
- * @param len  The length of the data, in bytes
- */
-void av_hmac_update(AVHMAC *ctx, const uint8_t *data, unsigned int len);
-
-/**
- * Finish hashing and output the HMAC digest.
- * @param ctx    The HMAC context
- * @param out    The output buffer to write the digest into
- * @param outlen The length of the out buffer, in bytes
- * @return       The number of bytes written to out, or a negative error code.
- */
-int av_hmac_final(AVHMAC *ctx, uint8_t *out, unsigned int outlen);
-
-/**
- * Hash an array of data with a key.
- * @param ctx    The HMAC context
- * @param data   The data to hash
- * @param len    The length of the data, in bytes
- * @param key    The authentication key
- * @param keylen The length of the key, in bytes
- * @param out    The output buffer to write the digest into
- * @param outlen The length of the out buffer, in bytes
- * @return       The number of bytes written to out, or a negative error code.
- */
-int av_hmac_calc(AVHMAC *ctx, const uint8_t *data, unsigned int len,
-                 const uint8_t *key, unsigned int keylen,
-                 uint8_t *out, unsigned int outlen);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_HMAC_H */
diff -pruN /usr/include/ffmpeg/libavutil/imgutils.h csrc/libavutil/imgutils.h
--- /usr/include/ffmpeg/libavutil/imgutils.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/imgutils.h	2014-10-20 12:31:38.300350667 +0200
@@ -20,68 +20,6 @@
 #define AVUTIL_IMGUTILS_H
 
 /**
- * @file
- * misc image utilities
- *
- * @addtogroup lavu_picture
- * @{
- */
-
-#include "avutil.h"
-#include "pixdesc.h"
-#include "rational.h"
-
-/**
- * Compute the max pixel step for each plane of an image with a
- * format described by pixdesc.
- *
- * The pixel step is the distance in bytes between the first byte of
- * the group of bytes which describe a pixel component and the first
- * byte of the successive group in the same plane for the same
- * component.
- *
- * @param max_pixsteps an array which is filled with the max pixel step
- * for each plane. Since a plane may contain different pixel
- * components, the computed max_pixsteps[plane] is relative to the
- * component in the plane with the max pixel step.
- * @param max_pixstep_comps an array which is filled with the component
- * for each plane which has the max pixel step. May be NULL.
- */
-void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4],
-                                const AVPixFmtDescriptor *pixdesc);
-
-/**
- * Compute the size of an image line with format pix_fmt and width
- * width for the plane plane.
- *
- * @return the computed size in bytes
- */
-int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane);
-
-/**
- * Fill plane linesizes for an image with pixel format pix_fmt and
- * width width.
- *
- * @param linesizes array to be filled with the linesize for each plane
- * @return >= 0 in case of success, a negative error code otherwise
- */
-int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width);
-
-/**
- * Fill plane data pointers for an image with pixel format pix_fmt and
- * height height.
- *
- * @param data pointers array to be filled with the pointer for each image plane
- * @param ptr the pointer to a buffer which will contain the image
- * @param linesizes the array containing the linesize for each
- * plane, should be filled by av_image_fill_linesizes()
- * @return the size in bytes required for the image buffer, a negative
- * error code in case of failure
- */
-int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height,
-                           uint8_t *ptr, const int linesizes[4]);
-
-/**
  * Allocate an image with size w and h and pixel format pix_fmt, and
  * fill pointers and linesizes accordingly.
  * The allocated image buffer has to be freed by using
@@ -95,22 +33,6 @@ int av_image_alloc(uint8_t *pointers[4],
                    int w, int h, enum AVPixelFormat pix_fmt, int align);
 
 /**
- * Copy image plane from src to dst.
- * That is, copy "height" number of lines of "bytewidth" bytes each.
- * The first byte of each successive line is separated by *_linesize
- * bytes.
- *
- * bytewidth must be contained by both absolute values of dst_linesize
- * and src_linesize, otherwise the function behavior is undefined.
- *
- * @param dst_linesize linesize for the image plane in dst
- * @param src_linesize linesize for the image plane in src
- */
-void av_image_copy_plane(uint8_t       *dst, int dst_linesize,
-                         const uint8_t *src, int src_linesize,
-                         int bytewidth, int height);
-
-/**
  * Copy image in src_data to dst_data.
  *
  * @param dst_linesizes linesizes for the image in dst_data
@@ -120,96 +42,4 @@ void av_image_copy(uint8_t *dst_data[4],
                    const uint8_t *src_data[4], const int src_linesizes[4],
                    enum AVPixelFormat pix_fmt, int width, int height);
 
-/**
- * Setup the data pointers and linesizes based on the specified image
- * parameters and the provided array.
- *
- * The fields of the given image are filled in by using the src
- * address which points to the image data buffer. Depending on the
- * specified pixel format, one or multiple image data pointers and
- * line sizes will be set.  If a planar format is specified, several
- * pointers will be set pointing to the different picture planes and
- * the line sizes of the different planes will be stored in the
- * lines_sizes array. Call with src == NULL to get the required
- * size for the src buffer.
- *
- * To allocate the buffer and fill in the dst_data and dst_linesize in
- * one call, use av_image_alloc().
- *
- * @param dst_data      data pointers to be filled in
- * @param dst_linesizes linesizes for the image in dst_data to be filled in
- * @param src           buffer which will contain or contains the actual image data, can be NULL
- * @param pix_fmt       the pixel format of the image
- * @param width         the width of the image in pixels
- * @param height        the height of the image in pixels
- * @param align         the value used in src for linesize alignment
- * @return the size in bytes required for src, a negative error code
- * in case of failure
- */
-int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],
-                         const uint8_t *src,
-                         enum AVPixelFormat pix_fmt, int width, int height, int align);
-
-/**
- * Return the size in bytes of the amount of data required to store an
- * image with the given parameters.
- *
- * @param[in] align the assumed linesize alignment
- */
-int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align);
-
-/**
- * Copy image data from an image into a buffer.
- *
- * av_image_get_buffer_size() can be used to compute the required size
- * for the buffer to fill.
- *
- * @param dst           a buffer into which picture data will be copied
- * @param dst_size      the size in bytes of dst
- * @param src_data      pointers containing the source image data
- * @param src_linesizes linesizes for the image in src_data
- * @param pix_fmt       the pixel format of the source image
- * @param width         the width of the source image in pixels
- * @param height        the height of the source image in pixels
- * @param align         the assumed linesize alignment for dst
- * @return the number of bytes written to dst, or a negative value
- * (error code) on error
- */
-int av_image_copy_to_buffer(uint8_t *dst, int dst_size,
-                            const uint8_t * const src_data[4], const int src_linesize[4],
-                            enum AVPixelFormat pix_fmt, int width, int height, int align);
-
-/**
- * Check if the given dimension of an image is valid, meaning that all
- * bytes of the image can be addressed with a signed int.
- *
- * @param w the width of the picture
- * @param h the height of the picture
- * @param log_offset the offset to sum to the log level for logging with log_ctx
- * @param log_ctx the parent logging context, it may be NULL
- * @return >= 0 if valid, a negative error code otherwise
- */
-int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx);
-
-/**
- * Check if the given sample aspect ratio of an image is valid.
- *
- * It is considered invalid if the denominator is 0 or if applying the ratio
- * to the image size would make the smaller dimension less than 1. If the
- * sar numerator is 0, it is considered unknown and will return as valid.
- *
- * @param w width of the image
- * @param h height of the image
- * @param sar sample aspect ratio of the image
- * @return 0 if valid, a negative AVERROR code otherwise
- */
-int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar);
-
-int avpriv_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt);
-
-/**
- * @}
- */
-
-
 #endif /* AVUTIL_IMGUTILS_H */
diff -pruN /usr/include/ffmpeg/libavutil/intfloat.h csrc/libavutil/intfloat.h
--- /usr/include/ffmpeg/libavutil/intfloat.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/intfloat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2011 Mans Rullgard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_INTFLOAT_H
-#define AVUTIL_INTFLOAT_H
-
-#include <stdint.h>
-#include "attributes.h"
-
-union av_intfloat32 {
-    uint32_t i;
-    float    f;
-};
-
-union av_intfloat64 {
-    uint64_t i;
-    double   f;
-};
-
-/**
- * Reinterpret a 32-bit integer as a float.
- */
-static av_always_inline float av_int2float(uint32_t i)
-{
-    union av_intfloat32 v;
-    v.i = i;
-    return v.f;
-}
-
-/**
- * Reinterpret a float as a 32-bit integer.
- */
-static av_always_inline uint32_t av_float2int(float f)
-{
-    union av_intfloat32 v;
-    v.f = f;
-    return v.i;
-}
-
-/**
- * Reinterpret a 64-bit integer as a double.
- */
-static av_always_inline double av_int2double(uint64_t i)
-{
-    union av_intfloat64 v;
-    v.i = i;
-    return v.f;
-}
-
-/**
- * Reinterpret a double as a 64-bit integer.
- */
-static av_always_inline uint64_t av_double2int(double f)
-{
-    union av_intfloat64 v;
-    v.f = f;
-    return v.i;
-}
-
-#endif /* AVUTIL_INTFLOAT_H */
diff -pruN /usr/include/ffmpeg/libavutil/intfloat_readwrite.h csrc/libavutil/intfloat_readwrite.h
--- /usr/include/ffmpeg/libavutil/intfloat_readwrite.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/intfloat_readwrite.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/*
- * copyright (c) 2005 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_INTFLOAT_READWRITE_H
-#define AVUTIL_INTFLOAT_READWRITE_H
-
-#include <stdint.h>
-
-#include "attributes.h"
-#include "version.h"
-
-#if FF_API_INTFLOAT
-/* IEEE 80 bits extended float */
-typedef struct AVExtFloat  {
-    uint8_t exponent[2];
-    uint8_t mantissa[8];
-} AVExtFloat;
-
-attribute_deprecated double av_int2dbl(int64_t v) av_const;
-attribute_deprecated float av_int2flt(int32_t v) av_const;
-attribute_deprecated double av_ext2dbl(const AVExtFloat ext) av_const;
-attribute_deprecated int64_t av_dbl2int(double d) av_const;
-attribute_deprecated int32_t av_flt2int(float d) av_const;
-attribute_deprecated AVExtFloat av_dbl2ext(double d) av_const;
-#endif /* FF_API_INTFLOAT */
-
-#endif /* AVUTIL_INTFLOAT_READWRITE_H */
diff -pruN /usr/include/ffmpeg/libavutil/intreadwrite.h csrc/libavutil/intreadwrite.h
--- /usr/include/ffmpeg/libavutil/intreadwrite.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/intreadwrite.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,621 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_INTREADWRITE_H
-#define AVUTIL_INTREADWRITE_H
-
-#include <stdint.h>
-#include "libavutil/avconfig.h"
-#include "attributes.h"
-#include "bswap.h"
-
-typedef union {
-    uint64_t u64;
-    uint32_t u32[2];
-    uint16_t u16[4];
-    uint8_t  u8 [8];
-    double   f64;
-    float    f32[2];
-} av_alias av_alias64;
-
-typedef union {
-    uint32_t u32;
-    uint16_t u16[2];
-    uint8_t  u8 [4];
-    float    f32;
-} av_alias av_alias32;
-
-typedef union {
-    uint16_t u16;
-    uint8_t  u8 [2];
-} av_alias av_alias16;
-
-/*
- * Arch-specific headers can provide any combination of
- * AV_[RW][BLN](16|24|32|48|64) and AV_(COPY|SWAP|ZERO)(64|128) macros.
- * Preprocessor symbols must be defined, even if these are implemented
- * as inline functions.
- */
-
-#ifdef HAVE_AV_CONFIG_H
-
-#include "config.h"
-
-#if   ARCH_ARM
-#   include "arm/intreadwrite.h"
-#elif ARCH_AVR32
-#   include "avr32/intreadwrite.h"
-#elif ARCH_MIPS
-#   include "mips/intreadwrite.h"
-#elif ARCH_PPC
-#   include "ppc/intreadwrite.h"
-#elif ARCH_TOMI
-#   include "tomi/intreadwrite.h"
-#elif ARCH_X86
-#   include "x86/intreadwrite.h"
-#endif
-
-#endif /* HAVE_AV_CONFIG_H */
-
-/*
- * Map AV_RNXX <-> AV_R[BL]XX for all variants provided by per-arch headers.
- */
-
-#if AV_HAVE_BIGENDIAN
-
-#   if    defined(AV_RN16) && !defined(AV_RB16)
-#       define AV_RB16(p) AV_RN16(p)
-#   elif !defined(AV_RN16) &&  defined(AV_RB16)
-#       define AV_RN16(p) AV_RB16(p)
-#   endif
-
-#   if    defined(AV_WN16) && !defined(AV_WB16)
-#       define AV_WB16(p, v) AV_WN16(p, v)
-#   elif !defined(AV_WN16) &&  defined(AV_WB16)
-#       define AV_WN16(p, v) AV_WB16(p, v)
-#   endif
-
-#   if    defined(AV_RN24) && !defined(AV_RB24)
-#       define AV_RB24(p) AV_RN24(p)
-#   elif !defined(AV_RN24) &&  defined(AV_RB24)
-#       define AV_RN24(p) AV_RB24(p)
-#   endif
-
-#   if    defined(AV_WN24) && !defined(AV_WB24)
-#       define AV_WB24(p, v) AV_WN24(p, v)
-#   elif !defined(AV_WN24) &&  defined(AV_WB24)
-#       define AV_WN24(p, v) AV_WB24(p, v)
-#   endif
-
-#   if    defined(AV_RN32) && !defined(AV_RB32)
-#       define AV_RB32(p) AV_RN32(p)
-#   elif !defined(AV_RN32) &&  defined(AV_RB32)
-#       define AV_RN32(p) AV_RB32(p)
-#   endif
-
-#   if    defined(AV_WN32) && !defined(AV_WB32)
-#       define AV_WB32(p, v) AV_WN32(p, v)
-#   elif !defined(AV_WN32) &&  defined(AV_WB32)
-#       define AV_WN32(p, v) AV_WB32(p, v)
-#   endif
-
-#   if    defined(AV_RN48) && !defined(AV_RB48)
-#       define AV_RB48(p) AV_RN48(p)
-#   elif !defined(AV_RN48) &&  defined(AV_RB48)
-#       define AV_RN48(p) AV_RB48(p)
-#   endif
-
-#   if    defined(AV_WN48) && !defined(AV_WB48)
-#       define AV_WB48(p, v) AV_WN48(p, v)
-#   elif !defined(AV_WN48) &&  defined(AV_WB48)
-#       define AV_WN48(p, v) AV_WB48(p, v)
-#   endif
-
-#   if    defined(AV_RN64) && !defined(AV_RB64)
-#       define AV_RB64(p) AV_RN64(p)
-#   elif !defined(AV_RN64) &&  defined(AV_RB64)
-#       define AV_RN64(p) AV_RB64(p)
-#   endif
-
-#   if    defined(AV_WN64) && !defined(AV_WB64)
-#       define AV_WB64(p, v) AV_WN64(p, v)
-#   elif !defined(AV_WN64) &&  defined(AV_WB64)
-#       define AV_WN64(p, v) AV_WB64(p, v)
-#   endif
-
-#else /* AV_HAVE_BIGENDIAN */
-
-#   if    defined(AV_RN16) && !defined(AV_RL16)
-#       define AV_RL16(p) AV_RN16(p)
-#   elif !defined(AV_RN16) &&  defined(AV_RL16)
-#       define AV_RN16(p) AV_RL16(p)
-#   endif
-
-#   if    defined(AV_WN16) && !defined(AV_WL16)
-#       define AV_WL16(p, v) AV_WN16(p, v)
-#   elif !defined(AV_WN16) &&  defined(AV_WL16)
-#       define AV_WN16(p, v) AV_WL16(p, v)
-#   endif
-
-#   if    defined(AV_RN24) && !defined(AV_RL24)
-#       define AV_RL24(p) AV_RN24(p)
-#   elif !defined(AV_RN24) &&  defined(AV_RL24)
-#       define AV_RN24(p) AV_RL24(p)
-#   endif
-
-#   if    defined(AV_WN24) && !defined(AV_WL24)
-#       define AV_WL24(p, v) AV_WN24(p, v)
-#   elif !defined(AV_WN24) &&  defined(AV_WL24)
-#       define AV_WN24(p, v) AV_WL24(p, v)
-#   endif
-
-#   if    defined(AV_RN32) && !defined(AV_RL32)
-#       define AV_RL32(p) AV_RN32(p)
-#   elif !defined(AV_RN32) &&  defined(AV_RL32)
-#       define AV_RN32(p) AV_RL32(p)
-#   endif
-
-#   if    defined(AV_WN32) && !defined(AV_WL32)
-#       define AV_WL32(p, v) AV_WN32(p, v)
-#   elif !defined(AV_WN32) &&  defined(AV_WL32)
-#       define AV_WN32(p, v) AV_WL32(p, v)
-#   endif
-
-#   if    defined(AV_RN48) && !defined(AV_RL48)
-#       define AV_RL48(p) AV_RN48(p)
-#   elif !defined(AV_RN48) &&  defined(AV_RL48)
-#       define AV_RN48(p) AV_RL48(p)
-#   endif
-
-#   if    defined(AV_WN48) && !defined(AV_WL48)
-#       define AV_WL48(p, v) AV_WN48(p, v)
-#   elif !defined(AV_WN48) &&  defined(AV_WL48)
-#       define AV_WN48(p, v) AV_WL48(p, v)
-#   endif
-
-#   if    defined(AV_RN64) && !defined(AV_RL64)
-#       define AV_RL64(p) AV_RN64(p)
-#   elif !defined(AV_RN64) &&  defined(AV_RL64)
-#       define AV_RN64(p) AV_RL64(p)
-#   endif
-
-#   if    defined(AV_WN64) && !defined(AV_WL64)
-#       define AV_WL64(p, v) AV_WN64(p, v)
-#   elif !defined(AV_WN64) &&  defined(AV_WL64)
-#       define AV_WN64(p, v) AV_WL64(p, v)
-#   endif
-
-#endif /* !AV_HAVE_BIGENDIAN */
-
-/*
- * Define AV_[RW]N helper macros to simplify definitions not provided
- * by per-arch headers.
- */
-
-#if defined(__GNUC__) && !defined(__TI_COMPILER_VERSION__)
-
-union unaligned_64 { uint64_t l; } __attribute__((packed)) av_alias;
-union unaligned_32 { uint32_t l; } __attribute__((packed)) av_alias;
-union unaligned_16 { uint16_t l; } __attribute__((packed)) av_alias;
-
-#   define AV_RN(s, p) (((const union unaligned_##s *) (p))->l)
-#   define AV_WN(s, p, v) ((((union unaligned_##s *) (p))->l) = (v))
-
-#elif defined(__DECC)
-
-#   define AV_RN(s, p) (*((const __unaligned uint##s##_t*)(p)))
-#   define AV_WN(s, p, v) (*((__unaligned uint##s##_t*)(p)) = (v))
-
-#elif AV_HAVE_FAST_UNALIGNED
-
-#   define AV_RN(s, p) (((const av_alias##s*)(p))->u##s)
-#   define AV_WN(s, p, v) (((av_alias##s*)(p))->u##s = (v))
-
-#else
-
-#ifndef AV_RB16
-#   define AV_RB16(x)                           \
-    ((((const uint8_t*)(x))[0] << 8) |          \
-      ((const uint8_t*)(x))[1])
-#endif
-#ifndef AV_WB16
-#   define AV_WB16(p, darg) do {                \
-        unsigned d = (darg);                    \
-        ((uint8_t*)(p))[1] = (d);               \
-        ((uint8_t*)(p))[0] = (d)>>8;            \
-    } while(0)
-#endif
-
-#ifndef AV_RL16
-#   define AV_RL16(x)                           \
-    ((((const uint8_t*)(x))[1] << 8) |          \
-      ((const uint8_t*)(x))[0])
-#endif
-#ifndef AV_WL16
-#   define AV_WL16(p, darg) do {                \
-        unsigned d = (darg);                    \
-        ((uint8_t*)(p))[0] = (d);               \
-        ((uint8_t*)(p))[1] = (d)>>8;            \
-    } while(0)
-#endif
-
-#ifndef AV_RB32
-#   define AV_RB32(x)                                \
-    (((uint32_t)((const uint8_t*)(x))[0] << 24) |    \
-               (((const uint8_t*)(x))[1] << 16) |    \
-               (((const uint8_t*)(x))[2] <<  8) |    \
-                ((const uint8_t*)(x))[3])
-#endif
-#ifndef AV_WB32
-#   define AV_WB32(p, darg) do {                \
-        unsigned d = (darg);                    \
-        ((uint8_t*)(p))[3] = (d);               \
-        ((uint8_t*)(p))[2] = (d)>>8;            \
-        ((uint8_t*)(p))[1] = (d)>>16;           \
-        ((uint8_t*)(p))[0] = (d)>>24;           \
-    } while(0)
-#endif
-
-#ifndef AV_RL32
-#   define AV_RL32(x)                                \
-    (((uint32_t)((const uint8_t*)(x))[3] << 24) |    \
-               (((const uint8_t*)(x))[2] << 16) |    \
-               (((const uint8_t*)(x))[1] <<  8) |    \
-                ((const uint8_t*)(x))[0])
-#endif
-#ifndef AV_WL32
-#   define AV_WL32(p, darg) do {                \
-        unsigned d = (darg);                    \
-        ((uint8_t*)(p))[0] = (d);               \
-        ((uint8_t*)(p))[1] = (d)>>8;            \
-        ((uint8_t*)(p))[2] = (d)>>16;           \
-        ((uint8_t*)(p))[3] = (d)>>24;           \
-    } while(0)
-#endif
-
-#ifndef AV_RB64
-#   define AV_RB64(x)                                   \
-    (((uint64_t)((const uint8_t*)(x))[0] << 56) |       \
-     ((uint64_t)((const uint8_t*)(x))[1] << 48) |       \
-     ((uint64_t)((const uint8_t*)(x))[2] << 40) |       \
-     ((uint64_t)((const uint8_t*)(x))[3] << 32) |       \
-     ((uint64_t)((const uint8_t*)(x))[4] << 24) |       \
-     ((uint64_t)((const uint8_t*)(x))[5] << 16) |       \
-     ((uint64_t)((const uint8_t*)(x))[6] <<  8) |       \
-      (uint64_t)((const uint8_t*)(x))[7])
-#endif
-#ifndef AV_WB64
-#   define AV_WB64(p, darg) do {                \
-        uint64_t d = (darg);                    \
-        ((uint8_t*)(p))[7] = (d);               \
-        ((uint8_t*)(p))[6] = (d)>>8;            \
-        ((uint8_t*)(p))[5] = (d)>>16;           \
-        ((uint8_t*)(p))[4] = (d)>>24;           \
-        ((uint8_t*)(p))[3] = (d)>>32;           \
-        ((uint8_t*)(p))[2] = (d)>>40;           \
-        ((uint8_t*)(p))[1] = (d)>>48;           \
-        ((uint8_t*)(p))[0] = (d)>>56;           \
-    } while(0)
-#endif
-
-#ifndef AV_RL64
-#   define AV_RL64(x)                                   \
-    (((uint64_t)((const uint8_t*)(x))[7] << 56) |       \
-     ((uint64_t)((const uint8_t*)(x))[6] << 48) |       \
-     ((uint64_t)((const uint8_t*)(x))[5] << 40) |       \
-     ((uint64_t)((const uint8_t*)(x))[4] << 32) |       \
-     ((uint64_t)((const uint8_t*)(x))[3] << 24) |       \
-     ((uint64_t)((const uint8_t*)(x))[2] << 16) |       \
-     ((uint64_t)((const uint8_t*)(x))[1] <<  8) |       \
-      (uint64_t)((const uint8_t*)(x))[0])
-#endif
-#ifndef AV_WL64
-#   define AV_WL64(p, darg) do {                \
-        uint64_t d = (darg);                    \
-        ((uint8_t*)(p))[0] = (d);               \
-        ((uint8_t*)(p))[1] = (d)>>8;            \
-        ((uint8_t*)(p))[2] = (d)>>16;           \
-        ((uint8_t*)(p))[3] = (d)>>24;           \
-        ((uint8_t*)(p))[4] = (d)>>32;           \
-        ((uint8_t*)(p))[5] = (d)>>40;           \
-        ((uint8_t*)(p))[6] = (d)>>48;           \
-        ((uint8_t*)(p))[7] = (d)>>56;           \
-    } while(0)
-#endif
-
-#if AV_HAVE_BIGENDIAN
-#   define AV_RN(s, p)    AV_RB##s(p)
-#   define AV_WN(s, p, v) AV_WB##s(p, v)
-#else
-#   define AV_RN(s, p)    AV_RL##s(p)
-#   define AV_WN(s, p, v) AV_WL##s(p, v)
-#endif
-
-#endif /* HAVE_FAST_UNALIGNED */
-
-#ifndef AV_RN16
-#   define AV_RN16(p) AV_RN(16, p)
-#endif
-
-#ifndef AV_RN32
-#   define AV_RN32(p) AV_RN(32, p)
-#endif
-
-#ifndef AV_RN64
-#   define AV_RN64(p) AV_RN(64, p)
-#endif
-
-#ifndef AV_WN16
-#   define AV_WN16(p, v) AV_WN(16, p, v)
-#endif
-
-#ifndef AV_WN32
-#   define AV_WN32(p, v) AV_WN(32, p, v)
-#endif
-
-#ifndef AV_WN64
-#   define AV_WN64(p, v) AV_WN(64, p, v)
-#endif
-
-#if AV_HAVE_BIGENDIAN
-#   define AV_RB(s, p)    AV_RN##s(p)
-#   define AV_WB(s, p, v) AV_WN##s(p, v)
-#   define AV_RL(s, p)    av_bswap##s(AV_RN##s(p))
-#   define AV_WL(s, p, v) AV_WN##s(p, av_bswap##s(v))
-#else
-#   define AV_RB(s, p)    av_bswap##s(AV_RN##s(p))
-#   define AV_WB(s, p, v) AV_WN##s(p, av_bswap##s(v))
-#   define AV_RL(s, p)    AV_RN##s(p)
-#   define AV_WL(s, p, v) AV_WN##s(p, v)
-#endif
-
-#define AV_RB8(x)     (((const uint8_t*)(x))[0])
-#define AV_WB8(p, d)  do { ((uint8_t*)(p))[0] = (d); } while(0)
-
-#define AV_RL8(x)     AV_RB8(x)
-#define AV_WL8(p, d)  AV_WB8(p, d)
-
-#ifndef AV_RB16
-#   define AV_RB16(p)    AV_RB(16, p)
-#endif
-#ifndef AV_WB16
-#   define AV_WB16(p, v) AV_WB(16, p, v)
-#endif
-
-#ifndef AV_RL16
-#   define AV_RL16(p)    AV_RL(16, p)
-#endif
-#ifndef AV_WL16
-#   define AV_WL16(p, v) AV_WL(16, p, v)
-#endif
-
-#ifndef AV_RB32
-#   define AV_RB32(p)    AV_RB(32, p)
-#endif
-#ifndef AV_WB32
-#   define AV_WB32(p, v) AV_WB(32, p, v)
-#endif
-
-#ifndef AV_RL32
-#   define AV_RL32(p)    AV_RL(32, p)
-#endif
-#ifndef AV_WL32
-#   define AV_WL32(p, v) AV_WL(32, p, v)
-#endif
-
-#ifndef AV_RB64
-#   define AV_RB64(p)    AV_RB(64, p)
-#endif
-#ifndef AV_WB64
-#   define AV_WB64(p, v) AV_WB(64, p, v)
-#endif
-
-#ifndef AV_RL64
-#   define AV_RL64(p)    AV_RL(64, p)
-#endif
-#ifndef AV_WL64
-#   define AV_WL64(p, v) AV_WL(64, p, v)
-#endif
-
-#ifndef AV_RB24
-#   define AV_RB24(x)                           \
-    ((((const uint8_t*)(x))[0] << 16) |         \
-     (((const uint8_t*)(x))[1] <<  8) |         \
-      ((const uint8_t*)(x))[2])
-#endif
-#ifndef AV_WB24
-#   define AV_WB24(p, d) do {                   \
-        ((uint8_t*)(p))[2] = (d);               \
-        ((uint8_t*)(p))[1] = (d)>>8;            \
-        ((uint8_t*)(p))[0] = (d)>>16;           \
-    } while(0)
-#endif
-
-#ifndef AV_RL24
-#   define AV_RL24(x)                           \
-    ((((const uint8_t*)(x))[2] << 16) |         \
-     (((const uint8_t*)(x))[1] <<  8) |         \
-      ((const uint8_t*)(x))[0])
-#endif
-#ifndef AV_WL24
-#   define AV_WL24(p, d) do {                   \
-        ((uint8_t*)(p))[0] = (d);               \
-        ((uint8_t*)(p))[1] = (d)>>8;            \
-        ((uint8_t*)(p))[2] = (d)>>16;           \
-    } while(0)
-#endif
-
-#ifndef AV_RB48
-#   define AV_RB48(x)                                     \
-    (((uint64_t)((const uint8_t*)(x))[0] << 40) |         \
-     ((uint64_t)((const uint8_t*)(x))[1] << 32) |         \
-     ((uint64_t)((const uint8_t*)(x))[2] << 24) |         \
-     ((uint64_t)((const uint8_t*)(x))[3] << 16) |         \
-     ((uint64_t)((const uint8_t*)(x))[4] <<  8) |         \
-      (uint64_t)((const uint8_t*)(x))[5])
-#endif
-#ifndef AV_WB48
-#   define AV_WB48(p, darg) do {                \
-        uint64_t d = (darg);                    \
-        ((uint8_t*)(p))[5] = (d);               \
-        ((uint8_t*)(p))[4] = (d)>>8;            \
-        ((uint8_t*)(p))[3] = (d)>>16;           \
-        ((uint8_t*)(p))[2] = (d)>>24;           \
-        ((uint8_t*)(p))[1] = (d)>>32;           \
-        ((uint8_t*)(p))[0] = (d)>>40;           \
-    } while(0)
-#endif
-
-#ifndef AV_RL48
-#   define AV_RL48(x)                                     \
-    (((uint64_t)((const uint8_t*)(x))[5] << 40) |         \
-     ((uint64_t)((const uint8_t*)(x))[4] << 32) |         \
-     ((uint64_t)((const uint8_t*)(x))[3] << 24) |         \
-     ((uint64_t)((const uint8_t*)(x))[2] << 16) |         \
-     ((uint64_t)((const uint8_t*)(x))[1] <<  8) |         \
-      (uint64_t)((const uint8_t*)(x))[0])
-#endif
-#ifndef AV_WL48
-#   define AV_WL48(p, darg) do {                \
-        uint64_t d = (darg);                    \
-        ((uint8_t*)(p))[0] = (d);               \
-        ((uint8_t*)(p))[1] = (d)>>8;            \
-        ((uint8_t*)(p))[2] = (d)>>16;           \
-        ((uint8_t*)(p))[3] = (d)>>24;           \
-        ((uint8_t*)(p))[4] = (d)>>32;           \
-        ((uint8_t*)(p))[5] = (d)>>40;           \
-    } while(0)
-#endif
-
-/*
- * The AV_[RW]NA macros access naturally aligned data
- * in a type-safe way.
- */
-
-#define AV_RNA(s, p)    (((const av_alias##s*)(p))->u##s)
-#define AV_WNA(s, p, v) (((av_alias##s*)(p))->u##s = (v))
-
-#ifndef AV_RN16A
-#   define AV_RN16A(p) AV_RNA(16, p)
-#endif
-
-#ifndef AV_RN32A
-#   define AV_RN32A(p) AV_RNA(32, p)
-#endif
-
-#ifndef AV_RN64A
-#   define AV_RN64A(p) AV_RNA(64, p)
-#endif
-
-#ifndef AV_WN16A
-#   define AV_WN16A(p, v) AV_WNA(16, p, v)
-#endif
-
-#ifndef AV_WN32A
-#   define AV_WN32A(p, v) AV_WNA(32, p, v)
-#endif
-
-#ifndef AV_WN64A
-#   define AV_WN64A(p, v) AV_WNA(64, p, v)
-#endif
-
-/*
- * The AV_COPYxxU macros are suitable for copying data to/from unaligned
- * memory locations.
- */
-
-#define AV_COPYU(n, d, s) AV_WN##n(d, AV_RN##n(s));
-
-#ifndef AV_COPY16U
-#   define AV_COPY16U(d, s) AV_COPYU(16, d, s)
-#endif
-
-#ifndef AV_COPY32U
-#   define AV_COPY32U(d, s) AV_COPYU(32, d, s)
-#endif
-
-#ifndef AV_COPY64U
-#   define AV_COPY64U(d, s) AV_COPYU(64, d, s)
-#endif
-
-#ifndef AV_COPY128U
-#   define AV_COPY128U(d, s)                                    \
-    do {                                                        \
-        AV_COPY64U(d, s);                                       \
-        AV_COPY64U((char *)(d) + 8, (const char *)(s) + 8);     \
-    } while(0)
-#endif
-
-/* Parameters for AV_COPY*, AV_SWAP*, AV_ZERO* must be
- * naturally aligned. They may be implemented using MMX,
- * so emms_c() must be called before using any float code
- * afterwards.
- */
-
-#define AV_COPY(n, d, s) \
-    (((av_alias##n*)(d))->u##n = ((const av_alias##n*)(s))->u##n)
-
-#ifndef AV_COPY16
-#   define AV_COPY16(d, s) AV_COPY(16, d, s)
-#endif
-
-#ifndef AV_COPY32
-#   define AV_COPY32(d, s) AV_COPY(32, d, s)
-#endif
-
-#ifndef AV_COPY64
-#   define AV_COPY64(d, s) AV_COPY(64, d, s)
-#endif
-
-#ifndef AV_COPY128
-#   define AV_COPY128(d, s)                    \
-    do {                                       \
-        AV_COPY64(d, s);                       \
-        AV_COPY64((char*)(d)+8, (char*)(s)+8); \
-    } while(0)
-#endif
-
-#define AV_SWAP(n, a, b) FFSWAP(av_alias##n, *(av_alias##n*)(a), *(av_alias##n*)(b))
-
-#ifndef AV_SWAP64
-#   define AV_SWAP64(a, b) AV_SWAP(64, a, b)
-#endif
-
-#define AV_ZERO(n, d) (((av_alias##n*)(d))->u##n = 0)
-
-#ifndef AV_ZERO16
-#   define AV_ZERO16(d) AV_ZERO(16, d)
-#endif
-
-#ifndef AV_ZERO32
-#   define AV_ZERO32(d) AV_ZERO(32, d)
-#endif
-
-#ifndef AV_ZERO64
-#   define AV_ZERO64(d) AV_ZERO(64, d)
-#endif
-
-#ifndef AV_ZERO128
-#   define AV_ZERO128(d)         \
-    do {                         \
-        AV_ZERO64(d);            \
-        AV_ZERO64((char*)(d)+8); \
-    } while(0)
-#endif
-
-#endif /* AVUTIL_INTREADWRITE_H */
diff -pruN /usr/include/ffmpeg/libavutil/lfg.h csrc/libavutil/lfg.h
--- /usr/include/ffmpeg/libavutil/lfg.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/lfg.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-/*
- * Lagged Fibonacci PRNG
- * Copyright (c) 2008 Michael Niedermayer
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_LFG_H
-#define AVUTIL_LFG_H
-
-typedef struct AVLFG {
-    unsigned int state[64];
-    int index;
-} AVLFG;
-
-void av_lfg_init(AVLFG *c, unsigned int seed);
-
-/**
- * Get the next random unsigned 32-bit number using an ALFG.
- *
- * Please also consider a simple LCG like state= state*1664525+1013904223,
- * it may be good enough and faster for your specific use case.
- */
-static inline unsigned int av_lfg_get(AVLFG *c){
-    c->state[c->index & 63] = c->state[(c->index-24) & 63] + c->state[(c->index-55) & 63];
-    return c->state[c->index++ & 63];
-}
-
-/**
- * Get the next random unsigned 32-bit number using a MLFG.
- *
- * Please also consider av_lfg_get() above, it is faster.
- */
-static inline unsigned int av_mlfg_get(AVLFG *c){
-    unsigned int a= c->state[(c->index-55) & 63];
-    unsigned int b= c->state[(c->index-24) & 63];
-    return c->state[c->index++ & 63] = 2*a*b+a+b;
-}
-
-/**
- * Get the next two numbers generated by a Box-Muller Gaussian
- * generator using the random numbers issued by lfg.
- *
- * @param out array where the two generated numbers are placed
- */
-void av_bmg_get(AVLFG *lfg, double out[2]);
-
-#endif /* AVUTIL_LFG_H */
diff -pruN /usr/include/ffmpeg/libavutil/log.h csrc/libavutil/log.h
--- /usr/include/ffmpeg/libavutil/log.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/log.h	2014-10-20 12:33:09.453000741 +0200
@@ -1,29 +1,8 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
 
 #ifndef AVUTIL_LOG_H
 #define AVUTIL_LOG_H
 
-#include <stdarg.h>
-#include "avutil.h"
-#include "attributes.h"
+#include "opt.h"
 
 typedef enum {
     AV_CLASS_CATEGORY_NA = 0,
@@ -54,287 +33,7 @@ struct AVOptionRanges;
  * AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).
  */
 typedef struct AVClass {
-    /**
-     * The name of the class; usually it is the same name as the
-     * context structure type to which the AVClass is associated.
-     */
-    const char* class_name;
-
-    /**
-     * A pointer to a function which returns the name of a context
-     * instance ctx associated with the class.
-     */
-    const char* (*item_name)(void* ctx);
-
-    /**
-     * a pointer to the first option specified in the class if any or NULL
-     *
-     * @see av_set_default_options()
-     */
-    const struct AVOption *option;
-
-    /**
-     * LIBAVUTIL_VERSION with which this structure was created.
-     * This is used to allow fields to be added without requiring major
-     * version bumps everywhere.
-     */
-
-    int version;
-
-    /**
-     * Offset in the structure where log_level_offset is stored.
-     * 0 means there is no such variable
-     */
-    int log_level_offset_offset;
-
-    /**
-     * Offset in the structure where a pointer to the parent context for
-     * logging is stored. For example a decoder could pass its AVCodecContext
-     * to eval as such a parent context, which an av_log() implementation
-     * could then leverage to display the parent context.
-     * The offset can be NULL.
-     */
-    int parent_log_context_offset;
-
-    /**
-     * Return next AVOptions-enabled child or NULL
-     */
-    void* (*child_next)(void *obj, void *prev);
-
-    /**
-     * Return an AVClass corresponding to the next potential
-     * AVOptions-enabled child.
-     *
-     * The difference between child_next and this is that
-     * child_next iterates over _already existing_ objects, while
-     * child_class_next iterates over _all possible_ children.
-     */
-    const struct AVClass* (*child_class_next)(const struct AVClass *prev);
-
-    /**
-     * Category used for visualization (like color)
-     * This is only set if the category is equal for all objects using this class.
-     * available since version (51 << 16 | 56 << 8 | 100)
-     */
-    AVClassCategory category;
-
-    /**
-     * Callback to return the category.
-     * available since version (51 << 16 | 59 << 8 | 100)
-     */
-    AVClassCategory (*get_category)(void* ctx);
-
-    /**
-     * Callback to return the supported/allowed ranges.
-     * available since version (52.12)
-     */
-    int (*query_ranges)(struct AVOptionRanges **, void *obj, const char *key, int flags);
+    int dummy;
 } AVClass;
 
-/**
- * @addtogroup lavu_log
- *
- * @{
- *
- * @defgroup lavu_log_constants Logging Constants
- *
- * @{
- */
-
-/**
- * Print no output.
- */
-#define AV_LOG_QUIET    -8
-
-/**
- * Something went really wrong and we will crash now.
- */
-#define AV_LOG_PANIC     0
-
-/**
- * Something went wrong and recovery is not possible.
- * For example, no header was found for a format which depends
- * on headers or an illegal combination of parameters is used.
- */
-#define AV_LOG_FATAL     8
-
-/**
- * Something went wrong and cannot losslessly be recovered.
- * However, not all future data is affected.
- */
-#define AV_LOG_ERROR    16
-
-/**
- * Something somehow does not look correct. This may or may not
- * lead to problems. An example would be the use of '-vstrict -2'.
- */
-#define AV_LOG_WARNING  24
-
-/**
- * Standard information.
- */
-#define AV_LOG_INFO     32
-
-/**
- * Detailed information.
- */
-#define AV_LOG_VERBOSE  40
-
-/**
- * Stuff which is only useful for libav* developers.
- */
-#define AV_LOG_DEBUG    48
-
-#define AV_LOG_MAX_OFFSET (AV_LOG_DEBUG - AV_LOG_QUIET)
-
-/**
- * @}
- */
-
-/**
- * Sets additional colors for extended debugging sessions.
- * @code
-   av_log(ctx, AV_LOG_DEBUG|AV_LOG_C(134), "Message in purple\n");
-   @endcode
- * Requires 256color terminal support. Uses outside debugging is not
- * recommended.
- */
-#define AV_LOG_C(x) (x << 8)
-
-/**
- * Send the specified message to the log if the level is less than or equal
- * to the current av_log_level. By default, all logging messages are sent to
- * stderr. This behavior can be altered by setting a different logging callback
- * function.
- * @see av_log_set_callback
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- *        pointer to an AVClass struct.
- * @param level The importance level of the message expressed using a @ref
- *        lavu_log_constants "Logging Constant".
- * @param fmt The format string (printf-compatible) that specifies how
- *        subsequent arguments are converted to output.
- */
-void av_log(void *avcl, int level, const char *fmt, ...) av_printf_format(3, 4);
-
-
-/**
- * Send the specified message to the log if the level is less than or equal
- * to the current av_log_level. By default, all logging messages are sent to
- * stderr. This behavior can be altered by setting a different logging callback
- * function.
- * @see av_log_set_callback
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- *        pointer to an AVClass struct.
- * @param level The importance level of the message expressed using a @ref
- *        lavu_log_constants "Logging Constant".
- * @param fmt The format string (printf-compatible) that specifies how
- *        subsequent arguments are converted to output.
- * @param vl The arguments referenced by the format string.
- */
-void av_vlog(void *avcl, int level, const char *fmt, va_list vl);
-
-/**
- * Get the current log level
- *
- * @see lavu_log_constants
- *
- * @return Current log level
- */
-int av_log_get_level(void);
-
-/**
- * Set the log level
- *
- * @see lavu_log_constants
- *
- * @param level Logging level
- */
-void av_log_set_level(int level);
-
-/**
- * Set the logging callback
- *
- * @note The callback must be thread safe, even if the application does not use
- *       threads itself as some codecs are multithreaded.
- *
- * @see av_log_default_callback
- *
- * @param callback A logging function with a compatible signature.
- */
-void av_log_set_callback(void (*callback)(void*, int, const char*, va_list));
-
-/**
- * Default logging callback
- *
- * It prints the message to stderr, optionally colorizing it.
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- *        pointer to an AVClass struct.
- * @param level The importance level of the message expressed using a @ref
- *        lavu_log_constants "Logging Constant".
- * @param fmt The format string (printf-compatible) that specifies how
- *        subsequent arguments are converted to output.
- * @param vl The arguments referenced by the format string.
- */
-void av_log_default_callback(void *avcl, int level, const char *fmt,
-                             va_list vl);
-
-/**
- * Return the context name
- *
- * @param  ctx The AVClass context
- *
- * @return The AVClass class_name
- */
-const char* av_default_item_name(void* ctx);
-AVClassCategory av_default_get_category(void *ptr);
-
-/**
- * Format a line of log the same way as the default callback.
- * @param line          buffer to receive the formated line
- * @param line_size     size of the buffer
- * @param print_prefix  used to store whether the prefix must be printed;
- *                      must point to a persistent integer initially set to 1
- */
-void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl,
-                        char *line, int line_size, int *print_prefix);
-
-/**
- * av_dlog macros
- * Useful to print debug messages that shouldn't get compiled in normally.
- */
-
-#ifdef DEBUG
-#    define av_dlog(pctx, ...) av_log(pctx, AV_LOG_DEBUG, __VA_ARGS__)
-#else
-#    define av_dlog(pctx, ...) do { if (0) av_log(pctx, AV_LOG_DEBUG, __VA_ARGS__); } while (0)
-#endif
-
-/**
- * Skip repeated messages, this requires the user app to use av_log() instead of
- * (f)printf as the 2 would otherwise interfere and lead to
- * "Last message repeated x times" messages below (f)printf messages with some
- * bad luck.
- * Also to receive the last, "last repeated" line if any, the user app must
- * call av_log(NULL, AV_LOG_QUIET, "%s", ""); at the end
- */
-#define AV_LOG_SKIP_REPEATED 1
-
-/**
- * Include the log severity in messages originating from codecs.
- *
- * Results in messages such as:
- * [rawvideo @ 0xDEADBEEF] [error] encode did not produce valid pts
- */
-#define AV_LOG_PRINT_LEVEL 2
-
-void av_log_set_flags(int arg);
-int av_log_get_flags(void);
-
-/**
- * @}
- */
-
 #endif /* AVUTIL_LOG_H */
diff -pruN /usr/include/ffmpeg/libavutil/lzo.h csrc/libavutil/lzo.h
--- /usr/include/ffmpeg/libavutil/lzo.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/lzo.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-/*
- * LZO 1x decompression
- * copyright (c) 2006 Reimar Doeffinger
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_LZO_H
-#define AVUTIL_LZO_H
-
-/**
- * @defgroup lavu_lzo LZO
- * @ingroup lavu_crypto
- *
- * @{
- */
-
-#include <stdint.h>
-
-/** @name Error flags returned by av_lzo1x_decode
- * @{ */
-/// end of the input buffer reached before decoding finished
-#define AV_LZO_INPUT_DEPLETED  1
-/// decoded data did not fit into output buffer
-#define AV_LZO_OUTPUT_FULL     2
-/// a reference to previously decoded data was wrong
-#define AV_LZO_INVALID_BACKPTR 4
-/// a non-specific error in the compressed bitstream
-#define AV_LZO_ERROR           8
-/** @} */
-
-#define AV_LZO_INPUT_PADDING   8
-#define AV_LZO_OUTPUT_PADDING 12
-
-/**
- * @brief Decodes LZO 1x compressed data.
- * @param out output buffer
- * @param outlen size of output buffer, number of bytes left are returned here
- * @param in input buffer
- * @param inlen size of input buffer, number of bytes left are returned here
- * @return 0 on success, otherwise a combination of the error flags above
- *
- * Make sure all buffers are appropriately padded, in must provide
- * AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes.
- */
-int av_lzo1x_decode(void *out, int *outlen, const void *in, int *inlen);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_LZO_H */
diff -pruN /usr/include/ffmpeg/libavutil/macros.h csrc/libavutil/macros.h
--- /usr/include/ffmpeg/libavutil/macros.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/macros.h	2014-10-20 10:36:41.565488533 +0200
@@ -1,48 +1,13 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * @ingroup lavu
- * Utility Preprocessor macros
- */
 
 #ifndef AVUTIL_MACROS_H
 #define AVUTIL_MACROS_H
 
-/**
- * @addtogroup preproc_misc Preprocessor String Macros
- *
- * String manipulation macros
- *
- * @{
- */
-
 #define AV_STRINGIFY(s)         AV_TOSTRING(s)
 #define AV_TOSTRING(s) #s
 
 #define AV_GLUE(a, b) a ## b
 #define AV_JOIN(a, b) AV_GLUE(a, b)
 
-/**
- * @}
- */
-
 #define AV_PRAGMA(s) _Pragma(#s)
 
 #endif /* AVUTIL_MACROS_H */
diff -pruN /usr/include/ffmpeg/libavutil/mathematics.h csrc/libavutil/mathematics.h
--- /usr/include/ffmpeg/libavutil/mathematics.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/mathematics.h	2014-10-20 12:47:08.940600478 +0200
@@ -21,144 +21,10 @@
 #ifndef AVUTIL_MATHEMATICS_H
 #define AVUTIL_MATHEMATICS_H
 
-#include <stdint.h>
-#include <math.h>
-#include "attributes.h"
-#include "rational.h"
-#include "intfloat.h"
-
-#ifndef M_E
-#define M_E            2.7182818284590452354   /* e */
-#endif
-#ifndef M_LN2
-#define M_LN2          0.69314718055994530942  /* log_e 2 */
-#endif
-#ifndef M_LN10
-#define M_LN10         2.30258509299404568402  /* log_e 10 */
-#endif
-#ifndef M_LOG2_10
-#define M_LOG2_10      3.32192809488736234787  /* log_2 10 */
-#endif
-#ifndef M_PHI
-#define M_PHI          1.61803398874989484820   /* phi / golden ratio */
-#endif
-#ifndef M_PI
-#define M_PI           3.14159265358979323846  /* pi */
-#endif
-#ifndef M_PI_2
-#define M_PI_2         1.57079632679489661923  /* pi/2 */
-#endif
-#ifndef M_SQRT1_2
-#define M_SQRT1_2      0.70710678118654752440  /* 1/sqrt(2) */
-#endif
-#ifndef M_SQRT2
-#define M_SQRT2        1.41421356237309504880  /* sqrt(2) */
-#endif
-#ifndef NAN
-#define NAN            av_int2float(0x7fc00000)
-#endif
-#ifndef INFINITY
-#define INFINITY       av_int2float(0x7f800000)
-#endif
-
-/**
- * @addtogroup lavu_math
- * @{
- */
-
-
-enum AVRounding {
-    AV_ROUND_ZERO     = 0, ///< Round toward zero.
-    AV_ROUND_INF      = 1, ///< Round away from zero.
-    AV_ROUND_DOWN     = 2, ///< Round toward -infinity.
-    AV_ROUND_UP       = 3, ///< Round toward +infinity.
-    AV_ROUND_NEAR_INF = 5, ///< Round to nearest and halfway cases away from zero.
-    AV_ROUND_PASS_MINMAX = 8192, ///< Flag to pass INT64_MIN/MAX through instead of rescaling, this avoids special cases for AV_NOPTS_VALUE
-};
-
-/**
- * Return the greatest common divisor of a and b.
- * If both a and b are 0 or either or both are <0 then behavior is
- * undefined.
- */
-int64_t av_const av_gcd(int64_t a, int64_t b);
-
 /**
  * Rescale a 64-bit integer with rounding to nearest.
  * A simple a*b/c isn't possible as it can overflow.
  */
 int64_t av_rescale(int64_t a, int64_t b, int64_t c) av_const;
 
-/**
- * Rescale a 64-bit integer with specified rounding.
- * A simple a*b/c isn't possible as it can overflow.
- *
- * @return rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is
- *         INT64_MIN or INT64_MAX then a is passed through unchanged.
- */
-int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding) av_const;
-
-/**
- * Rescale a 64-bit integer by 2 rational numbers.
- */
-int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq) av_const;
-
-/**
- * Rescale a 64-bit integer by 2 rational numbers with specified rounding.
- *
- * @return rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is
- *         INT64_MIN or INT64_MAX then a is passed through unchanged.
- */
-int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq,
-                         enum AVRounding) av_const;
-
-/**
- * Compare 2 timestamps each in its own timebases.
- * The result of the function is undefined if one of the timestamps
- * is outside the int64_t range when represented in the others timebase.
- * @return -1 if ts_a is before ts_b, 1 if ts_a is after ts_b or 0 if they represent the same position
- */
-int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b);
-
-/**
- * Compare 2 integers modulo mod.
- * That is we compare integers a and b for which only the least
- * significant log2(mod) bits are known.
- *
- * @param mod must be a power of 2
- * @return a negative value if a is smaller than b
- *         a positive value if a is greater than b
- *         0                if a equals          b
- */
-int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod);
-
-/**
- * Rescale a timestamp while preserving known durations.
- *
- * @param in_ts Input timestamp
- * @param in_tb Input timebase
- * @param fs_tb Duration and *last timebase
- * @param duration duration till the next call
- * @param out_tb Output timebase
- */
-int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts,  AVRational fs_tb, int duration, int64_t *last, AVRational out_tb);
-
-/**
- * Add a value to a timestamp.
- *
- * This function guarantees that when the same value is repeatly added that
- * no accumulation of rounding errors occurs.
- *
- * @param ts Input timestamp
- * @param ts_tb Input timestamp timebase
- * @param inc value to add to ts
- * @param inc_tb inc timebase
- */
-int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc);
-
-
-    /**
- * @}
- */
-
 #endif /* AVUTIL_MATHEMATICS_H */
diff -pruN /usr/include/ffmpeg/libavutil/md5.h csrc/libavutil/md5.h
--- /usr/include/ffmpeg/libavutil/md5.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/md5.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_MD5_H
-#define AVUTIL_MD5_H
-
-#include <stdint.h>
-
-#include "attributes.h"
-#include "version.h"
-
-/**
- * @defgroup lavu_md5 MD5
- * @ingroup lavu_crypto
- * @{
- */
-
-extern const int av_md5_size;
-
-struct AVMD5;
-
-/**
- * Allocate an AVMD5 context.
- */
-struct AVMD5 *av_md5_alloc(void);
-
-/**
- * Initialize MD5 hashing.
- *
- * @param ctx pointer to the function context (of size av_md5_size)
- */
-void av_md5_init(struct AVMD5 *ctx);
-
-/**
- * Update hash value.
- *
- * @param ctx hash function context
- * @param src input data to update hash with
- * @param len input data length
- */
-void av_md5_update(struct AVMD5 *ctx, const uint8_t *src, int len);
-
-/**
- * Finish hashing and output digest value.
- *
- * @param ctx hash function context
- * @param dst buffer where output digest value is stored
- */
-void av_md5_final(struct AVMD5 *ctx, uint8_t *dst);
-
-/**
- * Hash an array of data.
- *
- * @param dst The output buffer to write the digest into
- * @param src The data to hash
- * @param len The length of the data, in bytes
- */
-void av_md5_sum(uint8_t *dst, const uint8_t *src, const int len);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_MD5_H */
diff -pruN /usr/include/ffmpeg/libavutil/mem.h csrc/libavutil/mem.h
--- /usr/include/ffmpeg/libavutil/mem.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/mem.h	2014-10-20 12:49:27.458104052 +0200
@@ -1,27 +1,3 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * memory handling functions
- */
 
 #ifndef AVUTIL_MEM_H
 #define AVUTIL_MEM_H
@@ -33,33 +9,6 @@
 #include "error.h"
 #include "avutil.h"
 
-/**
- * @addtogroup lavu_mem
- * @{
- */
-
-
-#if defined(__INTEL_COMPILER) && __INTEL_COMPILER < 1110 || defined(__SUNPRO_C)
-    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (n))) v
-    #define DECLARE_ASM_CONST(n,t,v)    const t __attribute__ ((aligned (n))) v
-#elif defined(__TI_COMPILER_VERSION__)
-    #define DECLARE_ALIGNED(n,t,v)                      \
-        AV_PRAGMA(DATA_ALIGN(v,n))                      \
-        t __attribute__((aligned(n))) v
-    #define DECLARE_ASM_CONST(n,t,v)                    \
-        AV_PRAGMA(DATA_ALIGN(v,n))                      \
-        static const t __attribute__((aligned(n))) v
-#elif defined(__GNUC__)
-    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (n))) v
-    #define DECLARE_ASM_CONST(n,t,v)    static const t av_used __attribute__ ((aligned (n))) v
-#elif defined(_MSC_VER)
-    #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
-    #define DECLARE_ASM_CONST(n,t,v)    __declspec(align(n)) static const t v
-#else
-    #define DECLARE_ALIGNED(n,t,v)      t v
-    #define DECLARE_ASM_CONST(n,t,v)    static const t v
-#endif
-
 #if AV_GCC_VERSION_AT_LEAST(3,1)
     #define av_malloc_attrib __attribute__((__malloc__))
 #else
@@ -83,108 +32,6 @@
 void *av_malloc(size_t size) av_malloc_attrib av_alloc_size(1);
 
 /**
- * Allocate a block of size * nmemb bytes with av_malloc().
- * @param nmemb Number of elements
- * @param size Size of the single element
- * @return Pointer to the allocated block, NULL if the block cannot
- * be allocated.
- * @see av_malloc()
- */
-av_alloc_size(1, 2) static inline void *av_malloc_array(size_t nmemb, size_t size)
-{
-    if (!size || nmemb >= INT_MAX / size)
-        return NULL;
-    return av_malloc(nmemb * size);
-}
-
-/**
- * Allocate or reallocate a block of memory.
- * If ptr is NULL and size > 0, allocate a new block. If
- * size is zero, free the memory block pointed to by ptr.
- * @param ptr Pointer to a memory block already allocated with
- * av_realloc() or NULL.
- * @param size Size in bytes of the memory block to be allocated or
- * reallocated.
- * @return Pointer to a newly-reallocated block or NULL if the block
- * cannot be reallocated or the function is used to free the memory block.
- * @warning Pointers originating from the av_malloc() family of functions must
- *          not be passed to av_realloc(). The former can be implemented using
- *          memalign() (or other functions), and there is no guarantee that
- *          pointers from such functions can be passed to realloc() at all.
- *          The situation is undefined according to POSIX and may crash with
- *          some libc implementations.
- * @see av_fast_realloc()
- */
-void *av_realloc(void *ptr, size_t size) av_alloc_size(2);
-
-/**
- * Allocate or reallocate a block of memory.
- * This function does the same thing as av_realloc, except:
- * - It takes two arguments and checks the result of the multiplication for
- *   integer overflow.
- * - It frees the input block in case of failure, thus avoiding the memory
- *   leak with the classic "buf = realloc(buf); if (!buf) return -1;".
- */
-void *av_realloc_f(void *ptr, size_t nelem, size_t elsize);
-
-/**
- * Allocate or reallocate a block of memory.
- * If *ptr is NULL and size > 0, allocate a new block. If
- * size is zero, free the memory block pointed to by ptr.
- * @param   ptr Pointer to a pointer to a memory block already allocated
- *          with av_realloc(), or pointer to a pointer to NULL.
- *          The pointer is updated on success, or freed on failure.
- * @param   size Size in bytes for the memory block to be allocated or
- *          reallocated
- * @return  Zero on success, an AVERROR error code on failure.
- * @warning Pointers originating from the av_malloc() family of functions must
- *          not be passed to av_reallocp(). The former can be implemented using
- *          memalign() (or other functions), and there is no guarantee that
- *          pointers from such functions can be passed to realloc() at all.
- *          The situation is undefined according to POSIX and may crash with
- *          some libc implementations.
- */
-int av_reallocp(void *ptr, size_t size);
-
-/**
- * Allocate or reallocate an array.
- * If ptr is NULL and nmemb > 0, allocate a new block. If
- * nmemb is zero, free the memory block pointed to by ptr.
- * @param ptr Pointer to a memory block already allocated with
- * av_realloc() or NULL.
- * @param nmemb Number of elements
- * @param size Size of the single element
- * @return Pointer to a newly-reallocated block or NULL if the block
- * cannot be reallocated or the function is used to free the memory block.
- * @warning Pointers originating from the av_malloc() family of functions must
- *          not be passed to av_realloc(). The former can be implemented using
- *          memalign() (or other functions), and there is no guarantee that
- *          pointers from such functions can be passed to realloc() at all.
- *          The situation is undefined according to POSIX and may crash with
- *          some libc implementations.
- */
-av_alloc_size(2, 3) void *av_realloc_array(void *ptr, size_t nmemb, size_t size);
-
-/**
- * Allocate or reallocate an array through a pointer to a pointer.
- * If *ptr is NULL and nmemb > 0, allocate a new block. If
- * nmemb is zero, free the memory block pointed to by ptr.
- * @param ptr Pointer to a pointer to a memory block already allocated
- * with av_realloc(), or pointer to a pointer to NULL.
- * The pointer is updated on success, or freed on failure.
- * @param nmemb Number of elements
- * @param size Size of the single element
- * @return Zero on success, an AVERROR error code on failure.
- * @warning Pointers originating from the av_malloc() family of functions must
- *          not be passed to av_realloc(). The former can be implemented using
- *          memalign() (or other functions), and there is no guarantee that
- *          pointers from such functions can be passed to realloc() at all.
- *          The situation is undefined according to POSIX and may crash with
- *          some libc implementations.
- */
-av_alloc_size(2, 3) int av_reallocp_array(void *ptr, size_t nmemb, size_t size);
-
-/**
  * Free a memory block which has been allocated with av_malloc(z)() or
  * av_realloc().
  * @param ptr Pointer to the memory block which should be freed.
@@ -195,60 +42,6 @@ av_alloc_size(2, 3) int av_reallocp_arra
 void av_free(void *ptr);
 
 /**
- * Allocate a block of size bytes with alignment suitable for all
- * memory accesses (including vectors if available on the CPU) and
- * zero all the bytes of the block.
- * @param size Size in bytes for the memory block to be allocated.
- * @return Pointer to the allocated block, NULL if it cannot be allocated.
- * @see av_malloc()
- */
-void *av_mallocz(size_t size) av_malloc_attrib av_alloc_size(1);
-
-/**
- * Allocate a block of nmemb * size bytes with alignment suitable for all
- * memory accesses (including vectors if available on the CPU) and
- * zero all the bytes of the block.
- * The allocation will fail if nmemb * size is greater than or equal
- * to INT_MAX.
- * @param nmemb
- * @param size
- * @return Pointer to the allocated block, NULL if it cannot be allocated.
- */
-void *av_calloc(size_t nmemb, size_t size) av_malloc_attrib;
-
-/**
- * Allocate a block of size * nmemb bytes with av_mallocz().
- * @param nmemb Number of elements
- * @param size Size of the single element
- * @return Pointer to the allocated block, NULL if the block cannot
- * be allocated.
- * @see av_mallocz()
- * @see av_malloc_array()
- */
-av_alloc_size(1, 2) static inline void *av_mallocz_array(size_t nmemb, size_t size)
-{
-    if (!size || nmemb >= INT_MAX / size)
-        return NULL;
-    return av_mallocz(nmemb * size);
-}
-
-/**
- * Duplicate the string s.
- * @param s string to be duplicated
- * @return Pointer to a newly-allocated string containing a
- * copy of s or NULL if the string cannot be allocated.
- */
-char *av_strdup(const char *s) av_malloc_attrib;
-
-/**
- * Duplicate the buffer p.
- * @param p buffer to be duplicated
- * @return Pointer to a newly allocated buffer containing a
- * copy of p or NULL if the buffer cannot be allocated.
- */
-void *av_memdup(const void *p, size_t size);
-
-/**
  * Free a memory block which has been allocated with av_malloc(z)() or
  * av_realloc() and set the pointer pointing to it to NULL.
  * @param ptr Pointer to the pointer to the memory block which should
@@ -257,122 +50,4 @@ void *av_memdup(const void *p, size_t si
  */
 void av_freep(void *ptr);
 
-/**
- * Add an element to a dynamic array.
- *
- * The array to grow is supposed to be an array of pointers to
- * structures, and the element to add must be a pointer to an already
- * allocated structure.
- *
- * The array is reallocated when its size reaches powers of 2.
- * Therefore, the amortized cost of adding an element is constant.
- *
- * In case of success, the pointer to the array is updated in order to
- * point to the new grown array, and the number pointed to by nb_ptr
- * is incremented.
- * In case of failure, the array is freed, *tab_ptr is set to NULL and
- * *nb_ptr is set to 0.
- *
- * @param tab_ptr pointer to the array to grow
- * @param nb_ptr  pointer to the number of elements in the array
- * @param elem    element to add
- * @see av_dynarray_add_nofree(), av_dynarray2_add()
- */
-void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem);
-
-/**
- * Add an element to a dynamic array.
- *
- * Function has the same functionality as av_dynarray_add(),
- * but it doesn't free memory on fails. It returns error code
- * instead and leave current buffer untouched.
- *
- * @param tab_ptr pointer to the array to grow
- * @param nb_ptr  pointer to the number of elements in the array
- * @param elem    element to add
- * @return >=0 on success, negative otherwise.
- * @see av_dynarray_add(), av_dynarray2_add()
- */
-int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem);
-
-/**
- * Add an element of size elem_size to a dynamic array.
- *
- * The array is reallocated when its number of elements reaches powers of 2.
- * Therefore, the amortized cost of adding an element is constant.
- *
- * In case of success, the pointer to the array is updated in order to
- * point to the new grown array, and the number pointed to by nb_ptr
- * is incremented.
- * In case of failure, the array is freed, *tab_ptr is set to NULL and
- * *nb_ptr is set to 0.
- *
- * @param tab_ptr   pointer to the array to grow
- * @param nb_ptr    pointer to the number of elements in the array
- * @param elem_size size in bytes of the elements in the array
- * @param elem_data pointer to the data of the element to add. If NULL, the space of
- *                  the new added element is not filled.
- * @return          pointer to the data of the element to copy in the new allocated space.
- *                  If NULL, the new allocated space is left uninitialized."
- * @see av_dynarray_add(), av_dynarray_add_nofree()
- */
-void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size,
-                       const uint8_t *elem_data);
-
-/**
- * Multiply two size_t values checking for overflow.
- * @return  0 if success, AVERROR(EINVAL) if overflow.
- */
-static inline int av_size_mult(size_t a, size_t b, size_t *r)
-{
-    size_t t = a * b;
-    /* Hack inspired from glibc: only try the division if nelem and elsize
-     * are both greater than sqrt(SIZE_MAX). */
-    if ((a | b) >= ((size_t)1 << (sizeof(size_t) * 4)) && a && t / a != b)
-        return AVERROR(EINVAL);
-    *r = t;
-    return 0;
-}
-
-/**
- * Set the maximum size that may me allocated in one block.
- */
-void av_max_alloc(size_t max);
-
-/**
- * deliberately overlapping memcpy implementation
- * @param dst destination buffer
- * @param back how many bytes back we start (the initial size of the overlapping window), must be > 0
- * @param cnt number of bytes to copy, must be >= 0
- *
- * cnt > back is valid, this will copy the bytes we just copied,
- * thus creating a repeating pattern with a period length of back.
- */
-void av_memcpy_backptr(uint8_t *dst, int back, int cnt);
-
-/**
- * Reallocate the given block if it is not large enough, otherwise do nothing.
- *
- * @see av_realloc
- */
-void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size);
-
-/**
- * Allocate a buffer, reusing the given one if large enough.
- *
- * Contrary to av_fast_realloc the current buffer contents might not be
- * preserved and on error the old buffer is freed, thus no special
- * handling to avoid memleaks is necessary.
- *
- * @param ptr pointer to pointer to already allocated buffer, overwritten with pointer to new buffer
- * @param size size of the buffer *ptr points to
- * @param min_size minimum size of *ptr buffer after returning, *ptr will be NULL and
- *                 *size 0 if an error occurred.
- */
-void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size);
-
-/**
- * @}
- */
-
 #endif /* AVUTIL_MEM_H */
diff -pruN /usr/include/ffmpeg/libavutil/murmur3.h csrc/libavutil/murmur3.h
--- /usr/include/ffmpeg/libavutil/murmur3.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/murmur3.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2013 Reimar Dffinger <Reimar.Doeffinger@gmx.de>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_MURMUR3_H
-#define AVUTIL_MURMUR3_H
-
-#include <stdint.h>
-
-struct AVMurMur3 *av_murmur3_alloc(void);
-void av_murmur3_init_seeded(struct AVMurMur3 *c, uint64_t seed);
-void av_murmur3_init(struct AVMurMur3 *c);
-void av_murmur3_update(struct AVMurMur3 *c, const uint8_t *src, int len);
-void av_murmur3_final(struct AVMurMur3 *c, uint8_t dst[16]);
-
-#endif /* AVUTIL_MURMUR3_H */
diff -pruN /usr/include/ffmpeg/libavutil/old_pix_fmts.h csrc/libavutil/old_pix_fmts.h
--- /usr/include/ffmpeg/libavutil/old_pix_fmts.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/old_pix_fmts.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,177 +0,0 @@
-/*
- * copyright (c) 2006-2012 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_OLD_PIX_FMTS_H
-#define AVUTIL_OLD_PIX_FMTS_H
-
-/*
- * This header exists to prevent new pixel formats from being accidentally added
- * to the deprecated list.
- * Do not include it directly. It will be removed on next major bump
- *
- * Do not add new items to this list. Use the AVPixelFormat enum instead.
- */
-    PIX_FMT_NONE = AV_PIX_FMT_NONE,
-    PIX_FMT_YUV420P,   ///< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)
-    PIX_FMT_YUYV422,   ///< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr
-    PIX_FMT_RGB24,     ///< packed RGB 8:8:8, 24bpp, RGBRGB...
-    PIX_FMT_BGR24,     ///< packed RGB 8:8:8, 24bpp, BGRBGR...
-    PIX_FMT_YUV422P,   ///< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
-    PIX_FMT_YUV444P,   ///< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)
-    PIX_FMT_YUV410P,   ///< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)
-    PIX_FMT_YUV411P,   ///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)
-    PIX_FMT_GRAY8,     ///<        Y        ,  8bpp
-    PIX_FMT_MONOWHITE, ///<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb
-    PIX_FMT_MONOBLACK, ///<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb
-    PIX_FMT_PAL8,      ///< 8 bit with PIX_FMT_RGB32 palette
-    PIX_FMT_YUVJ420P,  ///< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV420P and setting color_range
-    PIX_FMT_YUVJ422P,  ///< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV422P and setting color_range
-    PIX_FMT_YUVJ444P,  ///< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV444P and setting color_range
-#if FF_API_XVMC
-    PIX_FMT_XVMC_MPEG2_MC,///< XVideo Motion Acceleration via common packet passing
-    PIX_FMT_XVMC_MPEG2_IDCT,
-#endif /* FF_API_XVMC */
-    PIX_FMT_UYVY422,   ///< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
-    PIX_FMT_UYYVYY411, ///< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
-    PIX_FMT_BGR8,      ///< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
-    PIX_FMT_BGR4,      ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
-    PIX_FMT_BGR4_BYTE, ///< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
-    PIX_FMT_RGB8,      ///< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
-    PIX_FMT_RGB4,      ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
-    PIX_FMT_RGB4_BYTE, ///< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)
-    PIX_FMT_NV12,      ///< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
-    PIX_FMT_NV21,      ///< as above, but U and V bytes are swapped
-
-    PIX_FMT_ARGB,      ///< packed ARGB 8:8:8:8, 32bpp, ARGBARGB...
-    PIX_FMT_RGBA,      ///< packed RGBA 8:8:8:8, 32bpp, RGBARGBA...
-    PIX_FMT_ABGR,      ///< packed ABGR 8:8:8:8, 32bpp, ABGRABGR...
-    PIX_FMT_BGRA,      ///< packed BGRA 8:8:8:8, 32bpp, BGRABGRA...
-
-    PIX_FMT_GRAY16BE,  ///<        Y        , 16bpp, big-endian
-    PIX_FMT_GRAY16LE,  ///<        Y        , 16bpp, little-endian
-    PIX_FMT_YUV440P,   ///< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
-    PIX_FMT_YUVJ440P,  ///< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of PIX_FMT_YUV440P and setting color_range
-    PIX_FMT_YUVA420P,  ///< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
-#if FF_API_VDPAU
-    PIX_FMT_VDPAU_H264,///< H.264 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-    PIX_FMT_VDPAU_MPEG1,///< MPEG-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-    PIX_FMT_VDPAU_MPEG2,///< MPEG-2 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-    PIX_FMT_VDPAU_WMV3,///< WMV3 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-    PIX_FMT_VDPAU_VC1, ///< VC-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-#endif
-    PIX_FMT_RGB48BE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
-    PIX_FMT_RGB48LE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
-
-    PIX_FMT_RGB565BE,  ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian
-    PIX_FMT_RGB565LE,  ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian
-    PIX_FMT_RGB555BE,  ///< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), big-endian, most significant bit to 0
-    PIX_FMT_RGB555LE,  ///< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), little-endian, most significant bit to 0
-
-    PIX_FMT_BGR565BE,  ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian
-    PIX_FMT_BGR565LE,  ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian
-    PIX_FMT_BGR555BE,  ///< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), big-endian, most significant bit to 1
-    PIX_FMT_BGR555LE,  ///< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), little-endian, most significant bit to 1
-
-    PIX_FMT_VAAPI_MOCO, ///< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers
-    PIX_FMT_VAAPI_IDCT, ///< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers
-    PIX_FMT_VAAPI_VLD,  ///< HW decoding through VA API, Picture.data[3] contains a vaapi_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-
-    PIX_FMT_YUV420P16LE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    PIX_FMT_YUV420P16BE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    PIX_FMT_YUV422P16LE,  ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    PIX_FMT_YUV422P16BE,  ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    PIX_FMT_YUV444P16LE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    PIX_FMT_YUV444P16BE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-#if FF_API_VDPAU
-    PIX_FMT_VDPAU_MPEG4,  ///< MPEG4 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-#endif
-    PIX_FMT_DXVA2_VLD,    ///< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer
-
-    PIX_FMT_RGB444LE,  ///< packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), little-endian, most significant bits to 0
-    PIX_FMT_RGB444BE,  ///< packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), big-endian, most significant bits to 0
-    PIX_FMT_BGR444LE,  ///< packed BGR 4:4:4, 16bpp, (msb)4A 4B 4G 4R(lsb), little-endian, most significant bits to 1
-    PIX_FMT_BGR444BE,  ///< packed BGR 4:4:4, 16bpp, (msb)4A 4B 4G 4R(lsb), big-endian, most significant bits to 1
-    PIX_FMT_GRAY8A,    ///< 8bit gray, 8bit alpha
-    PIX_FMT_BGR48BE,   ///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian
-    PIX_FMT_BGR48LE,   ///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian
-
-    //the following 10 formats have the disadvantage of needing 1 format for each bit depth, thus
-    //If you want to support multiple bit depths, then using PIX_FMT_YUV420P16* with the bpp stored separately
-    //is better
-    PIX_FMT_YUV420P9BE, ///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    PIX_FMT_YUV420P9LE, ///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    PIX_FMT_YUV420P10BE,///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    PIX_FMT_YUV420P10LE,///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    PIX_FMT_YUV422P10BE,///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    PIX_FMT_YUV422P10LE,///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    PIX_FMT_YUV444P9BE, ///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-    PIX_FMT_YUV444P9LE, ///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    PIX_FMT_YUV444P10BE,///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-    PIX_FMT_YUV444P10LE,///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    PIX_FMT_YUV422P9BE, ///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    PIX_FMT_YUV422P9LE, ///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    PIX_FMT_VDA_VLD,    ///< hardware decoding through VDA
-
-#ifdef AV_PIX_FMT_ABI_GIT_MASTER
-    PIX_FMT_RGBA64BE,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
-    PIX_FMT_RGBA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
-    PIX_FMT_BGRA64BE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
-    PIX_FMT_BGRA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
-#endif
-    PIX_FMT_GBRP,      ///< planar GBR 4:4:4 24bpp
-    PIX_FMT_GBRP9BE,   ///< planar GBR 4:4:4 27bpp, big endian
-    PIX_FMT_GBRP9LE,   ///< planar GBR 4:4:4 27bpp, little endian
-    PIX_FMT_GBRP10BE,  ///< planar GBR 4:4:4 30bpp, big endian
-    PIX_FMT_GBRP10LE,  ///< planar GBR 4:4:4 30bpp, little endian
-    PIX_FMT_GBRP16BE,  ///< planar GBR 4:4:4 48bpp, big endian
-    PIX_FMT_GBRP16LE,  ///< planar GBR 4:4:4 48bpp, little endian
-
-#ifndef AV_PIX_FMT_ABI_GIT_MASTER
-    PIX_FMT_RGBA64BE=0x123,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
-    PIX_FMT_RGBA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
-    PIX_FMT_BGRA64BE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
-    PIX_FMT_BGRA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
-#endif
-    PIX_FMT_0RGB=0x123+4,      ///< packed RGB 8:8:8, 32bpp, 0RGB0RGB...
-    PIX_FMT_RGB0,      ///< packed RGB 8:8:8, 32bpp, RGB0RGB0...
-    PIX_FMT_0BGR,      ///< packed BGR 8:8:8, 32bpp, 0BGR0BGR...
-    PIX_FMT_BGR0,      ///< packed BGR 8:8:8, 32bpp, BGR0BGR0...
-    PIX_FMT_YUVA444P,  ///< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)
-    PIX_FMT_YUVA422P,  ///< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)
-
-    PIX_FMT_YUV420P12BE, ///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    PIX_FMT_YUV420P12LE, ///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    PIX_FMT_YUV420P14BE, ///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    PIX_FMT_YUV420P14LE, ///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    PIX_FMT_YUV422P12BE, ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    PIX_FMT_YUV422P12LE, ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    PIX_FMT_YUV422P14BE, ///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    PIX_FMT_YUV422P14LE, ///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    PIX_FMT_YUV444P12BE, ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-    PIX_FMT_YUV444P12LE, ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    PIX_FMT_YUV444P14BE, ///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-    PIX_FMT_YUV444P14LE, ///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    PIX_FMT_GBRP12BE,    ///< planar GBR 4:4:4 36bpp, big endian
-    PIX_FMT_GBRP12LE,    ///< planar GBR 4:4:4 36bpp, little endian
-    PIX_FMT_GBRP14BE,    ///< planar GBR 4:4:4 42bpp, big endian
-    PIX_FMT_GBRP14LE,    ///< planar GBR 4:4:4 42bpp, little endian
-
-    PIX_FMT_NB,        ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
-#endif /* AVUTIL_OLD_PIX_FMTS_H */
diff -pruN /usr/include/ffmpeg/libavutil/opt.h csrc/libavutil/opt.h
--- /usr/include/ffmpeg/libavutil/opt.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/opt.h	2014-10-20 12:52:22.425496801 +0200
@@ -1,221 +1,9 @@
-/*
- * AVOptions
- * copyright (c) 2005 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
 
 #ifndef AVUTIL_OPT_H
 #define AVUTIL_OPT_H
 
-/**
- * @file
- * AVOptions
- */
-
+#include "common.h"
 #include "rational.h"
-#include "avutil.h"
-#include "dict.h"
-#include "log.h"
-#include "pixfmt.h"
-#include "samplefmt.h"
-
-/**
- * @defgroup avoptions AVOptions
- * @ingroup lavu_data
- * @{
- * AVOptions provide a generic system to declare options on arbitrary structs
- * ("objects"). An option can have a help text, a type and a range of possible
- * values. Options may then be enumerated, read and written to.
- *
- * @section avoptions_implement Implementing AVOptions
- * This section describes how to add AVOptions capabilities to a struct.
- *
- * All AVOptions-related information is stored in an AVClass. Therefore
- * the first member of the struct should be a pointer to an AVClass describing it.
- * The option field of the AVClass must be set to a NULL-terminated static array
- * of AVOptions. Each AVOption must have a non-empty name, a type, a default
- * value and for number-type AVOptions also a range of allowed values. It must
- * also declare an offset in bytes from the start of the struct, where the field
- * associated with this AVOption is located. Other fields in the AVOption struct
- * should also be set when applicable, but are not required.
- *
- * The following example illustrates an AVOptions-enabled struct:
- * @code
- * typedef struct test_struct {
- *     AVClass *class;
- *     int      int_opt;
- *     char    *str_opt;
- *     uint8_t *bin_opt;
- *     int      bin_len;
- * } test_struct;
- *
- * static const AVOption test_options[] = {
- *   { "test_int", "This is a test option of int type.", offsetof(test_struct, int_opt),
- *     AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },
- *   { "test_str", "This is a test option of string type.", offsetof(test_struct, str_opt),
- *     AV_OPT_TYPE_STRING },
- *   { "test_bin", "This is a test option of binary type.", offsetof(test_struct, bin_opt),
- *     AV_OPT_TYPE_BINARY },
- *   { NULL },
- * };
- *
- * static const AVClass test_class = {
- *     .class_name = "test class",
- *     .item_name  = av_default_item_name,
- *     .option     = test_options,
- *     .version    = LIBAVUTIL_VERSION_INT,
- * };
- * @endcode
- *
- * Next, when allocating your struct, you must ensure that the AVClass pointer
- * is set to the correct value. Then, av_opt_set_defaults() can be called to
- * initialize defaults. After that the struct is ready to be used with the
- * AVOptions API.
- *
- * When cleaning up, you may use the av_opt_free() function to automatically
- * free all the allocated string and binary options.
- *
- * Continuing with the above example:
- *
- * @code
- * test_struct *alloc_test_struct(void)
- * {
- *     test_struct *ret = av_malloc(sizeof(*ret));
- *     ret->class = &test_class;
- *     av_opt_set_defaults(ret);
- *     return ret;
- * }
- * void free_test_struct(test_struct **foo)
- * {
- *     av_opt_free(*foo);
- *     av_freep(foo);
- * }
- * @endcode
- *
- * @subsection avoptions_implement_nesting Nesting
- *      It may happen that an AVOptions-enabled struct contains another
- *      AVOptions-enabled struct as a member (e.g. AVCodecContext in
- *      libavcodec exports generic options, while its priv_data field exports
- *      codec-specific options). In such a case, it is possible to set up the
- *      parent struct to export a child's options. To do that, simply
- *      implement AVClass.child_next() and AVClass.child_class_next() in the
- *      parent struct's AVClass.
- *      Assuming that the test_struct from above now also contains a
- *      child_struct field:
- *
- *      @code
- *      typedef struct child_struct {
- *          AVClass *class;
- *          int flags_opt;
- *      } child_struct;
- *      static const AVOption child_opts[] = {
- *          { "test_flags", "This is a test option of flags type.",
- *            offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },
- *          { NULL },
- *      };
- *      static const AVClass child_class = {
- *          .class_name = "child class",
- *          .item_name  = av_default_item_name,
- *          .option     = child_opts,
- *          .version    = LIBAVUTIL_VERSION_INT,
- *      };
- *
- *      void *child_next(void *obj, void *prev)
- *      {
- *          test_struct *t = obj;
- *          if (!prev && t->child_struct)
- *              return t->child_struct;
- *          return NULL
- *      }
- *      const AVClass child_class_next(const AVClass *prev)
- *      {
- *          return prev ? NULL : &child_class;
- *      }
- *      @endcode
- *      Putting child_next() and child_class_next() as defined above into
- *      test_class will now make child_struct's options accessible through
- *      test_struct (again, proper setup as described above needs to be done on
- *      child_struct right after it is created).
- *
- *      From the above example it might not be clear why both child_next()
- *      and child_class_next() are needed. The distinction is that child_next()
- *      iterates over actually existing objects, while child_class_next()
- *      iterates over all possible child classes. E.g. if an AVCodecContext
- *      was initialized to use a codec which has private options, then its
- *      child_next() will return AVCodecContext.priv_data and finish
- *      iterating. OTOH child_class_next() on AVCodecContext.av_class will
- *      iterate over all available codecs with private options.
- *
- * @subsection avoptions_implement_named_constants Named constants
- *      It is possible to create named constants for options. Simply set the unit
- *      field of the option the constants should apply to a string and
- *      create the constants themselves as options of type AV_OPT_TYPE_CONST
- *      with their unit field set to the same string.
- *      Their default_val field should contain the value of the named
- *      constant.
- *      For example, to add some named constants for the test_flags option
- *      above, put the following into the child_opts array:
- *      @code
- *      { "test_flags", "This is a test option of flags type.",
- *        offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, "test_unit" },
- *      { "flag1", "This is a flag with value 16", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, "test_unit" },
- *      @endcode
- *
- * @section avoptions_use Using AVOptions
- * This section deals with accessing options in an AVOptions-enabled struct.
- * Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or
- * AVFormatContext in libavformat.
- *
- * @subsection avoptions_use_examine Examining AVOptions
- * The basic functions for examining options are av_opt_next(), which iterates
- * over all options defined for one object, and av_opt_find(), which searches
- * for an option with the given name.
- *
- * The situation is more complicated with nesting. An AVOptions-enabled struct
- * may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag
- * to av_opt_find() will make the function search children recursively.
- *
- * For enumerating there are basically two cases. The first is when you want to
- * get all options that may potentially exist on the struct and its children
- * (e.g.  when constructing documentation). In that case you should call
- * av_opt_child_class_next() recursively on the parent struct's AVClass.  The
- * second case is when you have an already initialized struct with all its
- * children and you want to get all options that can be actually written or read
- * from it. In that case you should call av_opt_child_next() recursively (and
- * av_opt_next() on each result).
- *
- * @subsection avoptions_use_get_set Reading and writing AVOptions
- * When setting options, you often have a string read directly from the
- * user. In such a case, simply passing it to av_opt_set() is enough. For
- * non-string type options, av_opt_set() will parse the string according to the
- * option type.
- *
- * Similarly av_opt_get() will read any option type and convert it to a string
- * which will be returned. Do not forget that the string is allocated, so you
- * have to free it with av_free().
- *
- * In some cases it may be more convenient to put all options into an
- * AVDictionary and call av_opt_set_dict() on it. A specific case of this
- * are the format/codec open functions in lavf/lavc which take a dictionary
- * filled with option as a parameter. This allows to set some options
- * that cannot be set otherwise, since e.g. the input file format is not known
- * before the file is actually opened.
- */
 
 enum AVOptionType{
     AV_OPT_TYPE_FLAGS,
@@ -234,220 +22,24 @@ enum AVOptionType{
     AV_OPT_TYPE_DURATION   = MKBETAG('D','U','R',' '),
     AV_OPT_TYPE_COLOR      = MKBETAG('C','O','L','R'),
     AV_OPT_TYPE_CHANNEL_LAYOUT = MKBETAG('C','H','L','A'),
-#if FF_API_OLD_AVOPTIONS
-    FF_OPT_TYPE_FLAGS = 0,
-    FF_OPT_TYPE_INT,
-    FF_OPT_TYPE_INT64,
-    FF_OPT_TYPE_DOUBLE,
-    FF_OPT_TYPE_FLOAT,
-    FF_OPT_TYPE_STRING,
-    FF_OPT_TYPE_RATIONAL,
-    FF_OPT_TYPE_BINARY,  ///< offset must point to a pointer immediately followed by an int for the length
-    FF_OPT_TYPE_CONST=128,
-#endif
 };
 
 /**
  * AVOption
  */
-typedef struct AVOption {
-    const char *name;
-
-    /**
-     * short English help text
-     * @todo What about other languages?
-     */
-    const char *help;
-
-    /**
-     * The offset relative to the context structure where the option
-     * value is stored. It should be 0 for named constants.
-     */
-    int offset;
-    enum AVOptionType type;
-
-    /**
-     * the default value for scalar options
-     */
-    union {
-        int64_t i64;
-        double dbl;
-        const char *str;
-        /* TODO those are unused now */
-        AVRational q;
-    } default_val;
-    double min;                 ///< minimum valid value for the option
-    double max;                 ///< maximum valid value for the option
-
-    int flags;
-#define AV_OPT_FLAG_ENCODING_PARAM  1   ///< a generic parameter which can be set by the user for muxing or encoding
-#define AV_OPT_FLAG_DECODING_PARAM  2   ///< a generic parameter which can be set by the user for demuxing or decoding
-#if FF_API_OPT_TYPE_METADATA
-#define AV_OPT_FLAG_METADATA        4   ///< some data extracted or inserted into the file like title, comment, ...
-#endif
-#define AV_OPT_FLAG_AUDIO_PARAM     8
-#define AV_OPT_FLAG_VIDEO_PARAM     16
-#define AV_OPT_FLAG_SUBTITLE_PARAM  32
-/**
- * The option is inteded for exporting values to the caller.
- */
-#define AV_OPT_FLAG_EXPORT          64
-/**
- * The option may not be set through the AVOptions API, only read.
- * This flag only makes sense when AV_OPT_FLAG_EXPORT is also set.
- */
-#define AV_OPT_FLAG_READONLY        128
-#define AV_OPT_FLAG_FILTERING_PARAM (1<<16) ///< a generic parameter which can be set by the user for filtering
-//FIXME think about enc-audio, ... style flags
-
-    /**
-     * The logical unit to which the option belongs. Non-constant
-     * options and corresponding named constants share the same
-     * unit. May be NULL.
-     */
-    const char *unit;
-} AVOption;
+typedef struct AVOption;
 
 /**
  * A single allowed range of values, or a single allowed value.
  */
-typedef struct AVOptionRange {
-    const char *str;
-    /**
-     * Value range.
-     * For string ranges this represents the min/max length.
-     * For dimensions this represents the min/max pixel count or width/height in multi-component case.
-     */
-    double value_min, value_max;
-    /**
-     * Value's component range.
-     * For string this represents the unicode range for chars, 0-127 limits to ASCII.
-     */
-    double component_min, component_max;
-    /**
-     * Range flag.
-     * If set to 1 the struct encodes a range, if set to 0 a single value.
-     */
-    int is_range;
-} AVOptionRange;
+typedef struct AVOptionRange;
 
 /**
  * List of AVOptionRange structs.
  */
-typedef struct AVOptionRanges {
-    /**
-     * Array of option ranges.
-     *
-     * Most of option types use just one component.
-     * Following describes multi-component option types:
-     *
-     * AV_OPT_TYPE_IMAGE_SIZE:
-     * component index 0: range of pixel count (width * height).
-     * component index 1: range of width.
-     * component index 2: range of height.
-     *
-     * @note To obtain multi-component version of this structure, user must
-     *       provide AV_OPT_MULTI_COMPONENT_RANGE to av_opt_query_ranges or
-     *       av_opt_query_ranges_default function.
-     *
-     * Multi-component range can be read as in following example:
-     *
-     * @code
-     * int range_index, component_index;
-     * AVOptionRanges *ranges;
-     * AVOptionRange *range[3]; //may require more than 3 in the future.
-     * av_opt_query_ranges(&ranges, obj, key, AV_OPT_MULTI_COMPONENT_RANGE);
-     * for (range_index = 0; range_index < ranges->nb_ranges; range_index++) {
-     *     for (component_index = 0; component_index < ranges->nb_components; component_index++)
-     *         range[component_index] = ranges->range[ranges->nb_ranges * component_index + range_index];
-     *     //do something with range here.
-     * }
-     * av_opt_freep_ranges(&ranges);
-     * @endcode
-     */
-    AVOptionRange **range;
-    /**
-     * Number of ranges per component.
-     */
-    int nb_ranges;
-    /**
-     * Number of componentes.
-     */
-    int nb_components;
-} AVOptionRanges;
+typedef struct AVOptionRanges;
 
 
-#if FF_API_FIND_OPT
-/**
- * Look for an option in obj. Look only for the options which
- * have the flags set as specified in mask and flags (that is,
- * for which it is the case that (opt->flags & mask) == flags).
- *
- * @param[in] obj a pointer to a struct whose first element is a
- * pointer to an AVClass
- * @param[in] name the name of the option to look for
- * @param[in] unit the unit of the option to look for, or any if NULL
- * @return a pointer to the option found, or NULL if no option
- * has been found
- *
- * @deprecated use av_opt_find.
- */
-attribute_deprecated
-const AVOption *av_find_opt(void *obj, const char *name, const char *unit, int mask, int flags);
-#endif
-
-#if FF_API_OLD_AVOPTIONS
-/**
- * Set the field of obj with the given name to value.
- *
- * @param[in] obj A struct whose first element is a pointer to an
- * AVClass.
- * @param[in] name the name of the field to set
- * @param[in] val The value to set. If the field is not of a string
- * type, then the given string is parsed.
- * SI postfixes and some named scalars are supported.
- * If the field is of a numeric type, it has to be a numeric or named
- * scalar. Behavior with more than one scalar and +- infix operators
- * is undefined.
- * If the field is of a flags type, it has to be a sequence of numeric
- * scalars or named flags separated by '+' or '-'. Prefixing a flag
- * with '+' causes it to be set without affecting the other flags;
- * similarly, '-' unsets a flag.
- * @param[out] o_out if non-NULL put here a pointer to the AVOption
- * found
- * @param alloc this parameter is currently ignored
- * @return 0 if the value has been set, or an AVERROR code in case of
- * error:
- * AVERROR_OPTION_NOT_FOUND if no matching option exists
- * AVERROR(ERANGE) if the value is out of range
- * AVERROR(EINVAL) if the value is not valid
- * @deprecated use av_opt_set()
- */
-attribute_deprecated
-int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out);
-
-attribute_deprecated const AVOption *av_set_double(void *obj, const char *name, double n);
-attribute_deprecated const AVOption *av_set_q(void *obj, const char *name, AVRational n);
-attribute_deprecated const AVOption *av_set_int(void *obj, const char *name, int64_t n);
-
-double av_get_double(void *obj, const char *name, const AVOption **o_out);
-AVRational av_get_q(void *obj, const char *name, const AVOption **o_out);
-int64_t av_get_int(void *obj, const char *name, const AVOption **o_out);
-attribute_deprecated const char *av_get_string(void *obj, const char *name, const AVOption **o_out, char *buf, int buf_len);
-attribute_deprecated const AVOption *av_next_option(void *obj, const AVOption *last);
-#endif
-
-/**
- * Show the obj options.
- *
- * @param req_flags requested flags for the options to show. Show only the
- * options for which it is opt->flags & req_flags.
- * @param rej_flags rejected flags for the options to show. Show only the
- * options for which it is !(opt->flags & req_flags).
- * @param av_log_obj log context to use for showing the options
- */
-int av_opt_show2(void *obj, void *av_log_obj, int req_flags, int rej_flags);
-
 /**
  * Set the values of all AVOption fields to their default values.
  *
@@ -455,77 +47,12 @@ int av_opt_show2(void *obj, void *av_log
  */
 void av_opt_set_defaults(void *s);
 
-#if FF_API_OLD_AVOPTIONS
-attribute_deprecated
-void av_opt_set_defaults2(void *s, int mask, int flags);
-#endif
-
-/**
- * Parse the key/value pairs list in opts. For each key/value pair
- * found, stores the value in the field in ctx that is named like the
- * key. ctx must be an AVClass context, storing is done using
- * AVOptions.
- *
- * @param opts options string to parse, may be NULL
- * @param key_val_sep a 0-terminated list of characters used to
- * separate key from value
- * @param pairs_sep a 0-terminated list of characters used to separate
- * two pairs from each other
- * @return the number of successfully set key/value pairs, or a negative
- * value corresponding to an AVERROR code in case of error:
- * AVERROR(EINVAL) if opts cannot be parsed,
- * the error code issued by av_set_string3() if a key/value pair
- * cannot be set
- */
-int av_set_options_string(void *ctx, const char *opts,
-                          const char *key_val_sep, const char *pairs_sep);
-
-/**
- * Parse the key-value pairs list in opts. For each key=value pair found,
- * set the value of the corresponding option in ctx.
- *
- * @param ctx          the AVClass object to set options on
- * @param opts         the options string, key-value pairs separated by a
- *                     delimiter
- * @param shorthand    a NULL-terminated array of options names for shorthand
- *                     notation: if the first field in opts has no key part,
- *                     the key is taken from the first element of shorthand;
- *                     then again for the second, etc., until either opts is
- *                     finished, shorthand is finished or a named option is
- *                     found; after that, all options must be named
- * @param key_val_sep  a 0-terminated list of characters used to separate
- *                     key from value, for example '='
- * @param pairs_sep    a 0-terminated list of characters used to separate
- *                     two pairs from each other, for example ':' or ','
- * @return  the number of successfully set key=value pairs, or a negative
- *          value corresponding to an AVERROR code in case of error:
- *          AVERROR(EINVAL) if opts cannot be parsed,
- *          the error code issued by av_set_string3() if a key/value pair
- *          cannot be set
- *
- * Options names must use only the following characters: a-z A-Z 0-9 - . / _
- * Separators must use characters distinct from option names and from each
- * other.
- */
-int av_opt_set_from_string(void *ctx, const char *opts,
-                           const char *const *shorthand,
-                           const char *key_val_sep, const char *pairs_sep);
 /**
  * Free all string and binary options in obj.
  */
 void av_opt_free(void *obj);
 
 /**
- * Check whether a particular flag is set in a flags field.
- *
- * @param field_name the name of the flag field option
- * @param flag_name the name of the flag to check
- * @return non-zero if the flag is set, zero if the flag isn't set,
- *         isn't of the right type, or the flags field doesn't exist.
- */
-int av_opt_flag_is_set(void *obj, const char *field_name, const char *flag_name);
-
-/**
  * Set all the options from a given dictionary on an object.
  *
  * @param obj a struct whose first element is a pointer to AVClass
@@ -541,307 +68,4 @@ int av_opt_flag_is_set(void *obj, const
  */
 int av_opt_set_dict(void *obj, struct AVDictionary **options);
 
-
-/**
- * Set all the options from a given dictionary on an object.
- *
- * @param obj a struct whose first element is a pointer to AVClass
- * @param options options to process. This dictionary will be freed and replaced
- *                by a new one containing all options not found in obj.
- *                Of course this new dictionary needs to be freed by caller
- *                with av_dict_free().
- * @param search_flags A combination of AV_OPT_SEARCH_*.
- *
- * @return 0 on success, a negative AVERROR if some option was found in obj,
- *         but could not be set.
- *
- * @see av_dict_copy()
- */
-int av_opt_set_dict2(void *obj, struct AVDictionary **options, int search_flags);
-
-/**
- * Extract a key-value pair from the beginning of a string.
- *
- * @param ropts        pointer to the options string, will be updated to
- *                     point to the rest of the string (one of the pairs_sep
- *                     or the final NUL)
- * @param key_val_sep  a 0-terminated list of characters used to separate
- *                     key from value, for example '='
- * @param pairs_sep    a 0-terminated list of characters used to separate
- *                     two pairs from each other, for example ':' or ','
- * @param flags        flags; see the AV_OPT_FLAG_* values below
- * @param rkey         parsed key; must be freed using av_free()
- * @param rval         parsed value; must be freed using av_free()
- *
- * @return  >=0 for success, or a negative value corresponding to an
- *          AVERROR code in case of error; in particular:
- *          AVERROR(EINVAL) if no key is present
- *
- */
-int av_opt_get_key_value(const char **ropts,
-                         const char *key_val_sep, const char *pairs_sep,
-                         unsigned flags,
-                         char **rkey, char **rval);
-
-enum {
-
-    /**
-     * Accept to parse a value without a key; the key will then be returned
-     * as NULL.
-     */
-    AV_OPT_FLAG_IMPLICIT_KEY = 1,
-};
-
-/**
- * @defgroup opt_eval_funcs Evaluating option strings
- * @{
- * This group of functions can be used to evaluate option strings
- * and get numbers out of them. They do the same thing as av_opt_set(),
- * except the result is written into the caller-supplied pointer.
- *
- * @param obj a struct whose first element is a pointer to AVClass.
- * @param o an option for which the string is to be evaluated.
- * @param val string to be evaluated.
- * @param *_out value of the string will be written here.
- *
- * @return 0 on success, a negative number on failure.
- */
-int av_opt_eval_flags (void *obj, const AVOption *o, const char *val, int        *flags_out);
-int av_opt_eval_int   (void *obj, const AVOption *o, const char *val, int        *int_out);
-int av_opt_eval_int64 (void *obj, const AVOption *o, const char *val, int64_t    *int64_out);
-int av_opt_eval_float (void *obj, const AVOption *o, const char *val, float      *float_out);
-int av_opt_eval_double(void *obj, const AVOption *o, const char *val, double     *double_out);
-int av_opt_eval_q     (void *obj, const AVOption *o, const char *val, AVRational *q_out);
-/**
- * @}
- */
-
-#define AV_OPT_SEARCH_CHILDREN   0x0001 /**< Search in possible children of the
-                                             given object first. */
-/**
- *  The obj passed to av_opt_find() is fake -- only a double pointer to AVClass
- *  instead of a required pointer to a struct containing AVClass. This is
- *  useful for searching for options without needing to allocate the corresponding
- *  object.
- */
-#define AV_OPT_SEARCH_FAKE_OBJ   0x0002
-
-/**
- *  Allows av_opt_query_ranges and av_opt_query_ranges_default to return more than
- *  one component for certain option types.
- *  @see AVOptionRanges for details.
- */
-#define AV_OPT_MULTI_COMPONENT_RANGE 0x1000
-
-/**
- * Look for an option in an object. Consider only options which
- * have all the specified flags set.
- *
- * @param[in] obj A pointer to a struct whose first element is a
- *                pointer to an AVClass.
- *                Alternatively a double pointer to an AVClass, if
- *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.
- * @param[in] name The name of the option to look for.
- * @param[in] unit When searching for named constants, name of the unit
- *                 it belongs to.
- * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
- * @param search_flags A combination of AV_OPT_SEARCH_*.
- *
- * @return A pointer to the option found, or NULL if no option
- *         was found.
- *
- * @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable
- * directly with av_set_string3(). Use special calls which take an options
- * AVDictionary (e.g. avformat_open_input()) to set options found with this
- * flag.
- */
-const AVOption *av_opt_find(void *obj, const char *name, const char *unit,
-                            int opt_flags, int search_flags);
-
-/**
- * Look for an option in an object. Consider only options which
- * have all the specified flags set.
- *
- * @param[in] obj A pointer to a struct whose first element is a
- *                pointer to an AVClass.
- *                Alternatively a double pointer to an AVClass, if
- *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.
- * @param[in] name The name of the option to look for.
- * @param[in] unit When searching for named constants, name of the unit
- *                 it belongs to.
- * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
- * @param search_flags A combination of AV_OPT_SEARCH_*.
- * @param[out] target_obj if non-NULL, an object to which the option belongs will be
- * written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present
- * in search_flags. This parameter is ignored if search_flags contain
- * AV_OPT_SEARCH_FAKE_OBJ.
- *
- * @return A pointer to the option found, or NULL if no option
- *         was found.
- */
-const AVOption *av_opt_find2(void *obj, const char *name, const char *unit,
-                             int opt_flags, int search_flags, void **target_obj);
-
-/**
- * Iterate over all AVOptions belonging to obj.
- *
- * @param obj an AVOptions-enabled struct or a double pointer to an
- *            AVClass describing it.
- * @param prev result of the previous call to av_opt_next() on this object
- *             or NULL
- * @return next AVOption or NULL
- */
-const AVOption *av_opt_next(void *obj, const AVOption *prev);
-
-/**
- * Iterate over AVOptions-enabled children of obj.
- *
- * @param prev result of a previous call to this function or NULL
- * @return next AVOptions-enabled child or NULL
- */
-void *av_opt_child_next(void *obj, void *prev);
-
-/**
- * Iterate over potential AVOptions-enabled children of parent.
- *
- * @param prev result of a previous call to this function or NULL
- * @return AVClass corresponding to next potential child or NULL
- */
-const AVClass *av_opt_child_class_next(const AVClass *parent, const AVClass *prev);
-
-/**
- * @defgroup opt_set_funcs Option setting functions
- * @{
- * Those functions set the field of obj with the given name to value.
- *
- * @param[in] obj A struct whose first element is a pointer to an AVClass.
- * @param[in] name the name of the field to set
- * @param[in] val The value to set. In case of av_opt_set() if the field is not
- * of a string type, then the given string is parsed.
- * SI postfixes and some named scalars are supported.
- * If the field is of a numeric type, it has to be a numeric or named
- * scalar. Behavior with more than one scalar and +- infix operators
- * is undefined.
- * If the field is of a flags type, it has to be a sequence of numeric
- * scalars or named flags separated by '+' or '-'. Prefixing a flag
- * with '+' causes it to be set without affecting the other flags;
- * similarly, '-' unsets a flag.
- * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
- * is passed here, then the option may be set on a child of obj.
- *
- * @return 0 if the value has been set, or an AVERROR code in case of
- * error:
- * AVERROR_OPTION_NOT_FOUND if no matching option exists
- * AVERROR(ERANGE) if the value is out of range
- * AVERROR(EINVAL) if the value is not valid
- */
-int av_opt_set       (void *obj, const char *name, const char *val, int search_flags);
-int av_opt_set_int   (void *obj, const char *name, int64_t     val, int search_flags);
-int av_opt_set_double(void *obj, const char *name, double      val, int search_flags);
-int av_opt_set_q     (void *obj, const char *name, AVRational  val, int search_flags);
-int av_opt_set_bin   (void *obj, const char *name, const uint8_t *val, int size, int search_flags);
-int av_opt_set_image_size(void *obj, const char *name, int w, int h, int search_flags);
-int av_opt_set_pixel_fmt (void *obj, const char *name, enum AVPixelFormat fmt, int search_flags);
-int av_opt_set_sample_fmt(void *obj, const char *name, enum AVSampleFormat fmt, int search_flags);
-int av_opt_set_video_rate(void *obj, const char *name, AVRational val, int search_flags);
-int av_opt_set_channel_layout(void *obj, const char *name, int64_t ch_layout, int search_flags);
-
-/**
- * Set a binary option to an integer list.
- *
- * @param obj    AVClass object to set options on
- * @param name   name of the binary option
- * @param val    pointer to an integer list (must have the correct type with
- *               regard to the contents of the list)
- * @param term   list terminator (usually 0 or -1)
- * @param flags  search flags
- */
-#define av_opt_set_int_list(obj, name, val, term, flags) \
-    (av_int_list_length(val, term) > INT_MAX / sizeof(*(val)) ? \
-     AVERROR(EINVAL) : \
-     av_opt_set_bin(obj, name, (const uint8_t *)(val), \
-                    av_int_list_length(val, term) * sizeof(*(val)), flags))
-/**
- * @}
- */
-
-/**
- * @defgroup opt_get_funcs Option getting functions
- * @{
- * Those functions get a value of the option with the given name from an object.
- *
- * @param[in] obj a struct whose first element is a pointer to an AVClass.
- * @param[in] name name of the option to get.
- * @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
- * is passed here, then the option may be found in a child of obj.
- * @param[out] out_val value of the option will be written here
- * @return >=0 on success, a negative error code otherwise
- */
-/**
- * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller
- */
-int av_opt_get       (void *obj, const char *name, int search_flags, uint8_t   **out_val);
-int av_opt_get_int   (void *obj, const char *name, int search_flags, int64_t    *out_val);
-int av_opt_get_double(void *obj, const char *name, int search_flags, double     *out_val);
-int av_opt_get_q     (void *obj, const char *name, int search_flags, AVRational *out_val);
-int av_opt_get_image_size(void *obj, const char *name, int search_flags, int *w_out, int *h_out);
-int av_opt_get_pixel_fmt (void *obj, const char *name, int search_flags, enum AVPixelFormat *out_fmt);
-int av_opt_get_sample_fmt(void *obj, const char *name, int search_flags, enum AVSampleFormat *out_fmt);
-int av_opt_get_video_rate(void *obj, const char *name, int search_flags, AVRational *out_val);
-int av_opt_get_channel_layout(void *obj, const char *name, int search_flags, int64_t *ch_layout);
-/**
- * @}
- */
-/**
- * Gets a pointer to the requested field in a struct.
- * This function allows accessing a struct even when its fields are moved or
- * renamed since the application making the access has been compiled,
- *
- * @returns a pointer to the field, it can be cast to the correct type and read
- *          or written to.
- */
-void *av_opt_ptr(const AVClass *avclass, void *obj, const char *name);
-
-/**
- * Free an AVOptionRanges struct and set it to NULL.
- */
-void av_opt_freep_ranges(AVOptionRanges **ranges);
-
-/**
- * Get a list of allowed ranges for the given option.
- *
- * The returned list may depend on other fields in obj like for example profile.
- *
- * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
- *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
- *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
- *
- * The result must be freed with av_opt_freep_ranges.
- *
- * @return number of compontents returned on success, a negative errro code otherwise
- */
-int av_opt_query_ranges(AVOptionRanges **, void *obj, const char *key, int flags);
-
-int av_opt_copy(void *dest, void *src);
-
-/**
- * Get a default list of allowed ranges for the given option.
- *
- * This list is constructed without using the AVClass.query_ranges() callback
- * and can be used as fallback from within the callback.
- *
- * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
- *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
- *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
- *
- * The result must be freed with av_opt_free_ranges.
- *
- * @return number of compontents returned on success, a negative errro code otherwise
- */
-int av_opt_query_ranges_default(AVOptionRanges **, void *obj, const char *key, int flags);
-
-/**
- * @}
- */
-
 #endif /* AVUTIL_OPT_H */
diff -pruN /usr/include/ffmpeg/libavutil/parseutils.h csrc/libavutil/parseutils.h
--- /usr/include/ffmpeg/libavutil/parseutils.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/parseutils.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,187 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_PARSEUTILS_H
-#define AVUTIL_PARSEUTILS_H
-
-#include <time.h>
-
-#include "rational.h"
-
-/**
- * @file
- * misc parsing utilities
- */
-
-/**
- * Parse str and store the parsed ratio in q.
- *
- * Note that a ratio with infinite (1/0) or negative value is
- * considered valid, so you should check on the returned value if you
- * want to exclude those values.
- *
- * The undefined value can be expressed using the "0:0" string.
- *
- * @param[in,out] q pointer to the AVRational which will contain the ratio
- * @param[in] str the string to parse: it has to be a string in the format
- * num:den, a float number or an expression
- * @param[in] max the maximum allowed numerator and denominator
- * @param[in] log_offset log level offset which is applied to the log
- * level of log_ctx
- * @param[in] log_ctx parent logging context
- * @return >= 0 on success, a negative error code otherwise
- */
-int av_parse_ratio(AVRational *q, const char *str, int max,
-                   int log_offset, void *log_ctx);
-
-#define av_parse_ratio_quiet(rate, str, max) \
-    av_parse_ratio(rate, str, max, AV_LOG_MAX_OFFSET, NULL)
-
-/**
- * Parse str and put in width_ptr and height_ptr the detected values.
- *
- * @param[in,out] width_ptr pointer to the variable which will contain the detected
- * width value
- * @param[in,out] height_ptr pointer to the variable which will contain the detected
- * height value
- * @param[in] str the string to parse: it has to be a string in the format
- * width x height or a valid video size abbreviation.
- * @return >= 0 on success, a negative error code otherwise
- */
-int av_parse_video_size(int *width_ptr, int *height_ptr, const char *str);
-
-/**
- * Parse str and store the detected values in *rate.
- *
- * @param[in,out] rate pointer to the AVRational which will contain the detected
- * frame rate
- * @param[in] str the string to parse: it has to be a string in the format
- * rate_num / rate_den, a float number or a valid video rate abbreviation
- * @return >= 0 on success, a negative error code otherwise
- */
-int av_parse_video_rate(AVRational *rate, const char *str);
-
-/**
- * Put the RGBA values that correspond to color_string in rgba_color.
- *
- * @param color_string a string specifying a color. It can be the name of
- * a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,
- * possibly followed by "@" and a string representing the alpha
- * component.
- * The alpha component may be a string composed by "0x" followed by an
- * hexadecimal number or a decimal number between 0.0 and 1.0, which
- * represents the opacity value (0x00/0.0 means completely transparent,
- * 0xff/1.0 completely opaque).
- * If the alpha component is not specified then 0xff is assumed.
- * The string "random" will result in a random color.
- * @param slen length of the initial part of color_string containing the
- * color. It can be set to -1 if color_string is a null terminated string
- * containing nothing else than the color.
- * @return >= 0 in case of success, a negative value in case of
- * failure (for example if color_string cannot be parsed).
- */
-int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen,
-                   void *log_ctx);
-
-/**
- * Get the name of a color from the internal table of hard-coded named
- * colors.
- *
- * This function is meant to enumerate the color names recognized by
- * av_parse_color().
- *
- * @param color_idx index of the requested color, starting from 0
- * @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB
- * @return the color name string or NULL if color_idx is not in the array
- */
-const char *av_get_known_color_name(int color_idx, const uint8_t **rgb);
-
-/**
- * Parse timestr and return in *time a corresponding number of
- * microseconds.
- *
- * @param timeval puts here the number of microseconds corresponding
- * to the string in timestr. If the string represents a duration, it
- * is the number of microseconds contained in the time interval.  If
- * the string is a date, is the number of microseconds since 1st of
- * January, 1970 up to the time of the parsed date.  If timestr cannot
- * be successfully parsed, set *time to INT64_MIN.
-
- * @param timestr a string representing a date or a duration.
- * - If a date the syntax is:
- * @code
- * [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]
- * now
- * @endcode
- * If the value is "now" it takes the current time.
- * Time is local time unless Z is appended, in which case it is
- * interpreted as UTC.
- * If the year-month-day part is not specified it takes the current
- * year-month-day.
- * - If a duration the syntax is:
- * @code
- * [-][HH:]MM:SS[.m...]
- * [-]S+[.m...]
- * @endcode
- * @param duration flag which tells how to interpret timestr, if not
- * zero timestr is interpreted as a duration, otherwise as a date
- * @return >= 0 in case of success, a negative value corresponding to an
- * AVERROR code otherwise
- */
-int av_parse_time(int64_t *timeval, const char *timestr, int duration);
-
-/**
- * Parse the input string p according to the format string fmt and
- * store its results in the structure dt.
- * This implementation supports only a subset of the formats supported
- * by the standard strptime().
- *
- * In particular it actually supports the parameters:
- * - %H: the hour as a decimal number, using a 24-hour clock, in the
- * range '00' through '23'
- * - %J: hours as a decimal number, in the range '0' through INT_MAX
- * - %M: the minute as a decimal number, using a 24-hour clock, in the
- * range '00' through '59'
- * - %S: the second as a decimal number, using a 24-hour clock, in the
- * range '00' through '59'
- * - %Y: the year as a decimal number, using the Gregorian calendar
- * - %m: the month as a decimal number, in the range '1' through '12'
- * - %d: the day of the month as a decimal number, in the range '1'
- * through '31'
- * - %%: a literal '%'
- *
- * @return a pointer to the first character not processed in this
- * function call, or NULL in case the function fails to match all of
- * the fmt string and therefore an error occurred
- */
-char *av_small_strptime(const char *p, const char *fmt, struct tm *dt);
-
-/**
- * Attempt to find a specific tag in a URL.
- *
- * syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.
- * Return 1 if found.
- */
-int av_find_info_tag(char *arg, int arg_size, const char *tag1, const char *info);
-
-/**
- * Convert the decomposed UTC time in tm to a time_t value.
- */
-time_t av_timegm(struct tm *tm);
-
-#endif /* AVUTIL_PARSEUTILS_H */
diff -pruN /usr/include/ffmpeg/libavutil/pixdesc.h csrc/libavutil/pixdesc.h
--- /usr/include/ffmpeg/libavutil/pixdesc.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/pixdesc.h	2014-10-20 12:53:46.078213794 +0200
@@ -22,177 +22,6 @@
 #ifndef AVUTIL_PIXDESC_H
 #define AVUTIL_PIXDESC_H
 
-#include <inttypes.h>
-
-#include "attributes.h"
-#include "pixfmt.h"
-
-typedef struct AVComponentDescriptor{
-    uint16_t plane        :2;            ///< which of the 4 planes contains the component
-
-    /**
-     * Number of elements between 2 horizontally consecutive pixels minus 1.
-     * Elements are bits for bitstream formats, bytes otherwise.
-     */
-    uint16_t step_minus1  :3;
-
-    /**
-     * Number of elements before the component of the first pixel plus 1.
-     * Elements are bits for bitstream formats, bytes otherwise.
-     */
-    uint16_t offset_plus1 :3;
-    uint16_t shift        :3;            ///< number of least significant bits that must be shifted away to get the value
-    uint16_t depth_minus1 :4;            ///< number of bits in the component minus 1
-}AVComponentDescriptor;
-
-/**
- * Descriptor that unambiguously describes how the bits of a pixel are
- * stored in the up to 4 data planes of an image. It also stores the
- * subsampling factors and number of components.
- *
- * @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV
- *       and all the YUV variants) AVPixFmtDescriptor just stores how values
- *       are stored not what these values represent.
- */
-typedef struct AVPixFmtDescriptor{
-    const char *name;
-    uint8_t nb_components;      ///< The number of components each pixel has, (1-4)
-
-    /**
-     * Amount to shift the luma width right to find the chroma width.
-     * For YV12 this is 1 for example.
-     * chroma_width = -((-luma_width) >> log2_chroma_w)
-     * The note above is needed to ensure rounding up.
-     * This value only refers to the chroma components.
-     */
-    uint8_t log2_chroma_w;      ///< chroma_width = -((-luma_width )>>log2_chroma_w)
-
-    /**
-     * Amount to shift the luma height right to find the chroma height.
-     * For YV12 this is 1 for example.
-     * chroma_height= -((-luma_height) >> log2_chroma_h)
-     * The note above is needed to ensure rounding up.
-     * This value only refers to the chroma components.
-     */
-    uint8_t log2_chroma_h;
-    uint8_t flags;
-
-    /**
-     * Parameters that describe how pixels are packed.
-     * If the format has 2 or 4 components, then alpha is last.
-     * If the format has 1 or 2 components, then luma is 0.
-     * If the format has 3 or 4 components,
-     * if the RGB flag is set then 0 is red, 1 is green and 2 is blue;
-     * otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.
-     */
-    AVComponentDescriptor comp[4];
-}AVPixFmtDescriptor;
-
-/**
- * Pixel format is big-endian.
- */
-#define AV_PIX_FMT_FLAG_BE           (1 << 0)
-/**
- * Pixel format has a palette in data[1], values are indexes in this palette.
- */
-#define AV_PIX_FMT_FLAG_PAL          (1 << 1)
-/**
- * All values of a component are bit-wise packed end to end.
- */
-#define AV_PIX_FMT_FLAG_BITSTREAM    (1 << 2)
-/**
- * Pixel format is an HW accelerated format.
- */
-#define AV_PIX_FMT_FLAG_HWACCEL      (1 << 3)
-/**
- * At least one pixel component is not in the first data plane.
- */
-#define AV_PIX_FMT_FLAG_PLANAR       (1 << 4)
-/**
- * The pixel format contains RGB-like data (as opposed to YUV/grayscale).
- */
-#define AV_PIX_FMT_FLAG_RGB          (1 << 5)
-/**
- * The pixel format is "pseudo-paletted". This means that FFmpeg treats it as
- * paletted internally, but the palette is generated by the decoder and is not
- * stored in the file.
- */
-#define AV_PIX_FMT_FLAG_PSEUDOPAL    (1 << 6)
-/**
- * The pixel format has an alpha channel.
- */
-#define AV_PIX_FMT_FLAG_ALPHA        (1 << 7)
-
-#if FF_API_PIX_FMT
-/**
- * @deprecated use the AV_PIX_FMT_FLAG_* flags
- */
-#define PIX_FMT_BE        AV_PIX_FMT_FLAG_BE
-#define PIX_FMT_PAL       AV_PIX_FMT_FLAG_PAL
-#define PIX_FMT_BITSTREAM AV_PIX_FMT_FLAG_BITSTREAM
-#define PIX_FMT_HWACCEL   AV_PIX_FMT_FLAG_HWACCEL
-#define PIX_FMT_PLANAR    AV_PIX_FMT_FLAG_PLANAR
-#define PIX_FMT_RGB       AV_PIX_FMT_FLAG_RGB
-#define PIX_FMT_PSEUDOPAL AV_PIX_FMT_FLAG_PSEUDOPAL
-#define PIX_FMT_ALPHA     AV_PIX_FMT_FLAG_ALPHA
-#endif
-
-#if FF_API_PIX_FMT_DESC
-/**
- * The array of all the pixel format descriptors.
- */
-extern attribute_deprecated const AVPixFmtDescriptor av_pix_fmt_descriptors[];
-#endif
-
-/**
- * Read a line from an image, and write the values of the
- * pixel format component c to dst.
- *
- * @param data the array containing the pointers to the planes of the image
- * @param linesize the array containing the linesizes of the image
- * @param desc the pixel format descriptor for the image
- * @param x the horizontal coordinate of the first pixel to read
- * @param y the vertical coordinate of the first pixel to read
- * @param w the width of the line to read, that is the number of
- * values to write to dst
- * @param read_pal_component if not zero and the format is a paletted
- * format writes the values corresponding to the palette
- * component c in data[1] to dst, rather than the palette indexes in
- * data[0]. The behavior is undefined if the format is not paletted.
- */
-void av_read_image_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4],
-                        const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component);
-
-/**
- * Write the values from src to the pixel format component c of an
- * image line.
- *
- * @param src array containing the values to write
- * @param data the array containing the pointers to the planes of the
- * image to write into. It is supposed to be zeroed.
- * @param linesize the array containing the linesizes of the image
- * @param desc the pixel format descriptor for the image
- * @param x the horizontal coordinate of the first pixel to write
- * @param y the vertical coordinate of the first pixel to write
- * @param w the width of the line to write, that is the number of
- * values to write to the image line
- */
-void av_write_image_line(const uint16_t *src, uint8_t *data[4], const int linesize[4],
-                         const AVPixFmtDescriptor *desc, int x, int y, int c, int w);
-
-/**
- * Return the pixel format corresponding to name.
- *
- * If there is no pixel format with name name, then looks for a
- * pixel format with the name corresponding to the native endian
- * format of name.
- * For example in a little-endian system, first looks for "gray16",
- * then for "gray16le".
- *
- * Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.
- */
-enum AVPixelFormat av_get_pix_fmt(const char *name);
-
 /**
  * Return the short name for a pixel format, NULL in case pix_fmt is
  * unknown.
@@ -201,139 +30,4 @@ enum AVPixelFormat av_get_pix_fmt(const
  */
 const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt);
 
-/**
- * Print in buf the string corresponding to the pixel format with
- * number pix_fmt, or a header if pix_fmt is negative.
- *
- * @param buf the buffer where to write the string
- * @param buf_size the size of buf
- * @param pix_fmt the number of the pixel format to print the
- * corresponding info string, or a negative value to print the
- * corresponding header.
- */
-char *av_get_pix_fmt_string (char *buf, int buf_size, enum AVPixelFormat pix_fmt);
-
-/**
- * Return the number of bits per pixel used by the pixel format
- * described by pixdesc. Note that this is not the same as the number
- * of bits per sample.
- *
- * The returned number of bits refers to the number of bits actually
- * used for storing the pixel information, that is padding bits are
- * not counted.
- */
-int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc);
-
-/**
- * Return the number of bits per pixel for the pixel format
- * described by pixdesc, including any padding or unused bits.
- */
-int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc);
-
-/**
- * @return a pixel format descriptor for provided pixel format or NULL if
- * this pixel format is unknown.
- */
-const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt);
-
-/**
- * Iterate over all pixel format descriptors known to libavutil.
- *
- * @param prev previous descriptor. NULL to get the first descriptor.
- *
- * @return next descriptor or NULL after the last descriptor
- */
-const AVPixFmtDescriptor *av_pix_fmt_desc_next(const AVPixFmtDescriptor *prev);
-
-/**
- * @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc
- * is not a valid pointer to a pixel format descriptor.
- */
-enum AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor *desc);
-
-/**
- * Utility function to access log2_chroma_w log2_chroma_h from
- * the pixel format AVPixFmtDescriptor.
- *
- * See av_get_chroma_sub_sample() for a function that asserts a
- * valid pixel format instead of returning an error code.
- * Its recommended that you use avcodec_get_chroma_sub_sample unless
- * you do check the return code!
- *
- * @param[in]  pix_fmt the pixel format
- * @param[out] h_shift store log2_chroma_w
- * @param[out] v_shift store log2_chroma_h
- *
- * @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format
- */
-int av_pix_fmt_get_chroma_sub_sample(enum AVPixelFormat pix_fmt,
-                                     int *h_shift, int *v_shift);
-
-/**
- * @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a
- * valid pixel format.
- */
-int av_pix_fmt_count_planes(enum AVPixelFormat pix_fmt);
-
-void ff_check_pixfmt_descriptors(void);
-
-/**
- * Utility function to swap the endianness of a pixel format.
- *
- * @param[in]  pix_fmt the pixel format
- *
- * @return pixel format with swapped endianness if it exists,
- * otherwise AV_PIX_FMT_NONE
- */
-enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt);
-
-#define FF_LOSS_RESOLUTION  0x0001 /**< loss due to resolution change */
-#define FF_LOSS_DEPTH       0x0002 /**< loss due to color depth change */
-#define FF_LOSS_COLORSPACE  0x0004 /**< loss due to color space conversion */
-#define FF_LOSS_ALPHA       0x0008 /**< loss of alpha bits */
-#define FF_LOSS_COLORQUANT  0x0010 /**< loss due to color quantization */
-#define FF_LOSS_CHROMA      0x0020 /**< loss of chroma (e.g. RGB to gray conversion) */
-
-/**
- * Compute what kind of losses will occur when converting from one specific
- * pixel format to another.
- * When converting from one pixel format to another, information loss may occur.
- * For example, when converting from RGB24 to GRAY, the color information will
- * be lost. Similarly, other losses occur when converting from some formats to
- * other formats. These losses can involve loss of chroma, but also loss of
- * resolution, loss of color depth, loss due to the color space conversion, loss
- * of the alpha bits or loss due to color quantization.
- * av_get_fix_fmt_loss() informs you about the various types of losses
- * which will occur when converting from one pixel format to another.
- *
- * @param[in] dst_pix_fmt destination pixel format
- * @param[in] src_pix_fmt source pixel format
- * @param[in] has_alpha Whether the source pixel format alpha channel is used.
- * @return Combination of flags informing you what kind of losses will occur
- * (maximum loss for an invalid dst_pix_fmt).
- */
-int av_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt,
-                        enum AVPixelFormat src_pix_fmt,
-                        int has_alpha);
-
-/**
- * Compute what kind of losses will occur when converting from one specific
- * pixel format to another.
- * When converting from one pixel format to another, information loss may occur.
- * For example, when converting from RGB24 to GRAY, the color information will
- * be lost. Similarly, other losses occur when converting from some formats to
- * other formats. These losses can involve loss of chroma, but also loss of
- * resolution, loss of color depth, loss due to the color space conversion, loss
- * of the alpha bits or loss due to color quantization.
- * av_get_fix_fmt_loss() informs you about the various types of losses
- * which will occur when converting from one pixel format to another.
- *
- * @param[in] dst_pix_fmt destination pixel format
- * @param[in] src_pix_fmt source pixel format
- * @param[in] has_alpha Whether the source pixel format alpha channel is used.
- * @return Combination of flags informing you what kind of losses will occur
- * (maximum loss for an invalid dst_pix_fmt).
- */
-enum AVPixelFormat av_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2,
-                                             enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr);
 #endif /* AVUTIL_PIXDESC_H */
diff -pruN /usr/include/ffmpeg/libavutil/pixfmt.h csrc/libavutil/pixfmt.h
--- /usr/include/ffmpeg/libavutil/pixfmt.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/pixfmt.h	2014-10-20 12:55:24.814885506 +0200
@@ -1,68 +1,7 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
 
 #ifndef AVUTIL_PIXFMT_H
 #define AVUTIL_PIXFMT_H
 
-/**
- * @file
- * pixel format definitions
- *
- */
-
-#include "libavutil/avconfig.h"
-#include "version.h"
-
-#define AVPALETTE_SIZE 1024
-#define AVPALETTE_COUNT 256
-
-/**
- * Pixel format.
- *
- * @note
- * AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA
- * color is put together as:
- *  (A << 24) | (R << 16) | (G << 8) | B
- * This is stored as BGRA on little-endian CPU architectures and ARGB on
- * big-endian CPUs.
- *
- * @par
- * When the pixel format is palettized RGB (AV_PIX_FMT_PAL8), the palettized
- * image data is stored in AVFrame.data[0]. The palette is transported in
- * AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is
- * formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is
- * also endian-specific). Note also that the individual RGB palette
- * components stored in AVFrame.data[1] should be in the range 0..255.
- * This is important as many custom PAL8 video codecs that were designed
- * to run on the IBM VGA graphics adapter use 6-bit palette components.
- *
- * @par
- * For all the 8bit per pixel formats, an RGB32 palette is in data[1] like
- * for pal8. This palette is filled in automatically by the function
- * allocating the picture.
- *
- * @note
- * Make sure that all newly added big-endian formats have (pix_fmt & 1) == 1
- * and that all newly added little-endian formats have (pix_fmt & 1) == 0.
- * This allows simpler detection of big vs little-endian.
- */
 enum AVPixelFormat {
     AV_PIX_FMT_NONE = -1,
     AV_PIX_FMT_YUV420P,   ///< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)
@@ -106,13 +45,6 @@ enum AVPixelFormat {
     AV_PIX_FMT_YUV440P,   ///< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
     AV_PIX_FMT_YUVJ440P,  ///< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of PIX_FMT_YUV440P and setting color_range
     AV_PIX_FMT_YUVA420P,  ///< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
-#if FF_API_VDPAU
-    AV_PIX_FMT_VDPAU_H264,///< H.264 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-    AV_PIX_FMT_VDPAU_MPEG1,///< MPEG-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-    AV_PIX_FMT_VDPAU_MPEG2,///< MPEG-2 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-    AV_PIX_FMT_VDPAU_WMV3,///< WMV3 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-    AV_PIX_FMT_VDPAU_VC1, ///< VC-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-#endif
     AV_PIX_FMT_RGB48BE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
     AV_PIX_FMT_RGB48LE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
 
@@ -136,9 +68,6 @@ enum AVPixelFormat {
     AV_PIX_FMT_YUV422P16BE,  ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
     AV_PIX_FMT_YUV444P16LE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
     AV_PIX_FMT_YUV444P16BE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-#if FF_API_VDPAU
-    AV_PIX_FMT_VDPAU_MPEG4,  ///< MPEG4 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-#endif
     AV_PIX_FMT_DXVA2_VLD,    ///< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer
 
     AV_PIX_FMT_RGB444LE,  ///< packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), little-endian, most significant bits to 0
@@ -168,12 +97,6 @@ enum AVPixelFormat {
     AV_PIX_FMT_YUV422P9LE, ///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
     AV_PIX_FMT_VDA_VLD,    ///< hardware decoding through VDA
 
-#ifdef AV_PIX_FMT_ABI_GIT_MASTER
-    AV_PIX_FMT_RGBA64BE,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
-    AV_PIX_FMT_RGBA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
-    AV_PIX_FMT_BGRA64BE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
-    AV_PIX_FMT_BGRA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
-#endif
     AV_PIX_FMT_GBRP,      ///< planar GBR 4:4:4 24bpp
     AV_PIX_FMT_GBRP9BE,   ///< planar GBR 4:4:4 27bpp, big-endian
     AV_PIX_FMT_GBRP9LE,   ///< planar GBR 4:4:4 27bpp, little-endian
@@ -232,12 +155,10 @@ enum AVPixelFormat {
 
     AV_PIX_FMT_VDA,          ///< HW acceleration through VDA, data[3] contains a CVPixelBufferRef
 
-#ifndef AV_PIX_FMT_ABI_GIT_MASTER
     AV_PIX_FMT_RGBA64BE=0x123,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
     AV_PIX_FMT_RGBA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
     AV_PIX_FMT_BGRA64BE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
     AV_PIX_FMT_BGRA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
-#endif
     AV_PIX_FMT_0RGB=0x123+4,      ///< packed RGB 8:8:8, 32bpp, 0RGB0RGB...
     AV_PIX_FMT_RGB0,      ///< packed RGB 8:8:8, 32bpp, RGB0RGB0...
     AV_PIX_FMT_0BGR,      ///< packed BGR 8:8:8, 32bpp, 0BGR0BGR...
@@ -284,142 +205,8 @@ enum AVPixelFormat {
 
     AV_PIX_FMT_NB,        ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 
-#if FF_API_PIX_FMT
-#include "old_pix_fmts.h"
-#endif
 };
 
-#if AV_HAVE_INCOMPATIBLE_LIBAV_ABI
-#define AV_PIX_FMT_YUVA422P AV_PIX_FMT_YUVA422P_LIBAV
-#define AV_PIX_FMT_YUVA444P AV_PIX_FMT_YUVA444P_LIBAV
-#define AV_PIX_FMT_RGBA64BE AV_PIX_FMT_RGBA64BE_LIBAV
-#define AV_PIX_FMT_RGBA64LE AV_PIX_FMT_RGBA64LE_LIBAV
-#define AV_PIX_FMT_BGRA64BE AV_PIX_FMT_BGRA64BE_LIBAV
-#define AV_PIX_FMT_BGRA64LE AV_PIX_FMT_BGRA64LE_LIBAV
-#endif
-
-
-#define AV_PIX_FMT_Y400A AV_PIX_FMT_GRAY8A
-#define AV_PIX_FMT_GBR24P AV_PIX_FMT_GBRP
-
-#if AV_HAVE_BIGENDIAN
-#   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##be
-#else
-#   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##le
-#endif
-
-#define AV_PIX_FMT_RGB32   AV_PIX_FMT_NE(ARGB, BGRA)
-#define AV_PIX_FMT_RGB32_1 AV_PIX_FMT_NE(RGBA, ABGR)
-#define AV_PIX_FMT_BGR32   AV_PIX_FMT_NE(ABGR, RGBA)
-#define AV_PIX_FMT_BGR32_1 AV_PIX_FMT_NE(BGRA, ARGB)
-#define AV_PIX_FMT_0RGB32  AV_PIX_FMT_NE(0RGB, BGR0)
-#define AV_PIX_FMT_0BGR32  AV_PIX_FMT_NE(0BGR, RGB0)
-
-#define AV_PIX_FMT_GRAY16 AV_PIX_FMT_NE(GRAY16BE, GRAY16LE)
-#define AV_PIX_FMT_RGB48  AV_PIX_FMT_NE(RGB48BE,  RGB48LE)
-#define AV_PIX_FMT_RGB565 AV_PIX_FMT_NE(RGB565BE, RGB565LE)
-#define AV_PIX_FMT_RGB555 AV_PIX_FMT_NE(RGB555BE, RGB555LE)
-#define AV_PIX_FMT_RGB444 AV_PIX_FMT_NE(RGB444BE, RGB444LE)
-#define AV_PIX_FMT_RGBA64 AV_PIX_FMT_NE(RGBA64BE, RGBA64LE)
-#define AV_PIX_FMT_BGR48  AV_PIX_FMT_NE(BGR48BE,  BGR48LE)
-#define AV_PIX_FMT_BGR565 AV_PIX_FMT_NE(BGR565BE, BGR565LE)
-#define AV_PIX_FMT_BGR555 AV_PIX_FMT_NE(BGR555BE, BGR555LE)
-#define AV_PIX_FMT_BGR444 AV_PIX_FMT_NE(BGR444BE, BGR444LE)
-#define AV_PIX_FMT_BGRA64 AV_PIX_FMT_NE(BGRA64BE, BGRA64LE)
-
-#define AV_PIX_FMT_YUV420P9  AV_PIX_FMT_NE(YUV420P9BE , YUV420P9LE)
-#define AV_PIX_FMT_YUV422P9  AV_PIX_FMT_NE(YUV422P9BE , YUV422P9LE)
-#define AV_PIX_FMT_YUV444P9  AV_PIX_FMT_NE(YUV444P9BE , YUV444P9LE)
-#define AV_PIX_FMT_YUV420P10 AV_PIX_FMT_NE(YUV420P10BE, YUV420P10LE)
-#define AV_PIX_FMT_YUV422P10 AV_PIX_FMT_NE(YUV422P10BE, YUV422P10LE)
-#define AV_PIX_FMT_YUV444P10 AV_PIX_FMT_NE(YUV444P10BE, YUV444P10LE)
-#define AV_PIX_FMT_YUV420P12 AV_PIX_FMT_NE(YUV420P12BE, YUV420P12LE)
-#define AV_PIX_FMT_YUV422P12 AV_PIX_FMT_NE(YUV422P12BE, YUV422P12LE)
-#define AV_PIX_FMT_YUV444P12 AV_PIX_FMT_NE(YUV444P12BE, YUV444P12LE)
-#define AV_PIX_FMT_YUV420P14 AV_PIX_FMT_NE(YUV420P14BE, YUV420P14LE)
-#define AV_PIX_FMT_YUV422P14 AV_PIX_FMT_NE(YUV422P14BE, YUV422P14LE)
-#define AV_PIX_FMT_YUV444P14 AV_PIX_FMT_NE(YUV444P14BE, YUV444P14LE)
-#define AV_PIX_FMT_YUV420P16 AV_PIX_FMT_NE(YUV420P16BE, YUV420P16LE)
-#define AV_PIX_FMT_YUV422P16 AV_PIX_FMT_NE(YUV422P16BE, YUV422P16LE)
-#define AV_PIX_FMT_YUV444P16 AV_PIX_FMT_NE(YUV444P16BE, YUV444P16LE)
-
-#define AV_PIX_FMT_GBRP9     AV_PIX_FMT_NE(GBRP9BE ,    GBRP9LE)
-#define AV_PIX_FMT_GBRP10    AV_PIX_FMT_NE(GBRP10BE,    GBRP10LE)
-#define AV_PIX_FMT_GBRP12    AV_PIX_FMT_NE(GBRP12BE,    GBRP12LE)
-#define AV_PIX_FMT_GBRP14    AV_PIX_FMT_NE(GBRP14BE,    GBRP14LE)
-#define AV_PIX_FMT_GBRP16    AV_PIX_FMT_NE(GBRP16BE,    GBRP16LE)
-#define AV_PIX_FMT_GBRAP16   AV_PIX_FMT_NE(GBRAP16BE,   GBRAP16LE)
-
-#define AV_PIX_FMT_BAYER_BGGR16 AV_PIX_FMT_NE(BAYER_BGGR16BE,    BAYER_BGGR16LE)
-#define AV_PIX_FMT_BAYER_RGGB16 AV_PIX_FMT_NE(BAYER_RGGB16BE,    BAYER_RGGB16LE)
-#define AV_PIX_FMT_BAYER_GBRG16 AV_PIX_FMT_NE(BAYER_GBRG16BE,    BAYER_GBRG16LE)
-#define AV_PIX_FMT_BAYER_GRBG16 AV_PIX_FMT_NE(BAYER_GRBG16BE,    BAYER_GRBG16LE)
-
-
-#define AV_PIX_FMT_YUVA420P9  AV_PIX_FMT_NE(YUVA420P9BE , YUVA420P9LE)
-#define AV_PIX_FMT_YUVA422P9  AV_PIX_FMT_NE(YUVA422P9BE , YUVA422P9LE)
-#define AV_PIX_FMT_YUVA444P9  AV_PIX_FMT_NE(YUVA444P9BE , YUVA444P9LE)
-#define AV_PIX_FMT_YUVA420P10 AV_PIX_FMT_NE(YUVA420P10BE, YUVA420P10LE)
-#define AV_PIX_FMT_YUVA422P10 AV_PIX_FMT_NE(YUVA422P10BE, YUVA422P10LE)
-#define AV_PIX_FMT_YUVA444P10 AV_PIX_FMT_NE(YUVA444P10BE, YUVA444P10LE)
-#define AV_PIX_FMT_YUVA420P16 AV_PIX_FMT_NE(YUVA420P16BE, YUVA420P16LE)
-#define AV_PIX_FMT_YUVA422P16 AV_PIX_FMT_NE(YUVA422P16BE, YUVA422P16LE)
-#define AV_PIX_FMT_YUVA444P16 AV_PIX_FMT_NE(YUVA444P16BE, YUVA444P16LE)
-
-#define AV_PIX_FMT_XYZ12      AV_PIX_FMT_NE(XYZ12BE, XYZ12LE)
-#define AV_PIX_FMT_NV20       AV_PIX_FMT_NE(NV20BE,  NV20LE)
-
-
-#if FF_API_PIX_FMT
-#define PixelFormat AVPixelFormat
-
-#define PIX_FMT_Y400A AV_PIX_FMT_Y400A
-#define PIX_FMT_GBR24P AV_PIX_FMT_GBR24P
-
-#define PIX_FMT_NE(be, le) AV_PIX_FMT_NE(be, le)
-
-#define PIX_FMT_RGB32   AV_PIX_FMT_RGB32
-#define PIX_FMT_RGB32_1 AV_PIX_FMT_RGB32_1
-#define PIX_FMT_BGR32   AV_PIX_FMT_BGR32
-#define PIX_FMT_BGR32_1 AV_PIX_FMT_BGR32_1
-#define PIX_FMT_0RGB32  AV_PIX_FMT_0RGB32
-#define PIX_FMT_0BGR32  AV_PIX_FMT_0BGR32
-
-#define PIX_FMT_GRAY16 AV_PIX_FMT_GRAY16
-#define PIX_FMT_RGB48  AV_PIX_FMT_RGB48
-#define PIX_FMT_RGB565 AV_PIX_FMT_RGB565
-#define PIX_FMT_RGB555 AV_PIX_FMT_RGB555
-#define PIX_FMT_RGB444 AV_PIX_FMT_RGB444
-#define PIX_FMT_BGR48  AV_PIX_FMT_BGR48
-#define PIX_FMT_BGR565 AV_PIX_FMT_BGR565
-#define PIX_FMT_BGR555 AV_PIX_FMT_BGR555
-#define PIX_FMT_BGR444 AV_PIX_FMT_BGR444
-
-#define PIX_FMT_YUV420P9  AV_PIX_FMT_YUV420P9
-#define PIX_FMT_YUV422P9  AV_PIX_FMT_YUV422P9
-#define PIX_FMT_YUV444P9  AV_PIX_FMT_YUV444P9
-#define PIX_FMT_YUV420P10 AV_PIX_FMT_YUV420P10
-#define PIX_FMT_YUV422P10 AV_PIX_FMT_YUV422P10
-#define PIX_FMT_YUV444P10 AV_PIX_FMT_YUV444P10
-#define PIX_FMT_YUV420P12 AV_PIX_FMT_YUV420P12
-#define PIX_FMT_YUV422P12 AV_PIX_FMT_YUV422P12
-#define PIX_FMT_YUV444P12 AV_PIX_FMT_YUV444P12
-#define PIX_FMT_YUV420P14 AV_PIX_FMT_YUV420P14
-#define PIX_FMT_YUV422P14 AV_PIX_FMT_YUV422P14
-#define PIX_FMT_YUV444P14 AV_PIX_FMT_YUV444P14
-#define PIX_FMT_YUV420P16 AV_PIX_FMT_YUV420P16
-#define PIX_FMT_YUV422P16 AV_PIX_FMT_YUV422P16
-#define PIX_FMT_YUV444P16 AV_PIX_FMT_YUV444P16
-
-#define PIX_FMT_RGBA64 AV_PIX_FMT_RGBA64
-#define PIX_FMT_BGRA64 AV_PIX_FMT_BGRA64
-#define PIX_FMT_GBRP9  AV_PIX_FMT_GBRP9
-#define PIX_FMT_GBRP10 AV_PIX_FMT_GBRP10
-#define PIX_FMT_GBRP12 AV_PIX_FMT_GBRP12
-#define PIX_FMT_GBRP14 AV_PIX_FMT_GBRP14
-#define PIX_FMT_GBRP16 AV_PIX_FMT_GBRP16
-#endif
-
 /**
   * Chromaticity coordinates of the source primaries.
   */
diff -pruN /usr/include/ffmpeg/libavutil/random_seed.h csrc/libavutil/random_seed.h
--- /usr/include/ffmpeg/libavutil/random_seed.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/random_seed.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2009 Baptiste Coudurier <baptiste.coudurier@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_RANDOM_SEED_H
-#define AVUTIL_RANDOM_SEED_H
-
-#include <stdint.h>
-/**
- * @addtogroup lavu_crypto
- * @{
- */
-
-/**
- * Get a seed to use in conjunction with random functions.
- * This function tries to provide a good seed at a best effort bases.
- * Its possible to call this function multiple times if more bits are needed.
- * It can be quite slow, which is why it should only be used as seed for a faster
- * PRNG. The quality of the seed depends on the platform.
- */
-uint32_t av_get_random_seed(void);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_RANDOM_SEED_H */
diff -pruN /usr/include/ffmpeg/libavutil/rational.h csrc/libavutil/rational.h
--- /usr/include/ffmpeg/libavutil/rational.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/rational.h	2014-10-20 10:36:41.574488522 +0200
@@ -1,29 +1,3 @@
-/*
- * rational numbers
- * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * rational numbers
- * @author Michael Niedermayer <michaelni@gmx.at>
- */
 
 #ifndef AVUTIL_RATIONAL_H
 #define AVUTIL_RATIONAL_H
@@ -32,135 +6,13 @@
 #include <limits.h>
 #include "attributes.h"
 
-/**
- * @addtogroup lavu_math
- * @{
- */
-
-/**
- * rational number numerator/denominator
- */
 typedef struct AVRational{
     int num; ///< numerator
     int den; ///< denominator
 } AVRational;
 
-/**
- * Create a rational.
- * Useful for compilers that do not support compound literals.
- * @note  The return value is not reduced.
- */
-static inline AVRational av_make_q(int num, int den)
-{
-    AVRational r = { num, den };
-    return r;
-}
-
-/**
- * Compare two rationals.
- * @param a first rational
- * @param b second rational
- * @return 0 if a==b, 1 if a>b, -1 if a<b, and INT_MIN if one of the
- * values is of the form 0/0
- */
-static inline int av_cmp_q(AVRational a, AVRational b){
-    const int64_t tmp= a.num * (int64_t)b.den - b.num * (int64_t)a.den;
-
-    if(tmp) return (int)((tmp ^ a.den ^ b.den)>>63)|1;
-    else if(b.den && a.den) return 0;
-    else if(a.num && b.num) return (a.num>>31) - (b.num>>31);
-    else                    return INT_MIN;
-}
-
-/**
- * Convert rational to double.
- * @param a rational to convert
- * @return (double) a
- */
-static inline double av_q2d(AVRational a){
-    return a.num / (double) a.den;
-}
-
-/**
- * Reduce a fraction.
- * This is useful for framerate calculations.
- * @param dst_num destination numerator
- * @param dst_den destination denominator
- * @param num source numerator
- * @param den source denominator
- * @param max the maximum allowed for dst_num & dst_den
- * @return 1 if exact, 0 otherwise
- */
 int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max);
 
-/**
- * Multiply two rationals.
- * @param b first rational
- * @param c second rational
- * @return b*c
- */
-AVRational av_mul_q(AVRational b, AVRational c) av_const;
-
-/**
- * Divide one rational by another.
- * @param b first rational
- * @param c second rational
- * @return b/c
- */
-AVRational av_div_q(AVRational b, AVRational c) av_const;
-
-/**
- * Add two rationals.
- * @param b first rational
- * @param c second rational
- * @return b+c
- */
-AVRational av_add_q(AVRational b, AVRational c) av_const;
-
-/**
- * Subtract one rational from another.
- * @param b first rational
- * @param c second rational
- * @return b-c
- */
-AVRational av_sub_q(AVRational b, AVRational c) av_const;
-
-/**
- * Invert a rational.
- * @param q value
- * @return 1 / q
- */
-static av_always_inline AVRational av_inv_q(AVRational q)
-{
-    AVRational r = { q.den, q.num };
-    return r;
-}
-
-/**
- * Convert a double precision floating point number to a rational.
- * inf is expressed as {1,0} or {-1,0} depending on the sign.
- *
- * @param d double to convert
- * @param max the maximum allowed numerator and denominator
- * @return (AVRational) d
- */
 AVRational av_d2q(double d, int max) av_const;
 
-/**
- * @return 1 if q1 is nearer to q than q2, -1 if q2 is nearer
- * than q1, 0 if they have the same distance.
- */
-int av_nearer_q(AVRational q, AVRational q1, AVRational q2);
-
-/**
- * Find the nearest value in q_list to q.
- * @param q_list an array of rationals terminated by {0, 0}
- * @return the index of the nearest value found in the array
- */
-int av_find_nearest_q_idx(AVRational q, const AVRational* q_list);
-
-/**
- * @}
- */
-
 #endif /* AVUTIL_RATIONAL_H */
diff -pruN /usr/include/ffmpeg/libavutil/replaygain.h csrc/libavutil/replaygain.h
--- /usr/include/ffmpeg/libavutil/replaygain.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/replaygain.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-/*
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_REPLAYGAIN_H
-#define AVUTIL_REPLAYGAIN_H
-
-#include <stdint.h>
-
-/**
- * ReplayGain information (see
- * http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification).
- * The size of this struct is a part of the public ABI.
- */
-typedef struct AVReplayGain {
-    /**
-     * Track replay gain in microbels (divide by 100000 to get the value in dB).
-     * Should be set to INT32_MIN when unknown.
-     */
-    int32_t track_gain;
-    /**
-     * Peak track amplitude, with 100000 representing full scale (but values
-     * may overflow). 0 when unknown.
-     */
-    uint32_t track_peak;
-    /**
-     * Same as track_gain, but for the whole album.
-     */
-    int32_t album_gain;
-    /**
-     * Same as track_peak, but for the whole album,
-     */
-    uint32_t album_peak;
-} AVReplayGain;
-
-#endif /* AVUTIL_REPLAYGAIN_H */
diff -pruN /usr/include/ffmpeg/libavutil/ripemd.h csrc/libavutil/ripemd.h
--- /usr/include/ffmpeg/libavutil/ripemd.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/ripemd.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2007 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (C) 2013 James Almer <jamrial@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_RIPEMD_H
-#define AVUTIL_RIPEMD_H
-
-#include <stdint.h>
-
-#include "attributes.h"
-#include "version.h"
-
-/**
- * @defgroup lavu_ripemd RIPEMD
- * @ingroup lavu_crypto
- * @{
- */
-
-extern const int av_ripemd_size;
-
-struct AVRIPEMD;
-
-/**
- * Allocate an AVRIPEMD context.
- */
-struct AVRIPEMD *av_ripemd_alloc(void);
-
-/**
- * Initialize RIPEMD hashing.
- *
- * @param context pointer to the function context (of size av_ripemd_size)
- * @param bits    number of bits in digest (128, 160, 256 or 320 bits)
- * @return        zero if initialization succeeded, -1 otherwise
- */
-int av_ripemd_init(struct AVRIPEMD* context, int bits);
-
-/**
- * Update hash value.
- *
- * @param context hash function context
- * @param data    input data to update hash with
- * @param len     input data length
- */
-void av_ripemd_update(struct AVRIPEMD* context, const uint8_t* data, unsigned int len);
-
-/**
- * Finish hashing and output digest value.
- *
- * @param context hash function context
- * @param digest  buffer where output digest value is stored
- */
-void av_ripemd_final(struct AVRIPEMD* context, uint8_t *digest);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_RIPEMD_H */
diff -pruN /usr/include/ffmpeg/libavutil/samplefmt.h csrc/libavutil/samplefmt.h
--- /usr/include/ffmpeg/libavutil/samplefmt.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/samplefmt.h	2014-10-20 17:02:01.423900942 +0200
@@ -19,22 +19,6 @@
 #ifndef AVUTIL_SAMPLEFMT_H
 #define AVUTIL_SAMPLEFMT_H
 
-#include <stdint.h>
-
-#include "avutil.h"
-#include "attributes.h"
-
-/**
- * @addtogroup lavu_audio
- * @{
- *
- * @defgroup lavu_sampfmts Audio sample formats
- *
- * Audio sample format enumeration and related convenience functions.
- * @{
- *
- */
-
 /**
  * Audio sample formats
  *
@@ -80,20 +64,6 @@ enum AVSampleFormat {
 const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt);
 
 /**
- * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE
- * on error.
- */
-enum AVSampleFormat av_get_sample_fmt(const char *name);
-
-/**
- * Return the planar<->packed alternative form of the given sample format, or
- * AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the
- * requested planar/packed format, the format returned is the same as the
- * input.
- */
-enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar);
-
-/**
  * Get the packed alternative form of the given sample format.
  *
  * If the passed sample_fmt is already in packed format, the format returned is
@@ -105,39 +75,6 @@ enum AVSampleFormat av_get_alt_sample_fm
 enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt);
 
 /**
- * Get the planar alternative form of the given sample format.
- *
- * If the passed sample_fmt is already in planar format, the format returned is
- * the same as the input.
- *
- * @return  the planar alternative form of the given sample format or
-            AV_SAMPLE_FMT_NONE on error.
- */
-enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt);
-
-/**
- * Generate a string corresponding to the sample format with
- * sample_fmt, or a header if sample_fmt is negative.
- *
- * @param buf the buffer where to write the string
- * @param buf_size the size of buf
- * @param sample_fmt the number of the sample format to print the
- * corresponding info string, or a negative value to print the
- * corresponding header.
- * @return the pointer to the filled buffer or NULL if sample_fmt is
- * unknown or in case of other errors
- */
-char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt);
-
-#if FF_API_GET_BITS_PER_SAMPLE_FMT
-/**
- * @deprecated Use av_get_bytes_per_sample() instead.
- */
-attribute_deprecated
-int av_get_bits_per_sample_fmt(enum AVSampleFormat sample_fmt);
-#endif
-
-/**
  * Return number of bytes per sample.
  *
  * @param sample_fmt the sample format
@@ -154,126 +91,4 @@ int av_get_bytes_per_sample(enum AVSampl
  */
 int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt);
 
-/**
- * Get the required buffer size for the given audio parameters.
- *
- * @param[out] linesize calculated linesize, may be NULL
- * @param nb_channels   the number of channels
- * @param nb_samples    the number of samples in a single channel
- * @param sample_fmt    the sample format
- * @param align         buffer size alignment (0 = default, 1 = no alignment)
- * @return              required buffer size, or negative error code on failure
- */
-int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples,
-                               enum AVSampleFormat sample_fmt, int align);
-
-/**
- * @}
- *
- * @defgroup lavu_sampmanip Samples manipulation
- *
- * Functions that manipulate audio samples
- * @{
- */
-
-/**
- * Fill plane data pointers and linesize for samples with sample
- * format sample_fmt.
- *
- * The audio_data array is filled with the pointers to the samples data planes:
- * for planar, set the start point of each channel's data within the buffer,
- * for packed, set the start point of the entire buffer only.
- *
- * The value pointed to by linesize is set to the aligned size of each
- * channel's data buffer for planar layout, or to the aligned size of the
- * buffer for all channels for packed layout.
- *
- * The buffer in buf must be big enough to contain all the samples
- * (use av_samples_get_buffer_size() to compute its minimum size),
- * otherwise the audio_data pointers will point to invalid data.
- *
- * @see enum AVSampleFormat
- * The documentation for AVSampleFormat describes the data layout.
- *
- * @param[out] audio_data  array to be filled with the pointer for each channel
- * @param[out] linesize    calculated linesize, may be NULL
- * @param buf              the pointer to a buffer containing the samples
- * @param nb_channels      the number of channels
- * @param nb_samples       the number of samples in a single channel
- * @param sample_fmt       the sample format
- * @param align            buffer size alignment (0 = default, 1 = no alignment)
- * @return                 >=0 on success or a negative error code on failure
- * @todo return minimum size in bytes required for the buffer in case
- * of success at the next bump
- */
-int av_samples_fill_arrays(uint8_t **audio_data, int *linesize,
-                           const uint8_t *buf,
-                           int nb_channels, int nb_samples,
-                           enum AVSampleFormat sample_fmt, int align);
-
-/**
- * Allocate a samples buffer for nb_samples samples, and fill data pointers and
- * linesize accordingly.
- * The allocated samples buffer can be freed by using av_freep(&audio_data[0])
- * Allocated data will be initialized to silence.
- *
- * @see enum AVSampleFormat
- * The documentation for AVSampleFormat describes the data layout.
- *
- * @param[out] audio_data  array to be filled with the pointer for each channel
- * @param[out] linesize    aligned size for audio buffer(s), may be NULL
- * @param nb_channels      number of audio channels
- * @param nb_samples       number of samples per channel
- * @param align            buffer size alignment (0 = default, 1 = no alignment)
- * @return                 >=0 on success or a negative error code on failure
- * @todo return the size of the allocated buffer in case of success at the next bump
- * @see av_samples_fill_arrays()
- * @see av_samples_alloc_array_and_samples()
- */
-int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels,
-                     int nb_samples, enum AVSampleFormat sample_fmt, int align);
-
-/**
- * Allocate a data pointers array, samples buffer for nb_samples
- * samples, and fill data pointers and linesize accordingly.
- *
- * This is the same as av_samples_alloc(), but also allocates the data
- * pointers array.
- *
- * @see av_samples_alloc()
- */
-int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels,
-                                       int nb_samples, enum AVSampleFormat sample_fmt, int align);
-
-/**
- * Copy samples from src to dst.
- *
- * @param dst destination array of pointers to data planes
- * @param src source array of pointers to data planes
- * @param dst_offset offset in samples at which the data will be written to dst
- * @param src_offset offset in samples at which the data will be read from src
- * @param nb_samples number of samples to be copied
- * @param nb_channels number of audio channels
- * @param sample_fmt audio sample format
- */
-int av_samples_copy(uint8_t **dst, uint8_t * const *src, int dst_offset,
-                    int src_offset, int nb_samples, int nb_channels,
-                    enum AVSampleFormat sample_fmt);
-
-/**
- * Fill an audio buffer with silence.
- *
- * @param audio_data  array of pointers to data planes
- * @param offset      offset in samples at which to start filling
- * @param nb_samples  number of samples to fill
- * @param nb_channels number of audio channels
- * @param sample_fmt  audio sample format
- */
-int av_samples_set_silence(uint8_t **audio_data, int offset, int nb_samples,
-                           int nb_channels, enum AVSampleFormat sample_fmt);
-
-/**
- * @}
- * @}
- */
 #endif /* AVUTIL_SAMPLEFMT_H */
diff -pruN /usr/include/ffmpeg/libavutil/sha512.h csrc/libavutil/sha512.h
--- /usr/include/ffmpeg/libavutil/sha512.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/sha512.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2007 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (C) 2013 James Almer <jamrial@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_SHA512_H
-#define AVUTIL_SHA512_H
-
-#include <stdint.h>
-
-#include "attributes.h"
-#include "version.h"
-
-/**
- * @defgroup lavu_sha512 SHA512
- * @ingroup lavu_crypto
- * @{
- */
-
-extern const int av_sha512_size;
-
-struct AVSHA512;
-
-/**
- * Allocate an AVSHA512 context.
- */
-struct AVSHA512 *av_sha512_alloc(void);
-
-/**
- * Initialize SHA-2 512 hashing.
- *
- * @param context pointer to the function context (of size av_sha512_size)
- * @param bits    number of bits in digest (224, 256, 384 or 512 bits)
- * @return        zero if initialization succeeded, -1 otherwise
- */
-int av_sha512_init(struct AVSHA512* context, int bits);
-
-/**
- * Update hash value.
- *
- * @param context hash function context
- * @param data    input data to update hash with
- * @param len     input data length
- */
-void av_sha512_update(struct AVSHA512* context, const uint8_t* data, unsigned int len);
-
-/**
- * Finish hashing and output digest value.
- *
- * @param context hash function context
- * @param digest  buffer where output digest value is stored
- */
-void av_sha512_final(struct AVSHA512* context, uint8_t *digest);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_SHA512_H */
diff -pruN /usr/include/ffmpeg/libavutil/sha.h csrc/libavutil/sha.h
--- /usr/include/ffmpeg/libavutil/sha.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/sha.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2007 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_SHA_H
-#define AVUTIL_SHA_H
-
-#include <stdint.h>
-
-#include "attributes.h"
-#include "version.h"
-
-/**
- * @defgroup lavu_sha SHA
- * @ingroup lavu_crypto
- * @{
- */
-
-extern const int av_sha_size;
-
-struct AVSHA;
-
-/**
- * Allocate an AVSHA context.
- */
-struct AVSHA *av_sha_alloc(void);
-
-/**
- * Initialize SHA-1 or SHA-2 hashing.
- *
- * @param context pointer to the function context (of size av_sha_size)
- * @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)
- * @return        zero if initialization succeeded, -1 otherwise
- */
-int av_sha_init(struct AVSHA* context, int bits);
-
-/**
- * Update hash value.
- *
- * @param context hash function context
- * @param data    input data to update hash with
- * @param len     input data length
- */
-void av_sha_update(struct AVSHA* context, const uint8_t* data, unsigned int len);
-
-/**
- * Finish hashing and output digest value.
- *
- * @param context hash function context
- * @param digest  buffer where output digest value is stored
- */
-void av_sha_final(struct AVSHA* context, uint8_t *digest);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_SHA_H */
diff -pruN /usr/include/ffmpeg/libavutil/stereo3d.h csrc/libavutil/stereo3d.h
--- /usr/include/ffmpeg/libavutil/stereo3d.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/stereo3d.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,152 +0,0 @@
-/*
- * Copyright (c) 2013 Vittorio Giovara <vittorio.giovara@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_STEREO3D_H
-#define AVUTIL_STEREO3D_H
-
-#include <stdint.h>
-
-#include "frame.h"
-
-/**
- * List of possible 3D Types
- */
-enum AVStereo3DType {
-    /**
-     * Video is not stereoscopic (and metadata has to be there).
-     */
-    AV_STEREO3D_2D,
-
-    /**
-     * Views are next to each other.
-     *
-     *    LLLLRRRR
-     *    LLLLRRRR
-     *    LLLLRRRR
-     *    ...
-     */
-    AV_STEREO3D_SIDEBYSIDE,
-
-    /**
-     * Views are on top of each other.
-     *
-     *    LLLLLLLL
-     *    LLLLLLLL
-     *    RRRRRRRR
-     *    RRRRRRRR
-     */
-    AV_STEREO3D_TOPBOTTOM,
-
-    /**
-     * Views are alternated temporally.
-     *
-     *     frame0   frame1   frame2   ...
-     *    LLLLLLLL RRRRRRRR LLLLLLLL
-     *    LLLLLLLL RRRRRRRR LLLLLLLL
-     *    LLLLLLLL RRRRRRRR LLLLLLLL
-     *    ...      ...      ...
-     */
-    AV_STEREO3D_FRAMESEQUENCE,
-
-    /**
-     * Views are packed in a checkerboard-like structure per pixel.
-     *
-     *    LRLRLRLR
-     *    RLRLRLRL
-     *    LRLRLRLR
-     *    ...
-     */
-    AV_STEREO3D_CHECKERBOARD,
-
-    /**
-     * Views are next to each other, but when upscaling
-     * apply a checkerboard pattern.
-     *
-     *     LLLLRRRR          L L L L    R R R R
-     *     LLLLRRRR    =>     L L L L  R R R R
-     *     LLLLRRRR          L L L L    R R R R
-     *     LLLLRRRR           L L L L  R R R R
-     */
-    AV_STEREO3D_SIDEBYSIDE_QUINCUNX,
-
-    /**
-     * Views are packed per line, as if interlaced.
-     *
-     *    LLLLLLLL
-     *    RRRRRRRR
-     *    LLLLLLLL
-     *    ...
-     */
-    AV_STEREO3D_LINES,
-
-    /**
-     * Views are packed per column.
-     *
-     *    LRLRLRLR
-     *    LRLRLRLR
-     *    LRLRLRLR
-     *    ...
-     */
-    AV_STEREO3D_COLUMNS,
-};
-
-
-/**
- * Inverted views, Right/Bottom represents the left view.
- */
-#define AV_STEREO3D_FLAG_INVERT     (1 << 0)
-
-/**
- * Stereo 3D type: this structure describes how two videos are packed
- * within a single video surface, with additional information as needed.
- *
- * @note The struct must be allocated with av_stereo3d_alloc() and
- *       its size is not a part of the public ABI.
- */
-typedef struct AVStereo3D {
-    /**
-     * How views are packed within the video.
-     */
-    enum AVStereo3DType type;
-
-    /**
-     * Additional information about the frame packing.
-     */
-    int flags;
-} AVStereo3D;
-
-/**
- * Allocate an AVStereo3D structure and set its fields to default values.
- * The resulting struct can be freed using av_freep().
- *
- * @return An AVStereo3D filled with default values or NULL on failure.
- */
-AVStereo3D *av_stereo3d_alloc(void);
-
-/**
- * Allocate a complete AVFrameSideData and add it to the frame.
- *
- * @param frame The frame which side data is added to.
- *
- * @return The AVStereo3D structure to be filled by caller.
- */
-AVStereo3D *av_stereo3d_create_side_data(AVFrame *frame);
-
-#endif /* AVUTIL_STEREO3D_H */
diff -pruN /usr/include/ffmpeg/libavutil/threadmessage.h csrc/libavutil/threadmessage.h
--- /usr/include/ffmpeg/libavutil/threadmessage.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/threadmessage.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_THREADMESSAGE_H
-#define AVUTIL_THREADMESSAGE_H
-
-typedef struct AVThreadMessageQueue AVThreadMessageQueue;
-
-typedef enum AVThreadMessageFlags {
-
-    /**
-     * Perform non-blocking operation.
-     * If this flag is set, send and recv operations are non-blocking and
-     * return AVERROR(EAGAIN) immediately if they can not proceed.
-     */
-    AV_THREAD_MESSAGE_NONBLOCK = 1,
-
-} AVThreadMessageFlags;
-
-/**
- * Allocate a new message queue.
- *
- * @param mq      pointer to the message queue
- * @param nelem   maximum number of elements in the queue
- * @param elsize  size of each element in the queue
- * @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if
- *          lavu was built without thread support
- */
-int av_thread_message_queue_alloc(AVThreadMessageQueue **mq,
-                                  unsigned nelem,
-                                  unsigned elsize);
-
-/**
- * Free a message queue.
- *
- * The message queue must no longer be in use by another thread.
- */
-void av_thread_message_queue_free(AVThreadMessageQueue **mq);
-
-/**
- * Send a message on the queue.
- */
-int av_thread_message_queue_send(AVThreadMessageQueue *mq,
-                                 void *msg,
-                                 unsigned flags);
-
-/**
- * Receive a message from the queue.
- */
-int av_thread_message_queue_recv(AVThreadMessageQueue *mq,
-                                 void *msg,
-                                 unsigned flags);
-
-/**
- * Set the sending error code.
- *
- * If the error code is set to non-zero, av_thread_message_queue_recv() will
- * return it immediately when there are no longer available messages.
- * Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used
- * to cause the receiving thread to stop or suspend its operation.
- */
-void av_thread_message_queue_set_err_send(AVThreadMessageQueue *mq,
-                                          int err);
-
-/**
- * Set the receiving error code.
- *
- * If the error code is set to non-zero, av_thread_message_queue_send() will
- * return it immediately. Conventional values, such as AVERROR_EOF or
- * AVERROR(EAGAIN), can be used to cause the sending thread to stop or
- * suspend its operation.
- */
-void av_thread_message_queue_set_err_recv(AVThreadMessageQueue *mq,
-                                          int err);
-
-#endif /* AVUTIL_THREADMESSAGE_H */
diff -pruN /usr/include/ffmpeg/libavutil/timecode.h csrc/libavutil/timecode.h
--- /usr/include/ffmpeg/libavutil/timecode.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/timecode.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,140 +0,0 @@
-/*
- * Copyright (c) 2006 Smartjog S.A.S, Baptiste Coudurier <baptiste.coudurier@gmail.com>
- * Copyright (c) 2011-2012 Smartjog S.A.S, Clment Bsch <clement.boesch@smartjog.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * Timecode helpers header
- */
-
-#ifndef AVUTIL_TIMECODE_H
-#define AVUTIL_TIMECODE_H
-
-#include <stdint.h>
-#include "rational.h"
-
-#define AV_TIMECODE_STR_SIZE 16
-
-enum AVTimecodeFlag {
-    AV_TIMECODE_FLAG_DROPFRAME      = 1<<0, ///< timecode is drop frame
-    AV_TIMECODE_FLAG_24HOURSMAX     = 1<<1, ///< timecode wraps after 24 hours
-    AV_TIMECODE_FLAG_ALLOWNEGATIVE  = 1<<2, ///< negative time values are allowed
-};
-
-typedef struct {
-    int start;          ///< timecode frame start (first base frame number)
-    uint32_t flags;     ///< flags such as drop frame, +24 hours support, ...
-    AVRational rate;    ///< frame rate in rational form
-    unsigned fps;       ///< frame per second; must be consistent with the rate field
-} AVTimecode;
-
-/**
- * Adjust frame number for NTSC drop frame time code.
- *
- * @param framenum frame number to adjust
- * @param fps      frame per second, 30 or 60
- * @return         adjusted frame number
- * @warning        adjustment is only valid in NTSC 29.97 and 59.94
- */
-int av_timecode_adjust_ntsc_framenum2(int framenum, int fps);
-
-/**
- * Convert frame number to SMPTE 12M binary representation.
- *
- * @param tc       timecode data correctly initialized
- * @param framenum frame number
- * @return         the SMPTE binary representation
- *
- * @note Frame number adjustment is automatically done in case of drop timecode,
- *       you do NOT have to call av_timecode_adjust_ntsc_framenum2().
- * @note The frame number is relative to tc->start.
- * @note Color frame (CF), binary group flags (BGF) and biphase mark polarity
- *       correction (PC) bits are set to zero.
- */
-uint32_t av_timecode_get_smpte_from_framenum(const AVTimecode *tc, int framenum);
-
-/**
- * Load timecode string in buf.
- *
- * @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long
- * @param tc       timecode data correctly initialized
- * @param framenum frame number
- * @return         the buf parameter
- *
- * @note Timecode representation can be a negative timecode and have more than
- *       24 hours, but will only be honored if the flags are correctly set.
- * @note The frame number is relative to tc->start.
- */
-char *av_timecode_make_string(const AVTimecode *tc, char *buf, int framenum);
-
-/**
- * Get the timecode string from the SMPTE timecode format.
- *
- * @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long
- * @param tcsmpte    the 32-bit SMPTE timecode
- * @param prevent_df prevent the use of a drop flag when it is known the DF bit
- *                   is arbitrary
- * @return           the buf parameter
- */
-char *av_timecode_make_smpte_tc_string(char *buf, uint32_t tcsmpte, int prevent_df);
-
-/**
- * Get the timecode string from the 25-bit timecode format (MPEG GOP format).
- *
- * @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long
- * @param tc25bit the 25-bits timecode
- * @return        the buf parameter
- */
-char *av_timecode_make_mpeg_tc_string(char *buf, uint32_t tc25bit);
-
-/**
- * Init a timecode struct with the passed parameters.
- *
- * @param log_ctx     a pointer to an arbitrary struct of which the first field
- *                    is a pointer to an AVClass struct (used for av_log)
- * @param tc          pointer to an allocated AVTimecode
- * @param rate        frame rate in rational form
- * @param flags       miscellaneous flags such as drop frame, +24 hours, ...
- *                    (see AVTimecodeFlag)
- * @param frame_start the first frame number
- * @return            0 on success, AVERROR otherwise
- */
-int av_timecode_init(AVTimecode *tc, AVRational rate, int flags, int frame_start, void *log_ctx);
-
-/**
- * Parse timecode representation (hh:mm:ss[:;.]ff).
- *
- * @param log_ctx a pointer to an arbitrary struct of which the first field is a
- *                pointer to an AVClass struct (used for av_log).
- * @param tc      pointer to an allocated AVTimecode
- * @param rate    frame rate in rational form
- * @param str     timecode string which will determine the frame start
- * @return        0 on success, AVERROR otherwise
- */
-int av_timecode_init_from_string(AVTimecode *tc, AVRational rate, const char *str, void *log_ctx);
-
-/**
- * Check if the timecode feature is available for the given frame rate
- *
- * @return 0 if supported, <0 otherwise
- */
-int av_timecode_check_frame_rate(AVRational rate);
-
-#endif /* AVUTIL_TIMECODE_H */
diff -pruN /usr/include/ffmpeg/libavutil/time.h csrc/libavutil/time.h
--- /usr/include/ffmpeg/libavutil/time.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/time.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2000-2003 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_TIME_H
-#define AVUTIL_TIME_H
-
-#include <stdint.h>
-
-/**
- * Get the current time in microseconds.
- */
-int64_t av_gettime(void);
-
-/**
- * Get the current time in microseconds since some unspecified starting point.
- * On platforms that support it, the time comes from a monotonic clock
- * This property makes this time source ideal for measuring relative time.
- * If a monotonic clock is not available on the targeted platform, the
- * implementation fallsback on using av_gettime().
- */
-int64_t av_gettime_relative(void);
-
-/**
- * Indicates with a boolean result if the av_gettime_relative() time source
- * is monotonic.
- */
-int av_gettime_relative_is_monotonic(void);
-
-/**
- * Sleep for a period of time.  Although the duration is expressed in
- * microseconds, the actual delay may be rounded to the precision of the
- * system timer.
- *
- * @param  usec Number of microseconds to sleep.
- * @return zero on success or (negative) error code.
- */
-int av_usleep(unsigned usec);
-
-#endif /* AVUTIL_TIME_H */
diff -pruN /usr/include/ffmpeg/libavutil/timestamp.h csrc/libavutil/timestamp.h
--- /usr/include/ffmpeg/libavutil/timestamp.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/timestamp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * timestamp utils, mostly useful for debugging/logging purposes
- */
-
-#ifndef AVUTIL_TIMESTAMP_H
-#define AVUTIL_TIMESTAMP_H
-
-#include "common.h"
-
-#if defined(__cplusplus) && !defined(__STDC_FORMAT_MACROS) && !defined(PRId64)
-#error missing -D__STDC_FORMAT_MACROS / #define __STDC_FORMAT_MACROS
-#endif
-
-#define AV_TS_MAX_STRING_SIZE 32
-
-/**
- * Fill the provided buffer with a string containing a timestamp
- * representation.
- *
- * @param buf a buffer with size in bytes of at least AV_TS_MAX_STRING_SIZE
- * @param ts the timestamp to represent
- * @return the buffer in input
- */
-static inline char *av_ts_make_string(char *buf, int64_t ts)
-{
-    if (ts == AV_NOPTS_VALUE) snprintf(buf, AV_TS_MAX_STRING_SIZE, "NOPTS");
-    else                      snprintf(buf, AV_TS_MAX_STRING_SIZE, "%"PRId64, ts);
-    return buf;
-}
-
-/**
- * Convenience macro, the return value should be used only directly in
- * function arguments but never stand-alone.
- */
-#define av_ts2str(ts) av_ts_make_string((char[AV_TS_MAX_STRING_SIZE]){0}, ts)
-
-/**
- * Fill the provided buffer with a string containing a timestamp time
- * representation.
- *
- * @param buf a buffer with size in bytes of at least AV_TS_MAX_STRING_SIZE
- * @param ts the timestamp to represent
- * @param tb the timebase of the timestamp
- * @return the buffer in input
- */
-static inline char *av_ts_make_time_string(char *buf, int64_t ts, AVRational *tb)
-{
-    if (ts == AV_NOPTS_VALUE) snprintf(buf, AV_TS_MAX_STRING_SIZE, "NOPTS");
-    else                      snprintf(buf, AV_TS_MAX_STRING_SIZE, "%.6g", av_q2d(*tb) * ts);
-    return buf;
-}
-
-/**
- * Convenience macro, the return value should be used only directly in
- * function arguments but never stand-alone.
- */
-#define av_ts2timestr(ts, tb) av_ts_make_time_string((char[AV_TS_MAX_STRING_SIZE]){0}, ts, tb)
-
-#endif /* AVUTIL_TIMESTAMP_H */
diff -pruN /usr/include/ffmpeg/libavutil/version.h csrc/libavutil/version.h
--- /usr/include/ffmpeg/libavutil/version.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/version.h	2014-10-20 16:56:37.727563376 +0200
@@ -21,8 +21,6 @@
 #ifndef AVUTIL_VERSION_H
 #define AVUTIL_VERSION_H
 
-#include "macros.h"
-
 /**
  * @addtogroup version_utils
  *
@@ -67,18 +65,7 @@
                                            LIBAVUTIL_VERSION_MICRO)
 #define LIBAVUTIL_BUILD         LIBAVUTIL_VERSION_INT
 
-#define LIBAVUTIL_IDENT         "Lavu" AV_STRINGIFY(LIBAVUTIL_VERSION)
-
-/**
- * @}
- *
- * @defgroup depr_guards Deprecation guards
- * FF_API_* defines may be placed below to indicate public API that will be
- * dropped at a future version bump. The defines themselves are not part of
- * the public API and may change, break or disappear at any time.
- *
- * @{
- */
+#define LIBAVUTIL_IDENT         "Lavu52.92.100"
 
 #ifndef FF_API_GET_BITS_PER_SAMPLE_FMT
 #define FF_API_GET_BITS_PER_SAMPLE_FMT (LIBAVUTIL_VERSION_MAJOR < 54)
@@ -150,9 +137,5 @@
 #endif
 #endif
 
-/**
- * @}
- */
-
 #endif /* AVUTIL_VERSION_H */
 
diff -pruN /usr/include/ffmpeg/libavutil/xtea.h csrc/libavutil/xtea.h
--- /usr/include/ffmpeg/libavutil/xtea.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libavutil/xtea.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,64 +0,0 @@
-/*
- * A 32-bit implementation of the XTEA algorithm
- * Copyright (c) 2012 Samuel Pitoiset
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_XTEA_H
-#define AVUTIL_XTEA_H
-
-#include <stdint.h>
-
-/**
- * @file
- * @brief Public header for libavutil XTEA algorithm
- * @defgroup lavu_xtea XTEA
- * @ingroup lavu_crypto
- * @{
- */
-
-typedef struct AVXTEA {
-    uint32_t key[16];
-} AVXTEA;
-
-/**
- * Initialize an AVXTEA context.
- *
- * @param ctx an AVXTEA context
- * @param key a key of 16 bytes used for encryption/decryption
- */
-void av_xtea_init(struct AVXTEA *ctx, const uint8_t key[16]);
-
-/**
- * Encrypt or decrypt a buffer using a previously initialized context.
- *
- * @param ctx an AVXTEA context
- * @param dst destination array, can be equal to src
- * @param src source array, can be equal to dst
- * @param count number of 8 byte blocks
- * @param iv initialization vector for CBC mode, if NULL then ECB will be used
- * @param decrypt 0 for encryption, 1 for decryption
- */
-void av_xtea_crypt(struct AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
-                   int count, uint8_t *iv, int decrypt);
-
-/**
- * @}
- */
-
-#endif /* AVUTIL_XTEA_H */
diff -pruN /usr/include/ffmpeg/libpostproc/postprocess.h csrc/libpostproc/postprocess.h
--- /usr/include/ffmpeg/libpostproc/postprocess.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libpostproc/postprocess.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2001-2003 Michael Niedermayer (michaelni@gmx.at)
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef POSTPROC_POSTPROCESS_H
-#define POSTPROC_POSTPROCESS_H
-
-/**
- * @file
- * @ingroup lpp
- * external API header
- */
-
-/**
- * @defgroup lpp Libpostproc
- * @{
- */
-
-#include "libpostproc/version.h"
-
-/**
- * Return the LIBPOSTPROC_VERSION_INT constant.
- */
-unsigned postproc_version(void);
-
-/**
- * Return the libpostproc build-time configuration.
- */
-const char *postproc_configuration(void);
-
-/**
- * Return the libpostproc license.
- */
-const char *postproc_license(void);
-
-#define PP_QUALITY_MAX 6
-
-#define QP_STORE_T int8_t
-
-#include <inttypes.h>
-
-typedef void pp_context;
-typedef void pp_mode;
-
-#if LIBPOSTPROC_VERSION_INT < (52<<16)
-typedef pp_context pp_context_t;
-typedef pp_mode pp_mode_t;
-extern const char *const pp_help; ///< a simple help text
-#else
-extern const char pp_help[]; ///< a simple help text
-#endif
-
-void  pp_postprocess(const uint8_t * src[3], const int srcStride[3],
-                     uint8_t * dst[3], const int dstStride[3],
-                     int horizontalSize, int verticalSize,
-                     const QP_STORE_T *QP_store,  int QP_stride,
-                     pp_mode *mode, pp_context *ppContext, int pict_type);
-
-
-/**
- * Return a pp_mode or NULL if an error occurred.
- *
- * @param name    the string after "-pp" on the command line
- * @param quality a number from 0 to PP_QUALITY_MAX
- */
-pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality);
-void pp_free_mode(pp_mode *mode);
-
-pp_context *pp_get_context(int width, int height, int flags);
-void pp_free_context(pp_context *ppContext);
-
-#define PP_CPU_CAPS_MMX   0x80000000
-#define PP_CPU_CAPS_MMX2  0x20000000
-#define PP_CPU_CAPS_3DNOW 0x40000000
-#define PP_CPU_CAPS_ALTIVEC 0x10000000
-#define PP_CPU_CAPS_AUTO  0x00080000
-
-#define PP_FORMAT         0x00000008
-#define PP_FORMAT_420    (0x00000011|PP_FORMAT)
-#define PP_FORMAT_422    (0x00000001|PP_FORMAT)
-#define PP_FORMAT_411    (0x00000002|PP_FORMAT)
-#define PP_FORMAT_444    (0x00000000|PP_FORMAT)
-
-#define PP_PICT_TYPE_QP2  0x00000010 ///< MPEG2 style QScale
-
-/**
- * @}
- */
-
-#endif /* POSTPROC_POSTPROCESS_H */
diff -pruN /usr/include/ffmpeg/libpostproc/version.h csrc/libpostproc/version.h
--- /usr/include/ffmpeg/libpostproc/version.h	2014-10-14 17:38:01.000000000 +0200
+++ csrc/libpostproc/version.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
- * Version macros.
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef POSTPROC_POSTPROCESS_VERSION_H
-#define POSTPROC_POSTPROCESS_VERSION_H
-
-/**
- * @file
- * Libpostproc version macros
- */
-
-#include "libavutil/avutil.h"
-
-#define LIBPOSTPROC_VERSION_MAJOR 52
-#define LIBPOSTPROC_VERSION_MINOR  3
-#define LIBPOSTPROC_VERSION_MICRO 100
-
-#define LIBPOSTPROC_VERSION_INT AV_VERSION_INT(LIBPOSTPROC_VERSION_MAJOR, \
-                                               LIBPOSTPROC_VERSION_MINOR, \
-                                               LIBPOSTPROC_VERSION_MICRO)
-#define LIBPOSTPROC_VERSION     AV_VERSION(LIBPOSTPROC_VERSION_MAJOR, \
-                                           LIBPOSTPROC_VERSION_MINOR, \
-                                           LIBPOSTPROC_VERSION_MICRO)
-#define LIBPOSTPROC_BUILD       LIBPOSTPROC_VERSION_INT
-
-#define LIBPOSTPROC_IDENT       "postproc" AV_STRINGIFY(LIBPOSTPROC_VERSION)
-
-#endif /* POSTPROC_POSTPROCESS_VERSION_H */
diff -pruN /usr/include/ffmpeg/libswresample/swresample.h csrc/libswresample/swresample.h
--- /usr/include/ffmpeg/libswresample/swresample.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libswresample/swresample.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,469 +0,0 @@
-/*
- * Copyright (C) 2011-2013 Michael Niedermayer (michaelni@gmx.at)
- *
- * This file is part of libswresample
- *
- * libswresample is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * libswresample is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with libswresample; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef SWRESAMPLE_SWRESAMPLE_H
-#define SWRESAMPLE_SWRESAMPLE_H
-
-/**
- * @file
- * @ingroup lswr
- * libswresample public header
- */
-
-/**
- * @defgroup lswr Libswresample
- * @{
- *
- * Libswresample (lswr) is a library that handles audio resampling, sample
- * format conversion and mixing.
- *
- * Interaction with lswr is done through SwrContext, which is
- * allocated with swr_alloc() or swr_alloc_set_opts(). It is opaque, so all parameters
- * must be set with the @ref avoptions API.
- *
- * The first thing you will need to do in order to use lswr is to allocate
- * SwrContext. This can be done with swr_alloc() or swr_alloc_set_opts(). If you
- * are using the former, you must set options through the @ref avoptions API.
- * The latter function provides the same feature, but it allows you to set some
- * common options in the same statement.
- *
- * For example the following code will setup conversion from planar float sample
- * format to interleaved signed 16-bit integer, downsampling from 48kHz to
- * 44.1kHz and downmixing from 5.1 channels to stereo (using the default mixing
- * matrix). This is using the swr_alloc() function.
- * @code
- * SwrContext *swr = swr_alloc();
- * av_opt_set_channel_layout(swr, "in_channel_layout",  AV_CH_LAYOUT_5POINT1, 0);
- * av_opt_set_channel_layout(swr, "out_channel_layout", AV_CH_LAYOUT_STEREO,  0);
- * av_opt_set_int(swr, "in_sample_rate",     48000,                0);
- * av_opt_set_int(swr, "out_sample_rate",    44100,                0);
- * av_opt_set_sample_fmt(swr, "in_sample_fmt",  AV_SAMPLE_FMT_FLTP, 0);
- * av_opt_set_sample_fmt(swr, "out_sample_fmt", AV_SAMPLE_FMT_S16,  0);
- * @endcode
- *
- * The same job can be done using swr_alloc_set_opts() as well:
- * @code
- * SwrContext *swr = swr_alloc_set_opts(NULL,  // we're allocating a new context
- *                       AV_CH_LAYOUT_STEREO,  // out_ch_layout
- *                       AV_SAMPLE_FMT_S16,    // out_sample_fmt
- *                       44100,                // out_sample_rate
- *                       AV_CH_LAYOUT_5POINT1, // in_ch_layout
- *                       AV_SAMPLE_FMT_FLTP,   // in_sample_fmt
- *                       48000,                // in_sample_rate
- *                       0,                    // log_offset
- *                       NULL);                // log_ctx
- * @endcode
- *
- * Once all values have been set, it must be initialized with swr_init(). If
- * you need to change the conversion parameters, you can change the parameters
- * using @ref AVOptions, as described above in the first example; or by using
- * swr_alloc_set_opts(), but with the first argument the allocated context.
- * You must then call swr_init() again.
- *
- * The conversion itself is done by repeatedly calling swr_convert().
- * Note that the samples may get buffered in swr if you provide insufficient
- * output space or if sample rate conversion is done, which requires "future"
- * samples. Samples that do not require future input can be retrieved at any
- * time by using swr_convert() (in_count can be set to 0).
- * At the end of conversion the resampling buffer can be flushed by calling
- * swr_convert() with NULL in and 0 in_count.
- *
- * The samples used in the conversion process can be managed with the libavutil
- * @ref lavu_sampmanip "samples manipulation" API, including av_samples_alloc()
- * function used in the following example.
- *
- * The delay between input and output, can at any time be found by using
- * swr_get_delay().
- *
- * The following code demonstrates the conversion loop assuming the parameters
- * from above and caller-defined functions get_input() and handle_output():
- * @code
- * uint8_t **input;
- * int in_samples;
- *
- * while (get_input(&input, &in_samples)) {
- *     uint8_t *output;
- *     int out_samples = av_rescale_rnd(swr_get_delay(swr, 48000) +
- *                                      in_samples, 44100, 48000, AV_ROUND_UP);
- *     av_samples_alloc(&output, NULL, 2, out_samples,
- *                      AV_SAMPLE_FMT_S16, 0);
- *     out_samples = swr_convert(swr, &output, out_samples,
- *                                      input, in_samples);
- *     handle_output(output, out_samples);
- *     av_freep(&output);
- * }
- * @endcode
- *
- * When the conversion is finished, the conversion
- * context and everything associated with it must be freed with swr_free().
- * A swr_close() function is also available, but it exists mainly for
- * compatibility with libavresample, and is not required to be called.
- *
- * There will be no memory leak if the data is not completely flushed before
- * swr_free().
- */
-
-#include <stdint.h>
-#include "libavutil/samplefmt.h"
-
-#include "libswresample/version.h"
-
-#if LIBSWRESAMPLE_VERSION_MAJOR < 1
-#define SWR_CH_MAX 32   ///< Maximum number of channels
-#endif
-
-/**
- * @name Option constants
- * These constants are used for the @ref avoptions interface for lswr.
- * @{
- *
- */
-
-#define SWR_FLAG_RESAMPLE 1 ///< Force resampling even if equal sample rate
-//TODO use int resample ?
-//long term TODO can we enable this dynamically?
-
-/** Dithering algorithms */
-enum SwrDitherType {
-    SWR_DITHER_NONE = 0,
-    SWR_DITHER_RECTANGULAR,
-    SWR_DITHER_TRIANGULAR,
-    SWR_DITHER_TRIANGULAR_HIGHPASS,
-
-    SWR_DITHER_NS = 64,         ///< not part of API/ABI
-    SWR_DITHER_NS_LIPSHITZ,
-    SWR_DITHER_NS_F_WEIGHTED,
-    SWR_DITHER_NS_MODIFIED_E_WEIGHTED,
-    SWR_DITHER_NS_IMPROVED_E_WEIGHTED,
-    SWR_DITHER_NS_SHIBATA,
-    SWR_DITHER_NS_LOW_SHIBATA,
-    SWR_DITHER_NS_HIGH_SHIBATA,
-    SWR_DITHER_NB,              ///< not part of API/ABI
-};
-
-/** Resampling Engines */
-enum SwrEngine {
-    SWR_ENGINE_SWR,             /**< SW Resampler */
-    SWR_ENGINE_SOXR,            /**< SoX Resampler */
-    SWR_ENGINE_NB,              ///< not part of API/ABI
-};
-
-/** Resampling Filter Types */
-enum SwrFilterType {
-    SWR_FILTER_TYPE_CUBIC,              /**< Cubic */
-    SWR_FILTER_TYPE_BLACKMAN_NUTTALL,   /**< Blackman Nuttall Windowed Sinc */
-    SWR_FILTER_TYPE_KAISER,             /**< Kaiser Windowed Sinc */
-};
-
-/**
- * @}
- */
-
-/**
- * The libswresample context. Unlike libavcodec and libavformat, this structure
- * is opaque. This means that if you would like to set options, you must use
- * the @ref avoptions API and cannot directly set values to members of the
- * structure.
- */
-typedef struct SwrContext SwrContext;
-
-/**
- * Get the AVClass for SwrContext. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- * @return the AVClass of SwrContext
- */
-const AVClass *swr_get_class(void);
-
-/**
- * @name SwrContext constructor functions
- * @{
- */
-
-/**
- * Allocate SwrContext.
- *
- * If you use this function you will need to set the parameters (manually or
- * with swr_alloc_set_opts()) before calling swr_init().
- *
- * @see swr_alloc_set_opts(), swr_init(), swr_free()
- * @return NULL on error, allocated context otherwise
- */
-struct SwrContext *swr_alloc(void);
-
-/**
- * Initialize context after user parameters have been set.
- *
- * @param[in,out]   s Swr context to initialize
- * @return AVERROR error code in case of failure.
- */
-int swr_init(struct SwrContext *s);
-
-/**
- * Check whether an swr context has been initialized or not.
- *
- * @param[in]       s Swr context to check
- * @see swr_init()
- * @return positive if it has been initialized, 0 if not initialized
- */
-int swr_is_initialized(struct SwrContext *s);
-
-/**
- * Allocate SwrContext if needed and set/reset common parameters.
- *
- * This function does not require s to be allocated with swr_alloc(). On the
- * other hand, swr_alloc() can use swr_alloc_set_opts() to set the parameters
- * on the allocated context.
- *
- * @param s               existing Swr context if available, or NULL if not
- * @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)
- * @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).
- * @param out_sample_rate output sample rate (frequency in Hz)
- * @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)
- * @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).
- * @param in_sample_rate  input sample rate (frequency in Hz)
- * @param log_offset      logging level offset
- * @param log_ctx         parent logging context, can be NULL
- *
- * @see swr_init(), swr_free()
- * @return NULL on error, allocated context otherwise
- */
-struct SwrContext *swr_alloc_set_opts(struct SwrContext *s,
-                                      int64_t out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate,
-                                      int64_t  in_ch_layout, enum AVSampleFormat  in_sample_fmt, int  in_sample_rate,
-                                      int log_offset, void *log_ctx);
-
-/**
- * @}
- *
- * @name SwrContext destructor functions
- * @{
- */
-
-/**
- * Free the given SwrContext and set the pointer to NULL.
- *
- * @param[in] s a pointer to a pointer to Swr context
- */
-void swr_free(struct SwrContext **s);
-
-/**
- * Closes the context so that swr_is_initialized() returns 0.
- *
- * The context can be brought back to life by running swr_init(),
- * swr_init() can also be used without swr_close().
- * This function is mainly provided for simplifying the usecase
- * where one tries to support libavresample and libswresample.
- *
- * @param[in,out] s Swr context to be closed
- */
-void swr_close(struct SwrContext *s);
-
-/**
- * @}
- *
- * @name Core conversion functions
- * @{
- */
-
-/** Convert audio.
- *
- * in and in_count can be set to 0 to flush the last few samples out at the
- * end.
- *
- * If more input is provided than output space then the input will be buffered.
- * You can avoid this buffering by providing more output space than input.
- * Conversion will run directly without copying whenever possible.
- *
- * @param s         allocated Swr context, with parameters set
- * @param out       output buffers, only the first one need be set in case of packed audio
- * @param out_count amount of space available for output in samples per channel
- * @param in        input buffers, only the first one need to be set in case of packed audio
- * @param in_count  number of input samples available in one channel
- *
- * @return number of samples output per channel, negative value on error
- */
-int swr_convert(struct SwrContext *s, uint8_t **out, int out_count,
-                                const uint8_t **in , int in_count);
-
-/**
- * Convert the next timestamp from input to output
- * timestamps are in 1/(in_sample_rate * out_sample_rate) units.
- *
- * @note There are 2 slightly differently behaving modes.
- *       @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)
- *              in this case timestamps will be passed through with delays compensated
- *       @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)
- *              in this case the output timestamps will match output sample numbers.
- *              See ffmpeg-resampler(1) for the two modes of compensation.
- *
- * @param s[in]     initialized Swr context
- * @param pts[in]   timestamp for the next input sample, INT64_MIN if unknown
- * @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are
- *      function used internally for timestamp compensation.
- * @return the output timestamp for the next output sample
- */
-int64_t swr_next_pts(struct SwrContext *s, int64_t pts);
-
-/**
- * @}
- *
- * @name Low-level option setting functions
- * These functons provide a means to set low-level options that is not possible
- * with the AVOption API.
- * @{
- */
-
-/**
- * Activate resampling compensation ("soft" compensation). This function is
- * internally called when needed in swr_next_pts().
- *
- * @param[in,out] s             allocated Swr context. If it is not initialized,
- *                              or SWR_FLAG_RESAMPLE is not set, swr_init() is
- *                              called with the flag set.
- * @param[in]     sample_delta  delta in PTS per sample
- * @param[in]     compensation_distance number of samples to compensate for
- * @return    >= 0 on success, AVERROR error codes if:
- *            @li @c s is NULL,
- *            @li @c compensation_distance is less than 0,
- *            @li @c compensation_distance is 0 but sample_delta is not,
- *            @li compensation unsupported by resampler, or
- *            @li swr_init() fails when called.
- */
-int swr_set_compensation(struct SwrContext *s, int sample_delta, int compensation_distance);
-
-/**
- * Set a customized input channel mapping.
- *
- * @param[in,out] s           allocated Swr context, not yet initialized
- * @param[in]     channel_map customized input channel mapping (array of channel
- *                            indexes, -1 for a muted channel)
- * @return >= 0 on success, or AVERROR error code in case of failure.
- */
-int swr_set_channel_mapping(struct SwrContext *s, const int *channel_map);
-
-/**
- * Set a customized remix matrix.
- *
- * @param s       allocated Swr context, not yet initialized
- * @param matrix  remix coefficients; matrix[i + stride * o] is
- *                the weight of input channel i in output channel o
- * @param stride  offset between lines of the matrix
- * @return  >= 0 on success, or AVERROR error code in case of failure.
- */
-int swr_set_matrix(struct SwrContext *s, const double *matrix, int stride);
-
-/**
- * @}
- *
- * @name Sample handling functions
- * @{
- */
-
-/**
- * Drops the specified number of output samples.
- *
- * This function, along with swr_inject_silence(), is called by swr_next_pts()
- * if needed for "hard" compensation.
- *
- * @param s     allocated Swr context
- * @param count number of samples to be dropped
- *
- * @return >= 0 on success, or a negative AVERROR code on failure
- */
-int swr_drop_output(struct SwrContext *s, int count);
-
-/**
- * Injects the specified number of silence samples.
- *
- * This function, along with swr_drop_output(), is called by swr_next_pts()
- * if needed for "hard" compensation.
- *
- * @param s     allocated Swr context
- * @param count number of samples to be dropped
- *
- * @return >= 0 on success, or a negative AVERROR code on failure
- */
-int swr_inject_silence(struct SwrContext *s, int count);
-
-/**
- * Gets the delay the next input sample will experience relative to the next output sample.
- *
- * Swresample can buffer data if more input has been provided than available
- * output space, also converting between sample rates needs a delay.
- * This function returns the sum of all such delays.
- * The exact delay is not necessarily an integer value in either input or
- * output sample rate. Especially when downsampling by a large value, the
- * output sample rate may be a poor choice to represent the delay, similarly
- * for upsampling and the input sample rate.
- *
- * @param s     swr context
- * @param base  timebase in which the returned delay will be:
- *              @li if it's set to 1 the returned delay is in seconds
- *              @li if it's set to 1000 the returned delay is in milliseconds
- *              @li if it's set to the input sample rate then the returned
- *                  delay is in input samples
- *              @li if it's set to the output sample rate then the returned
- *                  delay is in output samples
- *              @li if it's the least common multiple of in_sample_rate and
- *                  out_sample_rate then an exact rounding-free delay will be
- *                  returned
- * @returns     the delay in 1 / @c base units.
- */
-int64_t swr_get_delay(struct SwrContext *s, int64_t base);
-
-/**
- * @}
- *
- * @name Configuration accessors
- * @{
- */
-
-/**
- * Return the @ref LIBSWRESAMPLE_VERSION_INT constant.
- *
- * This is useful to check if the build-time libswresample has the same version
- * as the run-time one.
- *
- * @returns     the unsigned int-typed version
- */
-unsigned swresample_version(void);
-
-/**
- * Return the swr build-time configuration.
- *
- * @returns     the build-time @c ./configure flags
- */
-const char *swresample_configuration(void);
-
-/**
- * Return the swr license.
- *
- * @returns     the license of libswresample, determined at build-time
- */
-const char *swresample_license(void);
-
-/**
- * @}
- * @}
- */
-
-#endif /* SWRESAMPLE_SWRESAMPLE_H */
diff -pruN /usr/include/ffmpeg/libswresample/version.h csrc/libswresample/version.h
--- /usr/include/ffmpeg/libswresample/version.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libswresample/version.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
- * Version macros.
- *
- * This file is part of libswresample
- *
- * libswresample is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * libswresample is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with libswresample; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef SWR_VERSION_H
-#define SWR_VERSION_H
-
-/**
- * @file
- * Libswresample version macros
- */
-
-#include "libavutil/avutil.h"
-
-#define LIBSWRESAMPLE_VERSION_MAJOR 0
-#define LIBSWRESAMPLE_VERSION_MINOR 19
-#define LIBSWRESAMPLE_VERSION_MICRO 100
-
-#define LIBSWRESAMPLE_VERSION_INT  AV_VERSION_INT(LIBSWRESAMPLE_VERSION_MAJOR, \
-                                                  LIBSWRESAMPLE_VERSION_MINOR, \
-                                                  LIBSWRESAMPLE_VERSION_MICRO)
-#define LIBSWRESAMPLE_VERSION      AV_VERSION(LIBSWRESAMPLE_VERSION_MAJOR, \
-                                              LIBSWRESAMPLE_VERSION_MINOR, \
-                                              LIBSWRESAMPLE_VERSION_MICRO)
-#define LIBSWRESAMPLE_BUILD        LIBSWRESAMPLE_VERSION_INT
-
-#define LIBSWRESAMPLE_IDENT        "SwR" AV_STRINGIFY(LIBSWRESAMPLE_VERSION)
-
-#endif /* SWR_VERSION_H */
diff -pruN /usr/include/ffmpeg/libswscale/swscale.h csrc/libswscale/swscale.h
--- /usr/include/ffmpeg/libswscale/swscale.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libswscale/swscale.h	2014-10-20 10:36:46.390482631 +0200
@@ -1,32 +1,7 @@
-/*
- * Copyright (C) 2001-2011 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
 
 #ifndef SWSCALE_SWSCALE_H
 #define SWSCALE_SWSCALE_H
 
-/**
- * @file
- * @ingroup libsws
- * external API header
- */
-
 #include <stdint.h>
 
 #include "libavutil/avutil.h"
@@ -34,25 +9,12 @@
 #include "libavutil/pixfmt.h"
 #include "version.h"
 
-/**
- * @defgroup libsws Color conversion and scaling
- * @{
- *
- * Return the LIBSWSCALE_VERSION_INT constant.
- */
 unsigned swscale_version(void);
 
-/**
- * Return the libswscale build-time configuration.
- */
 const char *swscale_configuration(void);
 
-/**
- * Return the libswscale license.
- */
 const char *swscale_license(void);
 
-/* values for the flags, the stuff on the command line is different */
 #define SWS_FAST_BILINEAR     1
 #define SWS_BILINEAR          2
 #define SWS_BICUBIC           4
@@ -72,10 +34,7 @@ const char *swscale_license(void);
 
 #define SWS_PRINT_INFO              0x1000
 
-//the following 3 flags are not completely implemented
-//internal chrominace subsampling info
 #define SWS_FULL_CHR_H_INT    0x2000
-//input subsampling info
 #define SWS_FULL_CHR_H_INP    0x4000
 #define SWS_DIRECT_BGR        0x8000
 #define SWS_ACCURATE_RND      0x40000
@@ -83,10 +42,6 @@ const char *swscale_license(void);
 #define SWS_ERROR_DIFFUSION  0x800000
 
 #if FF_API_SWS_CPU_CAPS
-/**
- * CPU caps are autodetected now, those flags
- * are only provided for API compatibility.
- */
 #define SWS_CPU_CAPS_MMX      0x80000000
 #define SWS_CPU_CAPS_MMXEXT   0x20000000
 #define SWS_CPU_CAPS_MMX2     0x20000000
@@ -108,255 +63,18 @@ const char *swscale_license(void);
 #define SWS_CS_SMPTE240M      7
 #define SWS_CS_DEFAULT        5
 
-/**
- * Return a pointer to yuv<->rgb coefficients for the given colorspace
- * suitable for sws_setColorspaceDetails().
- *
- * @param colorspace One of the SWS_CS_* macros. If invalid,
- * SWS_CS_DEFAULT is used.
- */
-const int *sws_getCoefficients(int colorspace);
-
-// when used for filters they must have an odd number of elements
-// coeffs cannot be shared between vectors
-typedef struct SwsVector {
-    double *coeff;              ///< pointer to the list of coefficients
-    int length;                 ///< number of coefficients in the vector
-} SwsVector;
-
-// vectors can be shared
-typedef struct SwsFilter {
-    SwsVector *lumH;
-    SwsVector *lumV;
-    SwsVector *chrH;
-    SwsVector *chrV;
-} SwsFilter;
-
-struct SwsContext;
-
-/**
- * Return a positive value if pix_fmt is a supported input format, 0
- * otherwise.
- */
-int sws_isSupportedInput(enum AVPixelFormat pix_fmt);
-
-/**
- * Return a positive value if pix_fmt is a supported output format, 0
- * otherwise.
- */
-int sws_isSupportedOutput(enum AVPixelFormat pix_fmt);
-
-/**
- * @param[in]  pix_fmt the pixel format
- * @return a positive value if an endianness conversion for pix_fmt is
- * supported, 0 otherwise.
- */
-int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt);
-
-/**
- * Allocate an empty SwsContext. This must be filled and passed to
- * sws_init_context(). For filling see AVOptions, options.c and
- * sws_setColorspaceDetails().
- */
-struct SwsContext *sws_alloc_context(void);
-
-/**
- * Initialize the swscaler context sws_context.
- *
- * @return zero or positive value on success, a negative value on
- * error
- */
-int sws_init_context(struct SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter);
-
-/**
- * Free the swscaler context swsContext.
- * If swsContext is NULL, then does nothing.
- */
+typedef struct SwsContext;
 void sws_freeContext(struct SwsContext *swsContext);
 
 #if FF_API_SWS_GETCONTEXT
-/**
- * Allocate and return an SwsContext. You need it to perform
- * scaling/conversion operations using sws_scale().
- *
- * @param srcW the width of the source image
- * @param srcH the height of the source image
- * @param srcFormat the source image format
- * @param dstW the width of the destination image
- * @param dstH the height of the destination image
- * @param dstFormat the destination image format
- * @param flags specify which algorithm and options to use for rescaling
- * @return a pointer to an allocated context, or NULL in case of error
- * @note this function is to be removed after a saner alternative is
- *       written
- * @deprecated Use sws_getCachedContext() instead.
- */
 struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat,
                                   int dstW, int dstH, enum AVPixelFormat dstFormat,
                                   int flags, SwsFilter *srcFilter,
                                   SwsFilter *dstFilter, const double *param);
 #endif
 
-/**
- * Scale the image slice in srcSlice and put the resulting scaled
- * slice in the image in dst. A slice is a sequence of consecutive
- * rows in an image.
- *
- * Slices have to be provided in sequential order, either in
- * top-bottom or bottom-top order. If slices are provided in
- * non-sequential order the behavior of the function is undefined.
- *
- * @param c         the scaling context previously created with
- *                  sws_getContext()
- * @param srcSlice  the array containing the pointers to the planes of
- *                  the source slice
- * @param srcStride the array containing the strides for each plane of
- *                  the source image
- * @param srcSliceY the position in the source image of the slice to
- *                  process, that is the number (counted starting from
- *                  zero) in the image of the first row of the slice
- * @param srcSliceH the height of the source slice, that is the number
- *                  of rows in the slice
- * @param dst       the array containing the pointers to the planes of
- *                  the destination image
- * @param dstStride the array containing the strides for each plane of
- *                  the destination image
- * @return          the height of the output slice
- */
 int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[],
               const int srcStride[], int srcSliceY, int srcSliceH,
               uint8_t *const dst[], const int dstStride[]);
 
-/**
- * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)
- * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)
- * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]
- * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]
- * @param brightness 16.16 fixed point brightness correction
- * @param contrast 16.16 fixed point contrast correction
- * @param saturation 16.16 fixed point saturation correction
- * @return -1 if not supported
- */
-int sws_setColorspaceDetails(struct SwsContext *c, const int inv_table[4],
-                             int srcRange, const int table[4], int dstRange,
-                             int brightness, int contrast, int saturation);
-
-/**
- * @return -1 if not supported
- */
-int sws_getColorspaceDetails(struct SwsContext *c, int **inv_table,
-                             int *srcRange, int **table, int *dstRange,
-                             int *brightness, int *contrast, int *saturation);
-
-/**
- * Allocate and return an uninitialized vector with length coefficients.
- */
-SwsVector *sws_allocVec(int length);
-
-/**
- * Return a normalized Gaussian curve used to filter stuff
- * quality = 3 is high quality, lower is lower quality.
- */
-SwsVector *sws_getGaussianVec(double variance, double quality);
-
-/**
- * Allocate and return a vector with length coefficients, all
- * with the same value c.
- */
-SwsVector *sws_getConstVec(double c, int length);
-
-/**
- * Allocate and return a vector with just one coefficient, with
- * value 1.0.
- */
-SwsVector *sws_getIdentityVec(void);
-
-/**
- * Scale all the coefficients of a by the scalar value.
- */
-void sws_scaleVec(SwsVector *a, double scalar);
-
-/**
- * Scale all the coefficients of a so that their sum equals height.
- */
-void sws_normalizeVec(SwsVector *a, double height);
-void sws_convVec(SwsVector *a, SwsVector *b);
-void sws_addVec(SwsVector *a, SwsVector *b);
-void sws_subVec(SwsVector *a, SwsVector *b);
-void sws_shiftVec(SwsVector *a, int shift);
-
-/**
- * Allocate and return a clone of the vector a, that is a vector
- * with the same coefficients as a.
- */
-SwsVector *sws_cloneVec(SwsVector *a);
-
-/**
- * Print with av_log() a textual representation of the vector a
- * if log_level <= av_log_level.
- */
-void sws_printVec2(SwsVector *a, AVClass *log_ctx, int log_level);
-
-void sws_freeVec(SwsVector *a);
-
-SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur,
-                                float lumaSharpen, float chromaSharpen,
-                                float chromaHShift, float chromaVShift,
-                                int verbose);
-void sws_freeFilter(SwsFilter *filter);
-
-/**
- * Check if context can be reused, otherwise reallocate a new one.
- *
- * If context is NULL, just calls sws_getContext() to get a new
- * context. Otherwise, checks if the parameters are the ones already
- * saved in context. If that is the case, returns the current
- * context. Otherwise, frees context and gets a new context with
- * the new parameters.
- *
- * Be warned that srcFilter and dstFilter are not checked, they
- * are assumed to remain the same.
- */
-struct SwsContext *sws_getCachedContext(struct SwsContext *context,
-                                        int srcW, int srcH, enum AVPixelFormat srcFormat,
-                                        int dstW, int dstH, enum AVPixelFormat dstFormat,
-                                        int flags, SwsFilter *srcFilter,
-                                        SwsFilter *dstFilter, const double *param);
-
-/**
- * Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.
- *
- * The output frame will have the same packed format as the palette.
- *
- * @param src        source frame buffer
- * @param dst        destination frame buffer
- * @param num_pixels number of pixels to convert
- * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
- */
-void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette);
-
-/**
- * Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.
- *
- * With the palette format "ABCD", the destination frame ends up with the format "ABC".
- *
- * @param src        source frame buffer
- * @param dst        destination frame buffer
- * @param num_pixels number of pixels to convert
- * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
- */
-void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette);
-
-/**
- * Get the AVClass for swsContext. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- */
-const AVClass *sws_get_class(void);
-
-/**
- * @}
- */
-
 #endif /* SWSCALE_SWSCALE_H */
diff -pruN /usr/include/ffmpeg/libswscale/version.h csrc/libswscale/version.h
--- /usr/include/ffmpeg/libswscale/version.h	2014-10-14 17:38:02.000000000 +0200
+++ csrc/libswscale/version.h	2014-10-20 16:56:52.094533678 +0200
@@ -1,29 +1,7 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
 
 #ifndef SWSCALE_VERSION_H
 #define SWSCALE_VERSION_H
 
-/**
- * @file
- * swscale version macros
- */
-
 #include "libavutil/version.h"
 
 #define LIBSWSCALE_VERSION_MAJOR 2
@@ -38,7 +16,7 @@
                                            LIBSWSCALE_VERSION_MICRO)
 #define LIBSWSCALE_BUILD        LIBSWSCALE_VERSION_INT
 
-#define LIBSWSCALE_IDENT        "SwS" AV_STRINGIFY(LIBSWSCALE_VERSION)
+#define LIBSWSCALE_IDENT        "SwS2.6.100"
 
 /**
  * FF_API_* defines may be placed below to indicate public API that will be
