package org.ffmpeg.avcodec;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.SizeT;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.ffmpeg.avutil.AVBufferRef;
import org.ffmpeg.avutil.AVClass;
import org.ffmpeg.avutil.AVDictionary;
import org.ffmpeg.avutil.AVFrame;
import org.ffmpeg.avutil.AVRational;
import org.ffmpeg.avutil.AvutilLibrary.AVChromaLocation;
import org.ffmpeg.avutil.AvutilLibrary.AVMediaType;
import org.ffmpeg.avutil.AvutilLibrary.AVPixelFormat;
import org.ffmpeg.avutil.AvutilLibrary.AVSampleFormat;
/**
 * Wrapper for library <b>avcodec</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avcodec") 
@Runtime(CRuntime.class) 
public class AvcodecLibrary {
	static {
		BridJ.register();
	}
	/**
	 * Identify the syntax and semantics of the bitstream.<br>
	 * The principle is roughly:<br>
	 * Two decoders with the same ID can decode the same streams.<br>
	 * Two encoders with the same ID can encode compatible streams.<br>
	 * There may be slight deviations from the principle due to implementation<br>
	 * details.<br>
	 * * If you add a codec ID to this list, add it so that<br>
	 * 1. no value of an existing codec ID changes (that would break ABI),<br>
	 * 2. it is as close as possible to similar codecs<br>
	 * * After adding new codec IDs, do not forget to add an entry to the codec<br>
	 * descriptor list and bump libavcodec minor version.<br>
	 * enum values<br>
	 * <i>native declaration : ./libavcodec/codec_id.h:531</i>
	 */
	public enum AVCodecID implements IntValuedEnum<AVCodecID > {
		AV_CODEC_ID_NONE(0),
		/** video codecs */
		AV_CODEC_ID_MPEG1VIDEO(1),
		/** < preferred ID for MPEG-1/2 video decoding */
		AV_CODEC_ID_MPEG2VIDEO(2),
		AV_CODEC_ID_H261(3),
		AV_CODEC_ID_H263(4),
		AV_CODEC_ID_RV10(5),
		AV_CODEC_ID_RV20(6),
		AV_CODEC_ID_MJPEG(7),
		AV_CODEC_ID_MJPEGB(8),
		AV_CODEC_ID_LJPEG(9),
		AV_CODEC_ID_SP5X(10),
		AV_CODEC_ID_JPEGLS(11),
		AV_CODEC_ID_MPEG4(12),
		AV_CODEC_ID_RAWVIDEO(13),
		AV_CODEC_ID_MSMPEG4V1(14),
		AV_CODEC_ID_MSMPEG4V2(15),
		AV_CODEC_ID_MSMPEG4V3(16),
		AV_CODEC_ID_WMV1(17),
		AV_CODEC_ID_WMV2(18),
		AV_CODEC_ID_H263P(19),
		AV_CODEC_ID_H263I(20),
		AV_CODEC_ID_FLV1(21),
		AV_CODEC_ID_SVQ1(22),
		AV_CODEC_ID_SVQ3(23),
		AV_CODEC_ID_DVVIDEO(24),
		AV_CODEC_ID_HUFFYUV(25),
		AV_CODEC_ID_CYUV(26),
		AV_CODEC_ID_H264(27),
		AV_CODEC_ID_INDEO3(28),
		AV_CODEC_ID_VP3(29),
		AV_CODEC_ID_THEORA(30),
		AV_CODEC_ID_ASV1(31),
		AV_CODEC_ID_ASV2(32),
		AV_CODEC_ID_FFV1(33),
		AV_CODEC_ID_4XM(34),
		AV_CODEC_ID_VCR1(35),
		AV_CODEC_ID_CLJR(36),
		AV_CODEC_ID_MDEC(37),
		AV_CODEC_ID_ROQ(38),
		AV_CODEC_ID_INTERPLAY_VIDEO(39),
		AV_CODEC_ID_XAN_WC3(40),
		AV_CODEC_ID_XAN_WC4(41),
		AV_CODEC_ID_RPZA(42),
		AV_CODEC_ID_CINEPAK(43),
		AV_CODEC_ID_WS_VQA(44),
		AV_CODEC_ID_MSRLE(45),
		AV_CODEC_ID_MSVIDEO1(46),
		AV_CODEC_ID_IDCIN(47),
		AV_CODEC_ID_8BPS(48),
		AV_CODEC_ID_SMC(49),
		AV_CODEC_ID_FLIC(50),
		AV_CODEC_ID_TRUEMOTION1(51),
		AV_CODEC_ID_VMDVIDEO(52),
		AV_CODEC_ID_MSZH(53),
		AV_CODEC_ID_ZLIB(54),
		AV_CODEC_ID_QTRLE(55),
		AV_CODEC_ID_TSCC(56),
		AV_CODEC_ID_ULTI(57),
		AV_CODEC_ID_QDRAW(58),
		AV_CODEC_ID_VIXL(59),
		AV_CODEC_ID_QPEG(60),
		AV_CODEC_ID_PNG(61),
		AV_CODEC_ID_PPM(62),
		AV_CODEC_ID_PBM(63),
		AV_CODEC_ID_PGM(64),
		AV_CODEC_ID_PGMYUV(65),
		AV_CODEC_ID_PAM(66),
		AV_CODEC_ID_FFVHUFF(67),
		AV_CODEC_ID_RV30(68),
		AV_CODEC_ID_RV40(69),
		AV_CODEC_ID_VC1(70),
		AV_CODEC_ID_WMV3(71),
		AV_CODEC_ID_LOCO(72),
		AV_CODEC_ID_WNV1(73),
		AV_CODEC_ID_AASC(74),
		AV_CODEC_ID_INDEO2(75),
		AV_CODEC_ID_FRAPS(76),
		AV_CODEC_ID_TRUEMOTION2(77),
		AV_CODEC_ID_BMP(78),
		AV_CODEC_ID_CSCD(79),
		AV_CODEC_ID_MMVIDEO(80),
		AV_CODEC_ID_ZMBV(81),
		AV_CODEC_ID_AVS(82),
		AV_CODEC_ID_SMACKVIDEO(83),
		AV_CODEC_ID_NUV(84),
		AV_CODEC_ID_KMVC(85),
		AV_CODEC_ID_FLASHSV(86),
		AV_CODEC_ID_CAVS(87),
		AV_CODEC_ID_JPEG2000(88),
		AV_CODEC_ID_VMNC(89),
		AV_CODEC_ID_VP5(90),
		AV_CODEC_ID_VP6(91),
		AV_CODEC_ID_VP6F(92),
		AV_CODEC_ID_TARGA(93),
		AV_CODEC_ID_DSICINVIDEO(94),
		AV_CODEC_ID_TIERTEXSEQVIDEO(95),
		AV_CODEC_ID_TIFF(96),
		AV_CODEC_ID_GIF(97),
		AV_CODEC_ID_DXA(98),
		AV_CODEC_ID_DNXHD(99),
		AV_CODEC_ID_THP(100),
		AV_CODEC_ID_SGI(101),
		AV_CODEC_ID_C93(102),
		AV_CODEC_ID_BETHSOFTVID(103),
		AV_CODEC_ID_PTX(104),
		AV_CODEC_ID_TXD(105),
		AV_CODEC_ID_VP6A(106),
		AV_CODEC_ID_AMV(107),
		AV_CODEC_ID_VB(108),
		AV_CODEC_ID_PCX(109),
		AV_CODEC_ID_SUNRAST(110),
		AV_CODEC_ID_INDEO4(111),
		AV_CODEC_ID_INDEO5(112),
		AV_CODEC_ID_MIMIC(113),
		AV_CODEC_ID_RL2(114),
		AV_CODEC_ID_ESCAPE124(115),
		AV_CODEC_ID_DIRAC(116),
		AV_CODEC_ID_BFI(117),
		AV_CODEC_ID_CMV(118),
		AV_CODEC_ID_MOTIONPIXELS(119),
		AV_CODEC_ID_TGV(120),
		AV_CODEC_ID_TGQ(121),
		AV_CODEC_ID_TQI(122),
		AV_CODEC_ID_AURA(123),
		AV_CODEC_ID_AURA2(124),
		AV_CODEC_ID_V210X(125),
		AV_CODEC_ID_TMV(126),
		AV_CODEC_ID_V210(127),
		AV_CODEC_ID_DPX(128),
		AV_CODEC_ID_MAD(129),
		AV_CODEC_ID_FRWU(130),
		AV_CODEC_ID_FLASHSV2(131),
		AV_CODEC_ID_CDGRAPHICS(132),
		AV_CODEC_ID_R210(133),
		AV_CODEC_ID_ANM(134),
		AV_CODEC_ID_BINKVIDEO(135),
		AV_CODEC_ID_IFF_ILBM(136),
		AV_CODEC_ID_KGV1(137),
		AV_CODEC_ID_YOP(138),
		AV_CODEC_ID_VP8(139),
		AV_CODEC_ID_PICTOR(140),
		AV_CODEC_ID_ANSI(141),
		AV_CODEC_ID_A64_MULTI(142),
		AV_CODEC_ID_A64_MULTI5(143),
		AV_CODEC_ID_R10K(144),
		AV_CODEC_ID_MXPEG(145),
		AV_CODEC_ID_LAGARITH(146),
		AV_CODEC_ID_PRORES(147),
		AV_CODEC_ID_JV(148),
		AV_CODEC_ID_DFA(149),
		AV_CODEC_ID_WMV3IMAGE(150),
		AV_CODEC_ID_VC1IMAGE(151),
		AV_CODEC_ID_UTVIDEO(152),
		AV_CODEC_ID_BMV_VIDEO(153),
		AV_CODEC_ID_VBLE(154),
		AV_CODEC_ID_DXTORY(155),
		AV_CODEC_ID_V410(156),
		AV_CODEC_ID_XWD(157),
		AV_CODEC_ID_CDXL(158),
		AV_CODEC_ID_XBM(159),
		AV_CODEC_ID_ZEROCODEC(160),
		AV_CODEC_ID_MSS1(161),
		AV_CODEC_ID_MSA1(162),
		AV_CODEC_ID_TSCC2(163),
		AV_CODEC_ID_MTS2(164),
		AV_CODEC_ID_CLLC(165),
		AV_CODEC_ID_MSS2(166),
		AV_CODEC_ID_VP9(167),
		AV_CODEC_ID_AIC(168),
		AV_CODEC_ID_ESCAPE130(169),
		AV_CODEC_ID_G2M(170),
		AV_CODEC_ID_WEBP(171),
		AV_CODEC_ID_HNM4_VIDEO(172),
		AV_CODEC_ID_HEVC(173),
		AV_CODEC_ID_FIC(174),
		AV_CODEC_ID_ALIAS_PIX(175),
		AV_CODEC_ID_BRENDER_PIX(176),
		AV_CODEC_ID_PAF_VIDEO(177),
		AV_CODEC_ID_EXR(178),
		AV_CODEC_ID_VP7(179),
		AV_CODEC_ID_SANM(180),
		AV_CODEC_ID_SGIRLE(181),
		AV_CODEC_ID_MVC1(182),
		AV_CODEC_ID_MVC2(183),
		AV_CODEC_ID_HQX(184),
		AV_CODEC_ID_TDSC(185),
		AV_CODEC_ID_HQ_HQA(186),
		AV_CODEC_ID_HAP(187),
		AV_CODEC_ID_DDS(188),
		AV_CODEC_ID_DXV(189),
		AV_CODEC_ID_SCREENPRESSO(190),
		AV_CODEC_ID_RSCC(191),
		AV_CODEC_ID_AVS2(192),
		AV_CODEC_ID_PGX(193),
		AV_CODEC_ID_AVS3(194),
		AV_CODEC_ID_MSP2(195),
		AV_CODEC_ID_VVC(196),
		AV_CODEC_ID_Y41P(0x8000),
		AV_CODEC_ID_AVRP((0x8000 + 1)),
		AV_CODEC_ID_012V((0x8000 + 2)),
		AV_CODEC_ID_AVUI((0x8000 + 3)),
		AV_CODEC_ID_AYUV((0x8000 + 4)),
		AV_CODEC_ID_TARGA_Y216((0x8000 + 5)),
		AV_CODEC_ID_V308((0x8000 + 6)),
		AV_CODEC_ID_V408((0x8000 + 7)),
		AV_CODEC_ID_YUV4((0x8000 + 8)),
		AV_CODEC_ID_AVRN((0x8000 + 9)),
		AV_CODEC_ID_CPIA((0x8000 + 10)),
		AV_CODEC_ID_XFACE((0x8000 + 11)),
		AV_CODEC_ID_SNOW((0x8000 + 12)),
		AV_CODEC_ID_SMVJPEG((0x8000 + 13)),
		AV_CODEC_ID_APNG((0x8000 + 14)),
		AV_CODEC_ID_DAALA((0x8000 + 15)),
		AV_CODEC_ID_CFHD((0x8000 + 16)),
		AV_CODEC_ID_TRUEMOTION2RT((0x8000 + 17)),
		AV_CODEC_ID_M101((0x8000 + 18)),
		AV_CODEC_ID_MAGICYUV((0x8000 + 19)),
		AV_CODEC_ID_SHEERVIDEO((0x8000 + 20)),
		AV_CODEC_ID_YLC((0x8000 + 21)),
		AV_CODEC_ID_PSD((0x8000 + 22)),
		AV_CODEC_ID_PIXLET((0x8000 + 23)),
		AV_CODEC_ID_SPEEDHQ((0x8000 + 24)),
		AV_CODEC_ID_FMVC((0x8000 + 25)),
		AV_CODEC_ID_SCPR((0x8000 + 26)),
		AV_CODEC_ID_CLEARVIDEO((0x8000 + 27)),
		AV_CODEC_ID_XPM((0x8000 + 28)),
		AV_CODEC_ID_AV1((0x8000 + 29)),
		AV_CODEC_ID_BITPACKED((0x8000 + 30)),
		AV_CODEC_ID_MSCC((0x8000 + 31)),
		AV_CODEC_ID_SRGC((0x8000 + 32)),
		AV_CODEC_ID_SVG((0x8000 + 33)),
		AV_CODEC_ID_GDV((0x8000 + 34)),
		AV_CODEC_ID_FITS((0x8000 + 35)),
		AV_CODEC_ID_IMM4((0x8000 + 36)),
		AV_CODEC_ID_PROSUMER((0x8000 + 37)),
		AV_CODEC_ID_MWSC((0x8000 + 38)),
		AV_CODEC_ID_WCMV((0x8000 + 39)),
		AV_CODEC_ID_RASC((0x8000 + 40)),
		AV_CODEC_ID_HYMT((0x8000 + 41)),
		AV_CODEC_ID_ARBC((0x8000 + 42)),
		AV_CODEC_ID_AGM((0x8000 + 43)),
		AV_CODEC_ID_LSCR((0x8000 + 44)),
		AV_CODEC_ID_VP4((0x8000 + 45)),
		AV_CODEC_ID_IMM5((0x8000 + 46)),
		AV_CODEC_ID_MVDV((0x8000 + 47)),
		AV_CODEC_ID_MVHA((0x8000 + 48)),
		AV_CODEC_ID_CDTOONS((0x8000 + 49)),
		AV_CODEC_ID_MV30((0x8000 + 50)),
		AV_CODEC_ID_NOTCHLC((0x8000 + 51)),
		AV_CODEC_ID_PFM((0x8000 + 52)),
		AV_CODEC_ID_MOBICLIP((0x8000 + 53)),
		AV_CODEC_ID_PHOTOCD((0x8000 + 54)),
		AV_CODEC_ID_IPU((0x8000 + 55)),
		AV_CODEC_ID_ARGO((0x8000 + 56)),
		AV_CODEC_ID_CRI((0x8000 + 57)),
		AV_CODEC_ID_SIMBIOSIS_IMX((0x8000 + 58)),
		AV_CODEC_ID_SGA_VIDEO((0x8000 + 59)),
		/**
		 * various PCM "codecs"<br>
		 * < A dummy id pointing at the start of audio codecs
		 */
		AV_CODEC_ID_FIRST_AUDIO(0x10000),
		AV_CODEC_ID_PCM_S16LE(0x10000),
		AV_CODEC_ID_PCM_S16BE((0x10000 + 1)),
		AV_CODEC_ID_PCM_U16LE((0x10000 + 2)),
		AV_CODEC_ID_PCM_U16BE((0x10000 + 3)),
		AV_CODEC_ID_PCM_S8((0x10000 + 4)),
		AV_CODEC_ID_PCM_U8((0x10000 + 5)),
		AV_CODEC_ID_PCM_MULAW((0x10000 + 6)),
		AV_CODEC_ID_PCM_ALAW((0x10000 + 7)),
		AV_CODEC_ID_PCM_S32LE((0x10000 + 8)),
		AV_CODEC_ID_PCM_S32BE((0x10000 + 9)),
		AV_CODEC_ID_PCM_U32LE((0x10000 + 10)),
		AV_CODEC_ID_PCM_U32BE((0x10000 + 11)),
		AV_CODEC_ID_PCM_S24LE((0x10000 + 12)),
		AV_CODEC_ID_PCM_S24BE((0x10000 + 13)),
		AV_CODEC_ID_PCM_U24LE((0x10000 + 14)),
		AV_CODEC_ID_PCM_U24BE((0x10000 + 15)),
		AV_CODEC_ID_PCM_S24DAUD((0x10000 + 16)),
		AV_CODEC_ID_PCM_ZORK((0x10000 + 17)),
		AV_CODEC_ID_PCM_S16LE_PLANAR((0x10000 + 18)),
		AV_CODEC_ID_PCM_DVD((0x10000 + 19)),
		AV_CODEC_ID_PCM_F32BE((0x10000 + 20)),
		AV_CODEC_ID_PCM_F32LE((0x10000 + 21)),
		AV_CODEC_ID_PCM_F64BE((0x10000 + 22)),
		AV_CODEC_ID_PCM_F64LE((0x10000 + 23)),
		AV_CODEC_ID_PCM_BLURAY((0x10000 + 24)),
		AV_CODEC_ID_PCM_LXF((0x10000 + 25)),
		AV_CODEC_ID_S302M((0x10000 + 26)),
		AV_CODEC_ID_PCM_S8_PLANAR((0x10000 + 27)),
		AV_CODEC_ID_PCM_S24LE_PLANAR((0x10000 + 28)),
		AV_CODEC_ID_PCM_S32LE_PLANAR((0x10000 + 29)),
		AV_CODEC_ID_PCM_S16BE_PLANAR((0x10000 + 30)),
		AV_CODEC_ID_PCM_S64LE(0x10800),
		AV_CODEC_ID_PCM_S64BE((0x10800 + 1)),
		AV_CODEC_ID_PCM_F16LE((0x10800 + 2)),
		AV_CODEC_ID_PCM_F24LE((0x10800 + 3)),
		AV_CODEC_ID_PCM_VIDC((0x10800 + 4)),
		AV_CODEC_ID_PCM_SGA((0x10800 + 5)),
		/** various ADPCM codecs */
		AV_CODEC_ID_ADPCM_IMA_QT(0x11000),
		AV_CODEC_ID_ADPCM_IMA_WAV((0x11000 + 1)),
		AV_CODEC_ID_ADPCM_IMA_DK3((0x11000 + 2)),
		AV_CODEC_ID_ADPCM_IMA_DK4((0x11000 + 3)),
		AV_CODEC_ID_ADPCM_IMA_WS((0x11000 + 4)),
		AV_CODEC_ID_ADPCM_IMA_SMJPEG((0x11000 + 5)),
		AV_CODEC_ID_ADPCM_MS((0x11000 + 6)),
		AV_CODEC_ID_ADPCM_4XM((0x11000 + 7)),
		AV_CODEC_ID_ADPCM_XA((0x11000 + 8)),
		AV_CODEC_ID_ADPCM_ADX((0x11000 + 9)),
		AV_CODEC_ID_ADPCM_EA((0x11000 + 10)),
		AV_CODEC_ID_ADPCM_G726((0x11000 + 11)),
		AV_CODEC_ID_ADPCM_CT((0x11000 + 12)),
		AV_CODEC_ID_ADPCM_SWF((0x11000 + 13)),
		AV_CODEC_ID_ADPCM_YAMAHA((0x11000 + 14)),
		AV_CODEC_ID_ADPCM_SBPRO_4((0x11000 + 15)),
		AV_CODEC_ID_ADPCM_SBPRO_3((0x11000 + 16)),
		AV_CODEC_ID_ADPCM_SBPRO_2((0x11000 + 17)),
		AV_CODEC_ID_ADPCM_THP((0x11000 + 18)),
		AV_CODEC_ID_ADPCM_IMA_AMV((0x11000 + 19)),
		AV_CODEC_ID_ADPCM_EA_R1((0x11000 + 20)),
		AV_CODEC_ID_ADPCM_EA_R3((0x11000 + 21)),
		AV_CODEC_ID_ADPCM_EA_R2((0x11000 + 22)),
		AV_CODEC_ID_ADPCM_IMA_EA_SEAD((0x11000 + 23)),
		AV_CODEC_ID_ADPCM_IMA_EA_EACS((0x11000 + 24)),
		AV_CODEC_ID_ADPCM_EA_XAS((0x11000 + 25)),
		AV_CODEC_ID_ADPCM_EA_MAXIS_XA((0x11000 + 26)),
		AV_CODEC_ID_ADPCM_IMA_ISS((0x11000 + 27)),
		AV_CODEC_ID_ADPCM_G722((0x11000 + 28)),
		AV_CODEC_ID_ADPCM_IMA_APC((0x11000 + 29)),
		AV_CODEC_ID_ADPCM_VIMA((0x11000 + 30)),
		AV_CODEC_ID_ADPCM_AFC(0x11800),
		AV_CODEC_ID_ADPCM_IMA_OKI((0x11800 + 1)),
		AV_CODEC_ID_ADPCM_DTK((0x11800 + 2)),
		AV_CODEC_ID_ADPCM_IMA_RAD((0x11800 + 3)),
		AV_CODEC_ID_ADPCM_G726LE((0x11800 + 4)),
		AV_CODEC_ID_ADPCM_THP_LE((0x11800 + 5)),
		AV_CODEC_ID_ADPCM_PSX((0x11800 + 6)),
		AV_CODEC_ID_ADPCM_AICA((0x11800 + 7)),
		AV_CODEC_ID_ADPCM_IMA_DAT4((0x11800 + 8)),
		AV_CODEC_ID_ADPCM_MTAF((0x11800 + 9)),
		AV_CODEC_ID_ADPCM_AGM((0x11800 + 10)),
		AV_CODEC_ID_ADPCM_ARGO((0x11800 + 11)),
		AV_CODEC_ID_ADPCM_IMA_SSI((0x11800 + 12)),
		AV_CODEC_ID_ADPCM_ZORK((0x11800 + 13)),
		AV_CODEC_ID_ADPCM_IMA_APM((0x11800 + 14)),
		AV_CODEC_ID_ADPCM_IMA_ALP((0x11800 + 15)),
		AV_CODEC_ID_ADPCM_IMA_MTF((0x11800 + 16)),
		AV_CODEC_ID_ADPCM_IMA_CUNNING((0x11800 + 17)),
		AV_CODEC_ID_ADPCM_IMA_MOFLEX((0x11800 + 18)),
		/** AMR */
		AV_CODEC_ID_AMR_NB(0x12000),
		AV_CODEC_ID_AMR_WB((0x12000 + 1)),
		/** RealAudio codecs */
		AV_CODEC_ID_RA_144(0x13000),
		AV_CODEC_ID_RA_288((0x13000 + 1)),
		/** various DPCM codecs */
		AV_CODEC_ID_ROQ_DPCM(0x14000),
		AV_CODEC_ID_INTERPLAY_DPCM((0x14000 + 1)),
		AV_CODEC_ID_XAN_DPCM((0x14000 + 2)),
		AV_CODEC_ID_SOL_DPCM((0x14000 + 3)),
		AV_CODEC_ID_SDX2_DPCM(0x14800),
		AV_CODEC_ID_GREMLIN_DPCM((0x14800 + 1)),
		AV_CODEC_ID_DERF_DPCM((0x14800 + 2)),
		/** audio codecs */
		AV_CODEC_ID_MP2(0x15000),
		/** < preferred ID for decoding MPEG audio layer 1, 2 or 3 */
		AV_CODEC_ID_MP3((0x15000 + 1)),
		AV_CODEC_ID_AAC((0x15000 + 2)),
		AV_CODEC_ID_AC3((0x15000 + 3)),
		AV_CODEC_ID_DTS((0x15000 + 4)),
		AV_CODEC_ID_VORBIS((0x15000 + 5)),
		AV_CODEC_ID_DVAUDIO((0x15000 + 6)),
		AV_CODEC_ID_WMAV1((0x15000 + 7)),
		AV_CODEC_ID_WMAV2((0x15000 + 8)),
		AV_CODEC_ID_MACE3((0x15000 + 9)),
		AV_CODEC_ID_MACE6((0x15000 + 10)),
		AV_CODEC_ID_VMDAUDIO((0x15000 + 11)),
		AV_CODEC_ID_FLAC((0x15000 + 12)),
		AV_CODEC_ID_MP3ADU((0x15000 + 13)),
		AV_CODEC_ID_MP3ON4((0x15000 + 14)),
		AV_CODEC_ID_SHORTEN((0x15000 + 15)),
		AV_CODEC_ID_ALAC((0x15000 + 16)),
		AV_CODEC_ID_WESTWOOD_SND1((0x15000 + 17)),
		/** < as in Berlin toast format */
		AV_CODEC_ID_GSM((0x15000 + 18)),
		AV_CODEC_ID_QDM2((0x15000 + 19)),
		AV_CODEC_ID_COOK((0x15000 + 20)),
		AV_CODEC_ID_TRUESPEECH((0x15000 + 21)),
		AV_CODEC_ID_TTA((0x15000 + 22)),
		AV_CODEC_ID_SMACKAUDIO((0x15000 + 23)),
		AV_CODEC_ID_QCELP((0x15000 + 24)),
		AV_CODEC_ID_WAVPACK((0x15000 + 25)),
		AV_CODEC_ID_DSICINAUDIO((0x15000 + 26)),
		AV_CODEC_ID_IMC((0x15000 + 27)),
		AV_CODEC_ID_MUSEPACK7((0x15000 + 28)),
		AV_CODEC_ID_MLP((0x15000 + 29)),
		/** as found in WAV */
		AV_CODEC_ID_GSM_MS((0x15000 + 30)),
		AV_CODEC_ID_ATRAC3((0x15000 + 31)),
		AV_CODEC_ID_APE((0x15000 + 32)),
		AV_CODEC_ID_NELLYMOSER((0x15000 + 33)),
		AV_CODEC_ID_MUSEPACK8((0x15000 + 34)),
		AV_CODEC_ID_SPEEX((0x15000 + 35)),
		AV_CODEC_ID_WMAVOICE((0x15000 + 36)),
		AV_CODEC_ID_WMAPRO((0x15000 + 37)),
		AV_CODEC_ID_WMALOSSLESS((0x15000 + 38)),
		AV_CODEC_ID_ATRAC3P((0x15000 + 39)),
		AV_CODEC_ID_EAC3((0x15000 + 40)),
		AV_CODEC_ID_SIPR((0x15000 + 41)),
		AV_CODEC_ID_MP1((0x15000 + 42)),
		AV_CODEC_ID_TWINVQ((0x15000 + 43)),
		AV_CODEC_ID_TRUEHD((0x15000 + 44)),
		AV_CODEC_ID_MP4ALS((0x15000 + 45)),
		AV_CODEC_ID_ATRAC1((0x15000 + 46)),
		AV_CODEC_ID_BINKAUDIO_RDFT((0x15000 + 47)),
		AV_CODEC_ID_BINKAUDIO_DCT((0x15000 + 48)),
		AV_CODEC_ID_AAC_LATM((0x15000 + 49)),
		AV_CODEC_ID_QDMC((0x15000 + 50)),
		AV_CODEC_ID_CELT((0x15000 + 51)),
		AV_CODEC_ID_G723_1((0x15000 + 52)),
		AV_CODEC_ID_G729((0x15000 + 53)),
		AV_CODEC_ID_8SVX_EXP((0x15000 + 54)),
		AV_CODEC_ID_8SVX_FIB((0x15000 + 55)),
		AV_CODEC_ID_BMV_AUDIO((0x15000 + 56)),
		AV_CODEC_ID_RALF((0x15000 + 57)),
		AV_CODEC_ID_IAC((0x15000 + 58)),
		AV_CODEC_ID_ILBC((0x15000 + 59)),
		AV_CODEC_ID_OPUS((0x15000 + 60)),
		AV_CODEC_ID_COMFORT_NOISE((0x15000 + 61)),
		AV_CODEC_ID_TAK((0x15000 + 62)),
		AV_CODEC_ID_METASOUND((0x15000 + 63)),
		AV_CODEC_ID_PAF_AUDIO((0x15000 + 64)),
		AV_CODEC_ID_ON2AVC((0x15000 + 65)),
		AV_CODEC_ID_DSS_SP((0x15000 + 66)),
		AV_CODEC_ID_CODEC2((0x15000 + 67)),
		AV_CODEC_ID_FFWAVESYNTH(0x15800),
		AV_CODEC_ID_SONIC((0x15800 + 1)),
		AV_CODEC_ID_SONIC_LS((0x15800 + 2)),
		AV_CODEC_ID_EVRC((0x15800 + 3)),
		AV_CODEC_ID_SMV((0x15800 + 4)),
		AV_CODEC_ID_DSD_LSBF((0x15800 + 5)),
		AV_CODEC_ID_DSD_MSBF((0x15800 + 6)),
		AV_CODEC_ID_DSD_LSBF_PLANAR((0x15800 + 7)),
		AV_CODEC_ID_DSD_MSBF_PLANAR((0x15800 + 8)),
		AV_CODEC_ID_4GV((0x15800 + 9)),
		AV_CODEC_ID_INTERPLAY_ACM((0x15800 + 10)),
		AV_CODEC_ID_XMA1((0x15800 + 11)),
		AV_CODEC_ID_XMA2((0x15800 + 12)),
		AV_CODEC_ID_DST((0x15800 + 13)),
		AV_CODEC_ID_ATRAC3AL((0x15800 + 14)),
		AV_CODEC_ID_ATRAC3PAL((0x15800 + 15)),
		AV_CODEC_ID_DOLBY_E((0x15800 + 16)),
		AV_CODEC_ID_APTX((0x15800 + 17)),
		AV_CODEC_ID_APTX_HD((0x15800 + 18)),
		AV_CODEC_ID_SBC((0x15800 + 19)),
		AV_CODEC_ID_ATRAC9((0x15800 + 20)),
		AV_CODEC_ID_HCOM((0x15800 + 21)),
		AV_CODEC_ID_ACELP_KELVIN((0x15800 + 22)),
		AV_CODEC_ID_MPEGH_3D_AUDIO((0x15800 + 23)),
		AV_CODEC_ID_SIREN((0x15800 + 24)),
		AV_CODEC_ID_HCA((0x15800 + 25)),
		AV_CODEC_ID_FASTAUDIO((0x15800 + 26)),
		/**
		 * subtitle codecs<br>
		 * < A dummy ID pointing at the start of subtitle codecs.
		 */
		AV_CODEC_ID_FIRST_SUBTITLE(0x17000),
		AV_CODEC_ID_DVD_SUBTITLE(0x17000),
		AV_CODEC_ID_DVB_SUBTITLE((0x17000 + 1)),
		/** < raw UTF-8 text */
		AV_CODEC_ID_TEXT((0x17000 + 2)),
		AV_CODEC_ID_XSUB((0x17000 + 3)),
		AV_CODEC_ID_SSA((0x17000 + 4)),
		AV_CODEC_ID_MOV_TEXT((0x17000 + 5)),
		AV_CODEC_ID_HDMV_PGS_SUBTITLE((0x17000 + 6)),
		AV_CODEC_ID_DVB_TELETEXT((0x17000 + 7)),
		AV_CODEC_ID_SRT((0x17000 + 8)),
		AV_CODEC_ID_MICRODVD(0x17800),
		AV_CODEC_ID_EIA_608((0x17800 + 1)),
		AV_CODEC_ID_JACOSUB((0x17800 + 2)),
		AV_CODEC_ID_SAMI((0x17800 + 3)),
		AV_CODEC_ID_REALTEXT((0x17800 + 4)),
		AV_CODEC_ID_STL((0x17800 + 5)),
		AV_CODEC_ID_SUBVIEWER1((0x17800 + 6)),
		AV_CODEC_ID_SUBVIEWER((0x17800 + 7)),
		AV_CODEC_ID_SUBRIP((0x17800 + 8)),
		AV_CODEC_ID_WEBVTT((0x17800 + 9)),
		AV_CODEC_ID_MPL2((0x17800 + 10)),
		AV_CODEC_ID_VPLAYER((0x17800 + 11)),
		AV_CODEC_ID_PJS((0x17800 + 12)),
		AV_CODEC_ID_ASS((0x17800 + 13)),
		AV_CODEC_ID_HDMV_TEXT_SUBTITLE((0x17800 + 14)),
		AV_CODEC_ID_TTML((0x17800 + 15)),
		AV_CODEC_ID_ARIB_CAPTION((0x17800 + 16)),
		/**
		 * other specific kind of codecs (generally used for attachments)<br>
		 * < A dummy ID pointing at the start of various fake codecs.
		 */
		AV_CODEC_ID_FIRST_UNKNOWN(0x18000),
		AV_CODEC_ID_TTF(0x18000),
		/** < Contain timestamp estimated through PCR of program stream. */
		AV_CODEC_ID_SCTE_35((0x18000 + 1)),
		AV_CODEC_ID_EPG((0x18000 + 2)),
		AV_CODEC_ID_BINTEXT(0x18800),
		AV_CODEC_ID_XBIN((0x18800 + 1)),
		AV_CODEC_ID_IDF((0x18800 + 2)),
		AV_CODEC_ID_OTF((0x18800 + 3)),
		AV_CODEC_ID_SMPTE_KLV((0x18800 + 4)),
		AV_CODEC_ID_DVD_NAV((0x18800 + 5)),
		AV_CODEC_ID_TIMED_ID3((0x18800 + 6)),
		AV_CODEC_ID_BIN_DATA((0x18800 + 7)),
		/** < codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it */
		AV_CODEC_ID_PROBE(0x19000),
		/**
		 * < _FAKE_ codec to indicate a raw MPEG-2 TS<br>
		 * stream (only used by libavformat)
		 */
		AV_CODEC_ID_MPEG2TS(0x20000),
		/**
		 * < _FAKE_ codec to indicate a MPEG-4 Systems<br>
		 * stream (only used by libavformat)
		 */
		AV_CODEC_ID_MPEG4SYSTEMS(0x20001),
		/** < Dummy codec for streams containing only metadata information. */
		AV_CODEC_ID_FFMETADATA(0x21000),
		/** < Passthrough codec, AVFrames wrapped in AVPacket */
		AV_CODEC_ID_WRAPPED_AVFRAME(0x21001);
		AVCodecID(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<AVCodecID > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<AVCodecID > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : ./libavcodec/codec_par.h:11</i>
	 */
	public enum AVFieldOrder implements IntValuedEnum<AVFieldOrder > {
		AV_FIELD_UNKNOWN(0),
		AV_FIELD_PROGRESSIVE(1),
		/** < Top coded_first, top displayed first */
		AV_FIELD_TT(2),
		/** < Bottom coded first, bottom displayed first */
		AV_FIELD_BB(3),
		/** < Top coded first, bottom displayed first */
		AV_FIELD_TB(4),
		/** < Bottom coded first, top displayed first */
		AV_FIELD_BT(5);
		AVFieldOrder(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<AVFieldOrder > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<AVFieldOrder > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * @defgroup lavc_packet AVPacket<br>
	 * * Types and functions for working with AVPacket.<br>
	 * @{<br>
	 * enum values<br>
	 * <i>native declaration : ./libavcodec/packet.h:231</i>
	 */
	public enum AVPacketSideDataType implements IntValuedEnum<AVPacketSideDataType > {
		/**
		 * An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE<br>
		 * bytes worth of palette. This side data signals that a new palette is<br>
		 * present.
		 */
		AV_PKT_DATA_PALETTE(0),
		/**
		 * The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format<br>
		 * that the extradata buffer was changed and the receiving side should<br>
		 * act upon it appropriately. The new extradata is embedded in the side<br>
		 * data buffer and should be immediately used for processing the current<br>
		 * frame or packet.
		 */
		AV_PKT_DATA_NEW_EXTRADATA(1),
		/**
		 * An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:<br>
		 * @code<br>
		 * u32le param_flags<br>
		 * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)<br>
		 *     s32le channel_count<br>
		 * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)<br>
		 *     u64le channel_layout<br>
		 * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)<br>
		 *     s32le sample_rate<br>
		 * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)<br>
		 *     s32le width<br>
		 *     s32le height<br>
		 * @endcode
		 */
		AV_PKT_DATA_PARAM_CHANGE(2),
		/**
		 * An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of<br>
		 * structures with info about macroblocks relevant to splitting the<br>
		 * packet into smaller packets on macroblock edges (e.g. as for RFC 2190).<br>
		 * That is, it does not necessarily contain info about all macroblocks,<br>
		 * as long as the distance between macroblocks in the info is smaller<br>
		 * than the target payload size.<br>
		 * Each MB info structure is 12 bytes, and is laid out as follows:<br>
		 * @code<br>
		 * u32le bit offset from the start of the packet<br>
		 * u8    current quantizer at the start of the macroblock<br>
		 * u8    GOB number<br>
		 * u16le macroblock address within the GOB<br>
		 * u8    horizontal MV predictor<br>
		 * u8    vertical MV predictor<br>
		 * u8    horizontal MV predictor for block number 3<br>
		 * u8    vertical MV predictor for block number 3<br>
		 * @endcode
		 */
		AV_PKT_DATA_H263_MB_INFO(3),
		/**
		 * This side data should be associated with an audio stream and contains<br>
		 * ReplayGain information in form of the AVReplayGain struct.
		 */
		AV_PKT_DATA_REPLAYGAIN(4),
		/**
		 * This side data contains a 3x3 transformation matrix describing an affine<br>
		 * transformation that needs to be applied to the decoded video frames for<br>
		 * correct presentation.<br>
		 * * See libavutil/display.h for a detailed description of the data.
		 */
		AV_PKT_DATA_DISPLAYMATRIX(5),
		/**
		 * This side data should be associated with a video stream and contains<br>
		 * Stereoscopic 3D information in form of the AVStereo3D struct.
		 */
		AV_PKT_DATA_STEREO3D(6),
		/**
		 * This side data should be associated with an audio stream and corresponds<br>
		 * to enum AVAudioServiceType.
		 */
		AV_PKT_DATA_AUDIO_SERVICE_TYPE(7),
		/**
		 * This side data contains quality related information from the encoder.<br>
		 * @code<br>
		 * u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).<br>
		 * u8    picture type<br>
		 * u8    error count<br>
		 * u16   reserved<br>
		 * u64le[error count] sum of squared differences between encoder in and output<br>
		 * @endcode
		 */
		AV_PKT_DATA_QUALITY_STATS(8),
		/**
		 * This side data contains an integer value representing the stream index<br>
		 * of a "fallback" track.  A fallback track indicates an alternate<br>
		 * track to use when the current track can not be decoded for some reason.<br>
		 * e.g. no decoder available for codec.
		 */
		AV_PKT_DATA_FALLBACK_TRACK(9),
		/** This side data corresponds to the AVCPBProperties struct. */
		AV_PKT_DATA_CPB_PROPERTIES(10),
		/**
		 * Recommmends skipping the specified number of samples<br>
		 * @code<br>
		 * u32le number of samples to skip from start of this packet<br>
		 * u32le number of samples to skip from end of this packet<br>
		 * u8    reason for start skip<br>
		 * u8    reason for end   skip (0=padding silence, 1=convergence)<br>
		 * @endcode
		 */
		AV_PKT_DATA_SKIP_SAMPLES(11),
		/**
		 * An AV_PKT_DATA_JP_DUALMONO side data packet indicates that<br>
		 * the packet may contain "dual mono" audio specific to Japanese DTV<br>
		 * and if it is true, recommends only the selected channel to be used.<br>
		 * @code<br>
		 * u8    selected channels (0=mail/left, 1=sub/right, 2=both)<br>
		 * @endcode
		 */
		AV_PKT_DATA_JP_DUALMONO(12),
		/**
		 * A list of zero terminated key/value strings. There is no end marker for<br>
		 * the list, so it is required to rely on the side data size to stop.
		 */
		AV_PKT_DATA_STRINGS_METADATA(13),
		/**
		 * Subtitle event position<br>
		 * @code<br>
		 * u32le x1<br>
		 * u32le y1<br>
		 * u32le x2<br>
		 * u32le y2<br>
		 * @endcode
		 */
		AV_PKT_DATA_SUBTITLE_POSITION(14),
		/**
		 * Data found in BlockAdditional element of matroska container. There is<br>
		 * no end marker for the data, so it is required to rely on the side data<br>
		 * size to recognize the end. 8 byte id (as found in BlockAddId) followed<br>
		 * by data.
		 */
		AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL(15),
		/** The optional first identifier line of a WebVTT cue. */
		AV_PKT_DATA_WEBVTT_IDENTIFIER(16),
		/**
		 * The optional settings (rendering instructions) that immediately<br>
		 * follow the timestamp specifier of a WebVTT cue.
		 */
		AV_PKT_DATA_WEBVTT_SETTINGS(17),
		/**
		 * A list of zero terminated key/value strings. There is no end marker for<br>
		 * the list, so it is required to rely on the side data size to stop. This<br>
		 * side data includes updated metadata which appeared in the stream.
		 */
		AV_PKT_DATA_METADATA_UPDATE(18),
		/**
		 * MPEGTS stream ID as uint8_t, this is required to pass the stream ID<br>
		 * information from the demuxer to the corresponding muxer.
		 */
		AV_PKT_DATA_MPEGTS_STREAM_ID(19),
		/**
		 * Mastering display metadata (based on SMPTE-2086:2014). This metadata<br>
		 * should be associated with a video stream and contains data in the form<br>
		 * of the AVMasteringDisplayMetadata struct.
		 */
		AV_PKT_DATA_MASTERING_DISPLAY_METADATA(20),
		/**
		 * This side data should be associated with a video stream and corresponds<br>
		 * to the AVSphericalMapping structure.
		 */
		AV_PKT_DATA_SPHERICAL(21),
		/**
		 * Content light level (based on CTA-861.3). This metadata should be<br>
		 * associated with a video stream and contains data in the form of the<br>
		 * AVContentLightMetadata struct.
		 */
		AV_PKT_DATA_CONTENT_LIGHT_LEVEL(22),
		/**
		 * ATSC A53 Part 4 Closed Captions. This metadata should be associated with<br>
		 * a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.<br>
		 * The number of bytes of CC data is AVPacketSideData.size.
		 */
		AV_PKT_DATA_A53_CC(23),
		/**
		 * This side data is encryption initialization data.<br>
		 * The format is not part of ABI, use av_encryption_init_info_* methods to<br>
		 * access.
		 */
		AV_PKT_DATA_ENCRYPTION_INIT_INFO(24),
		/**
		 * This side data contains encryption info for how to decrypt the packet.<br>
		 * The format is not part of ABI, use av_encryption_info_* methods to access.
		 */
		AV_PKT_DATA_ENCRYPTION_INFO(25),
		/**
		 * Active Format Description data consisting of a single byte as specified<br>
		 * in ETSI TS 101 154 using AVActiveFormatDescription enum.
		 */
		AV_PKT_DATA_AFD(26),
		/**
		 * Producer Reference Time data corresponding to the AVProducerReferenceTime struct,<br>
		 * usually exported by some encoders (on demand through the prft flag set in the<br>
		 * AVCodecContext export_side_data field).
		 */
		AV_PKT_DATA_PRFT(27),
		/**
		 * ICC profile data consisting of an opaque octet buffer following the<br>
		 * format described by ISO 15076-1.
		 */
		AV_PKT_DATA_ICC_PROFILE(28),
		/**
		 * DOVI configuration<br>
		 * ref:<br>
		 * dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2<br>
		 * dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3<br>
		 * Tags are stored in struct AVDOVIDecoderConfigurationRecord.
		 */
		AV_PKT_DATA_DOVI_CONF(29),
		/**
		 * Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4 uint32_t<br>
		 * where the first uint32_t describes how many (1-3) of the other timecodes are used.<br>
		 * The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()<br>
		 * function in libavutil/timecode.h.
		 */
		AV_PKT_DATA_S12M_TIMECODE(30),
		/**
		 * The number of side data types.<br>
		 * This is not part of the public API/ABI in the sense that it may<br>
		 * change when new side data types are added.<br>
		 * This must stay the last enum value.<br>
		 * If its value becomes huge, some code using it<br>
		 * needs to be updated as it assumes it to be smaller than other limits.
		 */
		AV_PKT_DATA_NB(31);
		AVPacketSideDataType(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<AVPacketSideDataType > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<AVPacketSideDataType > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : ./libavcodec/packet.h:315</i>
	 */
	public enum AVSideDataParamChangeFlags implements IntValuedEnum<AVSideDataParamChangeFlags > {
		AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT(0x0001),
		AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT(0x0002),
		AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE(0x0004),
		AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS(0x0008);
		AVSideDataParamChangeFlags(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<AVSideDataParamChangeFlags > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<AVSideDataParamChangeFlags > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * The codec supports this format via the hw_device_ctx interface.<br>
	 * * When selecting this format, AVCodecContext.hw_device_ctx should<br>
	 * have been set to a device of the specified type before calling<br>
	 * avcodec_open2().
	 */
	public static final int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 0x01;
	/**
	 * The codec supports this format via the hw_frames_ctx interface.<br>
	 * * When selecting this format for a decoder,<br>
	 * AVCodecContext.hw_frames_ctx should be set to a suitable frames<br>
	 * context inside the get_format() callback.  The frames context<br>
	 * must have been created on a device of the specified type.<br>
	 * * When selecting this format for an encoder,<br>
	 * AVCodecContext.hw_frames_ctx should be set to the context which<br>
	 * will be used for the input frames before calling avcodec_open2().
	 */
	public static final int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 0x02;
	/**
	 * The codec supports this format by some internal method.<br>
	 * * This format can be selected without any additional configuration -<br>
	 * no device or frames context is required.
	 */
	public static final int AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 0x04;
	/**
	 * The codec supports this format by some ad-hoc method.<br>
	 * * Additional settings and/or function calls are required.  See the<br>
	 * codec-specific documentation for details.  (Methods requiring<br>
	 * this sort of configuration are deprecated and others should be<br>
	 * used in preference.)
	 */
	public static final int AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 0x08;
	/**
	 * @ingroup lavc_decoding<br>
	 * enum values<br>
	 * <i>native declaration : ./libavcodec/avcodec.h:20</i>
	 */
	public enum AVDiscard implements IntValuedEnum<AVDiscard > {
		/**
		 * We leave some space between them for extensions (drop some<br>
		 * keyframes for intra-only or drop just some bidir frames).<br>
		 * < discard nothing
		 */
		AVDISCARD_NONE(-16),
		/** < discard useless packets like 0 size packets in avi */
		AVDISCARD_DEFAULT(0),
		/** < discard all non reference */
		AVDISCARD_NONREF(8),
		/** < discard all bidirectional frames */
		AVDISCARD_BIDIR(16),
		/** < discard all non intra frames */
		AVDISCARD_NONINTRA(24),
		/** < discard all frames except keyframes */
		AVDISCARD_NONKEY(32),
		/** < discard all */
		AVDISCARD_ALL(48);
		AVDiscard(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<AVDiscard > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<AVDiscard > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : ./libavcodec/avcodec.h:33</i>
	 */
	public enum AVAudioServiceType implements IntValuedEnum<AVAudioServiceType > {
		AV_AUDIO_SERVICE_TYPE_MAIN(0),
		AV_AUDIO_SERVICE_TYPE_EFFECTS(1),
		AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED(2),
		AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED(3),
		AV_AUDIO_SERVICE_TYPE_DIALOGUE(4),
		AV_AUDIO_SERVICE_TYPE_COMMENTARY(5),
		AV_AUDIO_SERVICE_TYPE_EMERGENCY(6),
		AV_AUDIO_SERVICE_TYPE_VOICE_OVER(7),
		AV_AUDIO_SERVICE_TYPE_KARAOKE(8),
		/** < Not part of ABI */
		AV_AUDIO_SERVICE_TYPE_NB(9);
		AVAudioServiceType(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<AVAudioServiceType > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<AVAudioServiceType > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1580</i>
	 */
	public enum AVSubtitleType implements IntValuedEnum<AVSubtitleType > {
		SUBTITLE_NONE(0),
		/** < A bitmap, pict will be set */
		SUBTITLE_BITMAP(1),
		/**
		 * Plain text, the text field must be set by the decoder and is<br>
		 * authoritative. ass and pict fields may contain approximations.
		 */
		SUBTITLE_TEXT(2),
		/**
		 * Formatted text, the ass field must be set by the decoder and is<br>
		 * authoritative. pict and text fields may contain approximations.
		 */
		SUBTITLE_ASS(3);
		AVSubtitleType(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<AVSubtitleType > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<AVSubtitleType > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2047</i>
	 */
	public enum AVPictureStructure implements IntValuedEnum<AVPictureStructure > {
		/** < unknown */
		AV_PICTURE_STRUCTURE_UNKNOWN(0),
		/** < coded as top field */
		AV_PICTURE_STRUCTURE_TOP_FIELD(1),
		/** < coded as bottom field */
		AV_PICTURE_STRUCTURE_BOTTOM_FIELD(2),
		/** < coded as frame */
		AV_PICTURE_STRUCTURE_FRAME(3);
		AVPictureStructure(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<AVPictureStructure > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<AVPictureStructure > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * Lock operation used by lockmgr<br>
	 * * @deprecated Deprecated together with av_lockmgr_register().<br>
	 * enum values<br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2455</i>
	 */
	public enum AVLockOp implements IntValuedEnum<AVLockOp > {
		/** < Create a mutex */
		AV_LOCK_CREATE(0),
		/** < Lock the mutex */
		AV_LOCK_OBTAIN(1),
		/** < Unlock the mutex */
		AV_LOCK_RELEASE(2),
		/** < Free mutex resources */
		AV_LOCK_DESTROY(3);
		AVLockOp(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<AVLockOp > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<AVLockOp > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil/rational.h:0</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_PRORES_STANDARD = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_CONSTRAINED_BASELINE = (int)(66 | (1 << 9));
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_EXPORT_DATA_MVS = (int)(1 << 0);
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_ENCODER_FLUSH = (int)(1 << 21);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VVC_MAIN_10 = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_DROPCHANGED = (int)(1 << 5);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_HYBRID = (int)8;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_EF_IGNORE_ERR = (int)(1 << 15);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PRED_MEDIAN = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DCT_FASTINT = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLE = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_LOOP_FILTER = (int)(1 << 11);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_NORMAL = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_SKIP = (int)0x00000080;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_OUTPUT_CORRUPT = (int)(1 << 3);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_PRIVATE_OPT = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_NO_PADDING = (int)16;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE = (int)(1 << 20);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_UNOFFICIAL = (int)-1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_SSR = (int)2;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_OLD_ENCDEC = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_AVPRIV_PUT_BITS = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VVC_MAIN_10_444 = (int)33;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = (int)(1 << 1);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_AC_PRED = (int)(1 << 24);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_SSE = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_MB_TYPE = (int)8;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_STAT_BITS = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS = (int)1;
	/** <i>native declaration : ./libavcodec/packet.h</i> */
	public static final int AV_PKT_FLAG_DISPOSABLE = (int)0x0010;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final int LIBAVCODEC_VERSION_MINOR = (int)134;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MV_P_FOR = (int)0x00000001;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_PASS2 = (int)(1 << 10);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_PASS1 = (int)(1 << 9);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_CONSTRAINED = (int)(1 << 9);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_EF_CAREFUL = (int)(1 << 16);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_EC_FAVOR_INTER = (int)256;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_USER_VISIBLE_AVHWACCEL = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_BIT = (int)5;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH = (int)(1 << 2);
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_DELAY = (int)(1 << 5);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_DCT264 = (int)14;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_4MV = (int)(1 << 2);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final int LIBAVCODEC_BUILD = (int)((58) << 16 | (134) << 8 | (100));
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS_EXPRESS = (int)70;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_AVCODEC_PIX_FMT = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_EF_AGGRESSIVE = (int)(1 << 18);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_PARSER_PTS_NB = (int)4;
	/** <i>native declaration : ./libavcodec/codec_desc.h</i> */
	public static final int AV_CODEC_PROP_LOSSY = (int)(1 << 1);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_CODER_TYPE = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_IEDGE = (int)32768;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_SAD = (int)0;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_FRAME_THREADS = (int)(1 << 12);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = (int)13;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_LEVEL_UNKNOWN = (int)-99;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = (int)7;
	/** <i>native declaration : ./libavcodec/packet.h</i> */
	public static final int AV_PKT_FLAG_CORRUPT = (int)0x0002;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_SIMPLE = (int)5;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int SLICE_FLAG_ALLOW_PLANE = (int)0x0004;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CODER_TYPE_AC = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_AUTODETECT = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_THREAD_SLICE = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = (int)0x0200;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_AUTO_THREADS = (int)(1 << 15);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_SS = (int)2;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_OPENH264_SLICE_MODE = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_PSNR = (int)4;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_HE = (int)4;
	/** <i>native declaration : ./libavcodec/codec_desc.h</i> */
	public static final int AV_CODEC_PROP_TEXT_SUB = (int)(1 << 17);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = (int)6;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_UNKNOWN = (int)-99;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_TRUNCATED = (int)(1 << 16);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_INIT_PACKET = (boolean)(58 < 60);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_NO_OUTPUT = (int)(1 << 2);
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_SUBFRAMES = (int)(1 << 8);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_10 = (int)110;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_BITEXACT = (int)(1 << 23);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS_HD_HRA = (int)50;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH = (int)100;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_DEBUG_MV = (boolean)(58 < 60);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_LD = (int)22;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_CLOSED_GOP = (int)(1 << 31);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_PSNR = (int)(1 << 15);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_CORE = (int)2;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_CONVERGENCE_DURATION = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_PARAM_CHANGE = (int)(1 << 14);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_MERGE_SD_API = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_EXPORT_DATA_FILM_GRAIN = (int)(1 << 3);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_VERY_STRICT = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int PARSER_FLAG_COMPLETE_FRAMES = (int)0x0001;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AV1_HIGH = (int)1;
	/**
	 * define<br>
	 * Conversion Error : 58.134.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : ./libavcodec/version.h:0</i><br>
	 * 58.134.
	 */
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_UMP4 = (int)8;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_MAIN = (int)4;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEAUTO = (int)128;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_CODEC_GET_SET = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DCT_ALTIVEC = (int)5;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_DCTMAX = (int)13;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_MMCO = (int)0x00000800;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int SLICE_FLAG_ALLOW_FIELD = (int)0x0002;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_AUTO_THREADS = (boolean)(58 < 60);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_ARM = (int)7;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEARMV5TE = (int)16;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_ELD = (int)38;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_SLICE_THREADS = (int)(1 << 13);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_PRORES_4444 = (int)4;
	/** <i>native declaration : ./libavcodec/packet.h</i> */
	public static final int AV_PKT_FLAG_DISCARD = (int)0x0004;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_EXPERIMENTAL = (int)-2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CODER_TYPE_RAW = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_XVID = (int)14;
	/** <i>native declaration : ./libavcodec/codec_desc.h</i> */
	public static final int AV_CODEC_PROP_BITMAP_SUB = (int)(1 << 16);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_STD_QPEL = (int)128;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DCT_FAAN = (int)6;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS = (int)(1 << 2);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_CHROMA = (int)256;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_BITSTREAM = (int)4;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_XVID_ILACE = (int)4;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_RD = (int)6;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CODER_TYPE_VLC = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VC1_COMPLEX = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MJPEG_JPEG_LS = (int)0xf7;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_FAAN = (int)20;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_HEVC_MAIN = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_EC_GUESS_MVS = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_FAST = (int)(1 << 0);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_422_INTRA = (int)(122 | (1 << 11));
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VC1_SIMPLE = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MV_B_BACK = (int)0x00000004;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_LOCAL_HEADER = (int)(1 << 3);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_QPEL_CHROMA2 = (int)256;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_EXPORT_MVS = (int)(1 << 28);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_EF_BITSTREAM = (int)(1 << 1);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_RC = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_BASELINE = (int)66;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_SUB_TEXT_FMT_ASS = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_QP = (int)16;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_COMPRESSION_DEFAULT = (int)-1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SCALABLE_TEXTURE = (int)5;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_COPY_CONTEXT = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT = (int)0xc2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_SQ = (int)2;
	/** <i>native declaration : ./libavcodec/codec_desc.h</i> */
	public static final int AV_CODEC_PROP_INTRA_ONLY = (int)(1 << 0);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CODER_TYPE_RLE = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS = (int)0xc3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_DCINEMA_2K = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_SUB_CHARENC_MODE_AUTOMATIC = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int PARSER_FLAG_USE_CODEC_TS = (int)0x1000;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_OTHER_THREADS = (int)(1 << 15);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_LB = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_DCINEMA_4K = (int)4;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_LOCKMGR = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_EXTENDED = (int)88;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEARM = (int)10;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_INT = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_HQ = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_444 = (int)144;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_GRAY = (int)(1 << 13);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_422 = (int)122;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DCT_INT = (int)2;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_DR1 = (int)(1 << 1);
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_DRAW_HORIZ_BAND = (int)(1 << 0);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_HPEL_CHROMA = (int)2048;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_EXPERIMENTAL = (int)(1 << 9);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final int LIBAVCODEC_VERSION_MICRO = (int)100;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_NONE = (int)24;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_NEXT = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/packet.h</i> */
	public static final int AV_PKT_FLAG_KEY = (int)0x0001;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_THREAD_FRAME = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_SUB_CHARENC_MODE_PRE_DECODER = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT = (int)0xc0;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_HYBRID = (int)(1 << 19);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_SNR_SCALABLE = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_THREADS = (int)0x00010000;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DCT_MMX = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DNXHD = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_CHUNKS = (int)(1 << 15);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLENEON = (int)22;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_SUB_CHARENC_MODE_DO_NOTHING = (int)-1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS = (int)20;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CODEC_PROPERTY_LOSSLESS = (int)0x00000001;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_INTRA = (int)(1 << 11);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_CODING = (int)11;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_GET_FRAME_CLASS = (boolean)(58 < 60);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_ER = (int)0x00000400;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = (int)0xc1;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_VDPAU_PROFILE = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_STRICT = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_PICT_INFO = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_MB_DECISION_RD = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_AAC_LOW = (int)128;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_AAC_HE = (int)131;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_HQX = (int)4;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_EF_COMPLIANT = (int)(1 << 17);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_OPENH264_CABAC = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PRED_LEFT = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_INTERLACED_DCT = (int)(1 << 18);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DNXHR_444 = (int)5;
	/** <i>native declaration : ./libavcodec/codec_desc.h</i> */
	public static final int AV_CODEC_PROP_REORDER = (int)(1 << 3);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_AVPICTURE = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VP9_0 = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VP9_2 = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VP9_1 = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VP9_3 = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_DC_CLIP = (int)4096;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_SATD = (int)2;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_NVENC_OLD_NAME = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_MAIN = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEMMX = (int)3;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final int LIBAVCODEC_VERSION_INT = (int)((58) << 16 | (134) << 8 | (100));
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_TRUNCATED = (int)(1 << 3);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_INTERLACED_ME = (int)(1 << 29);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_ALTIVEC = (int)8;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_MAIN = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_422 = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_NOMC = (int)0x01000000;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_SIDEDATA_ONLY_PKT = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_DCT_COEFF = (int)0x00000040;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_QSCALE = (int)(1 << 1);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_DROP_FRAME_TIMECODE = (int)(1 << 13);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_UNALIGNED = (int)(1 << 0);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_VSSE = (int)9;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_GREEN_MD = (int)0x00800000;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_DCT = (int)3;
	/** <i>native declaration : ./libavcodec/packet.h</i> */
	public static final int AV_PKT_FLAG_TRUSTED = (int)0x0008;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEARMV6 = (int)17;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MV_B_FOR = (int)0x00000002;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_SMALL_LAST_FRAME = (int)(1 << 6);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_KLVA_SYNC = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_RESERVED = (int)-100;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_AVOID_PROBING = (int)(1 << 17);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_TRUNCATED = (int)16384;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_UNSANITIZED_BITRATES = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_EF_CRCCHECK = (int)(1 << 0);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_STEREO_HIGH = (int)128;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_BUGS = (int)0x00001000;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_UNUSED_CODEC_CAPS = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_CORE = (int)12;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_VBV_DELAY = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_PRORES_PROXY = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_EXPORT_DATA_PRFT = (int)(1 << 1);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_LOW_DELAY = (int)(1 << 19);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CODEC_PROPERTY_CLOSED_CAPTIONS = (int)0x00000002;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_RO_FLUSH_NOOP = (int)(1 << 30);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_HE_V2 = (int)28;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_GET_CONTEXT_DEFAULTS = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AV1_PROFESSIONAL = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int SLICE_FLAG_CODED_ORDER = (int)0x0001;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DCT_AUTO = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_MAIN = (int)77;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_MB_DECISION_SIMPLE = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_KLVA_ASYNC = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_QPEL_CHROMA = (int)64;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_STARTCODE = (int)0x00000100;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_QPEL = (int)(1 << 4);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_VSAD = (int)8;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_HWACCEL_FLAG_IGNORE_LEVEL = (int)(1 << 0);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_EF_EXPLODE = (int)(1 << 3);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_SUBTITLE_FLAG_FORCED = (int)0x00000001;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PRED_PLANE = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_INPUT_BUFFER_MIN_SIZE = (int)16384;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS_ES = (int)30;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE_STUDIO = (int)14;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int PARSER_FLAG_FETCHED_OFFSET = (int)0x0004;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AV1_MAIN = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_SHOW_ALL = (int)(1 << 22);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_AVCTX_TIMEBASE = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS_96_24 = (int)40;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_W97 = (int)12;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_CAVLC_444 = (int)44;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_444_PREDICTIVE = (int)244;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_HIGH = (int)1;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_AVPACKET_OLD_API = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_MPV_RC_STRATEGY = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_PRORES_XQ = (int)5;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_RTP_CALLBACK = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_W53 = (int)11;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_DIRECT_BLOCKSIZE = (int)512;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_PARSER_CHANGE = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_STRUCT_VAAPI_CONTEXT = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_CODED_FRAME = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_CHANNEL_CONF = (int)(1 << 10);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_ZERO = (int)7;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_MEDIAN_SAD = (int)15;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_SBC_MSBC = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_CMP_NSSE = (int)10;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_ASS_TIMING = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_MULTIVIEW_HIGH = (int)118;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_VARIABLE_FRAME_SIZE = (int)(1 << 16);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_AUTO = (int)0;
	/** <i>native declaration : ./libavcodec/codec_desc.h</i> */
	public static final int AV_CODEC_PROP_LOSSLESS = (int)(1 << 2);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_LTP = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_SKIP_MANUAL = (int)(1 << 29);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_SUB_CHARENC_MODE_IGNORE = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_MB_DECISION_BITS = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_EDGE = (int)1024;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_INPUT_BUFFER_PADDING_SIZE = (int)64;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_N_BIT = (int)4;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_HEVC_MAIN_STILL_PICTURE = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_PRORES_HQ = (int)3;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int PARSER_FLAG_ONCE = (int)0x0002;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VC1_ADVANCED = (int)3;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_OLD_BSF = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_10_INTRA = (int)(110 | (1 << 11));
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_THREAD_SAFE_CALLBACKS = (boolean)(58 < 60);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_BUFFERS = (int)0x00008000;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_PRORES_LT = (int)1;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_GETCHROMA = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_MS = (int)8192;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_EC_DEBLOCK = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_EF_BUFFER = (int)(1 << 2);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_HEVC_REXT = (int)4;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_BUG_AMV = (int)32;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_HEVC_MAIN_10 = (int)2;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE_SCALABLE = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG2_IGNORE_CROP = (int)(1 << 16);
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_INTRA_ONLY = (int)0x40000000;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_SIMPLE = (int)15;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = (int)9;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final String LIBAVCODEC_IDENT = (String)"Lavc58.134.100";
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS_HD_MA = (int)60;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_444_INTRA = (int)(244 | (1 << 11));
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_CORE_SCALABLE = (int)10;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = (int)32768;
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final boolean FF_API_TAG_STRING = (boolean)(58 < 59);
	/** <i>native declaration : ./libavcodec/version.h</i> */
	public static final int LIBAVCODEC_VERSION_MAJOR = (int)58;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_ARIB_PROFILE_A = (int)0;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_ARIB_PROFILE_C = (int)1;
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_LOSSLESS = (int)0x80000000;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_GET_ENCODE_BUFFER_FLAG_REF = (int)(1 << 0);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_LOW = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_GET_BUFFER_FLAG_REF = (int)(1 << 0);
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VC1_MAIN = (int)1;
	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
	public static final int AV_CODEC_FLAG_GLOBAL_HEADER = (int)(1 << 22);
	/** <i>native declaration : ./libavcodec/codec.h</i> */
	public static final int AV_CODEC_CAP_HARDWARE = (int)(1 << 18);
	/** <i>native declaration : ./libavcodec/avcodec.h:2527</i> */
	public static abstract class avcodec_default_execute_func_callback extends Callback<avcodec_default_execute_func_callback > {
		public int apply(Pointer<AVCodecContext > c2, Pointer<? > arg2) {
			return apply(Pointer.getPeer(c2), Pointer.getPeer(arg2));
		}
		public int apply(@Ptr long c2, @Ptr long arg2) {
			return apply(Pointer.pointerToAddress(c2, AVCodecContext.class), Pointer.pointerToAddress(arg2));
		}
	};
	/** <i>native declaration : ./libavcodec/avcodec.h:2528</i> */
	public static abstract class avcodec_default_execute2_func_callback extends Callback<avcodec_default_execute2_func_callback > {
		public int apply(Pointer<AVCodecContext > c2, Pointer<? > arg2, int int1, int int2) {
			return apply(Pointer.getPeer(c2), Pointer.getPeer(arg2), int1, int2);
		}
		public int apply(@Ptr long c2, @Ptr long arg2, int int1, int int2) {
			return apply(Pointer.pointerToAddress(c2, AVCodecContext.class), Pointer.pointerToAddress(arg2), int1, int2);
		}
	};
	/**
	 * Get the type of the given codec.<br>
	 * Original signature : <code>AVMediaType avcodec_get_type(AVCodecID)</code><br>
	 * <i>native declaration : ./libavcodec/codec_id.h:536</i>
	 */
	public static IntValuedEnum<AVMediaType > avcodec_get_type(IntValuedEnum<AvcodecLibrary.AVCodecID > codec_id) {
		return FlagSet.fromValue(avcodec_get_type((int)codec_id.value()), AVMediaType.class);
	}
	protected native static int avcodec_get_type(int codec_id);
	/**
	 * Get the name of a codec.<br>
	 * @return  a static string identifying the codec; never NULL<br>
	 * Original signature : <code>char* avcodec_get_name(AVCodecID)</code><br>
	 * <i>native declaration : ./libavcodec/codec_id.h:542</i>
	 */
	public static Pointer<Byte > avcodec_get_name(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
		return Pointer.pointerToAddress(avcodec_get_name((int)id.value()), Byte.class);
	}
	@Ptr 
	protected native static long avcodec_get_name(int id);
	/**
	 * Allocate a new AVCodecParameters and set its fields to default values<br>
	 * (unknown/invalid/0). The returned struct must be freed with<br>
	 * avcodec_parameters_free().<br>
	 * Original signature : <code>AVCodecParameters* avcodec_parameters_alloc()</code><br>
	 * <i>native declaration : ./libavcodec/codec_par.h:143</i>
	 */
	public static Pointer<AVCodecParameters > avcodec__parameters_alloc() {
		return Pointer.pointerToAddress(avcodec_parameters_alloc(), AVCodecParameters.class);
	}
	@Ptr 
	protected native static long avcodec_parameters_alloc();
	/**
	 * Free an AVCodecParameters instance and everything associated with it and<br>
	 * write NULL to the supplied pointer.<br>
	 * Original signature : <code>void avcodec_parameters_free(AVCodecParameters**)</code><br>
	 * <i>native declaration : ./libavcodec/codec_par.h:149</i>
	 */
	public static void avcodec_parameters_free(Pointer<Pointer<AVCodecParameters > > par) {
		avcodec_parameters_free(Pointer.getPeer(par));
	}
	protected native static void avcodec_parameters_free(@Ptr long par);
	/**
	 * Copy the contents of src to dst. Any allocated fields in dst are freed and<br>
	 * replaced with newly allocated duplicates of the corresponding fields in src.<br>
	 * * @return >= 0 on success, a negative AVERROR code on failure.<br>
	 * Original signature : <code>int avcodec_parameters_copy(AVCodecParameters*, const AVCodecParameters*)</code><br>
	 * <i>native declaration : ./libavcodec/codec_par.h:156</i>
	 */
	public static int avcodec_parameters_copy(Pointer<AVCodecParameters > dst, Pointer<AVCodecParameters > src) {
		return avcodec_parameters_copy(Pointer.getPeer(dst), Pointer.getPeer(src));
	}
	protected native static int avcodec_parameters_copy(@Ptr long dst, @Ptr long src);
	/**
	 * Allocate an AVPacket and set its fields to default values.  The resulting<br>
	 * struct must be freed using av_packet_free().<br>
	 * * @return An AVPacket filled with default values or NULL on failure.<br>
	 * * @note this only allocates the AVPacket itself, not the data buffers. Those<br>
	 * must be allocated through other means such as av_new_packet.<br>
	 * * @see av_new_packet<br>
	 * Original signature : <code>AVPacket* av_packet_alloc()</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:325</i>
	 */
	public static Pointer<AVPacket > av_packet__alloc() {
		return Pointer.pointerToAddress(av_packet_alloc(), AVPacket.class);
	}
	@Ptr 
	protected native static long av_packet_alloc();
	/**
	 * Create a new packet that references the same data as src.<br>
	 * * This is a shortcut for av_packet_alloc()+av_packet_ref().<br>
	 * * @return newly created AVPacket on success, NULL on error.<br>
	 * * @see av_packet_alloc<br>
	 * @see av_packet_ref<br>
	 * Original signature : <code>AVPacket* av_packet_clone(const AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:334</i>
	 */
	public static Pointer<AVPacket > av_packet_clone(Pointer<AVPacket > src) {
		return Pointer.pointerToAddress(av_packet_clone(Pointer.getPeer(src)), AVPacket.class);
	}
	@Ptr 
	protected native static long av_packet_clone(@Ptr long src);
	/**
	 * Free the packet, if the packet is reference counted, it will be<br>
	 * unreferenced first.<br>
	 * * @param pkt packet to be freed. The pointer will be set to NULL.<br>
	 * @note passing NULL is a no-op.<br>
	 * Original signature : <code>void av_packet_free(AVPacket**)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:342</i>
	 */
	public static void av_packet_free(Pointer<Pointer<AVPacket > > pkt) {
		av_packet_free(Pointer.getPeer(pkt));
	}
	protected native static void av_packet_free(@Ptr long pkt);
	/**
	 * Original signature : <code>void av_init_packet(AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:344</i>
	 */
	public static void av_init_packet(Pointer<AVPacket > pkt) {
		av_init_packet(Pointer.getPeer(pkt));
	}
	protected native static void av_init_packet(@Ptr long pkt);
	/**
	 * Allocate the payload of a packet and initialize its fields with<br>
	 * default values.<br>
	 * * @param pkt packet<br>
	 * @param size wanted payload size<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * Original signature : <code>int av_new_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:353</i>
	 */
	public static int av_new_packet(Pointer<AVPacket > pkt, int size) {
		return av_new_packet(Pointer.getPeer(pkt), size);
	}
	protected native static int av_new_packet(@Ptr long pkt, int size);
	/**
	 * Reduce packet size, correctly zeroing padding<br>
	 * * @param pkt packet<br>
	 * @param size new size<br>
	 * Original signature : <code>void av_shrink_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:360</i>
	 */
	public static void av_shrink_packet(Pointer<AVPacket > pkt, int size) {
		av_shrink_packet(Pointer.getPeer(pkt), size);
	}
	protected native static void av_shrink_packet(@Ptr long pkt, int size);
	/**
	 * Increase packet size, correctly zeroing padding<br>
	 * * @param pkt packet<br>
	 * @param grow_by number of bytes by which to increase the size of the packet<br>
	 * Original signature : <code>int av_grow_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:367</i>
	 */
	public static int av_grow_packet(Pointer<AVPacket > pkt, int grow_by) {
		return av_grow_packet(Pointer.getPeer(pkt), grow_by);
	}
	protected native static int av_grow_packet(@Ptr long pkt, int grow_by);
	/**
	 * Initialize a reference-counted packet from av_malloc()ed data.<br>
	 * * @param pkt packet to be initialized. This function will set the data, size,<br>
	 *        and buf fields, all others are left untouched.<br>
	 * @param data Data allocated by av_malloc() to be used as packet data. If this<br>
	 *        function returns successfully, the data is owned by the underlying AVBuffer.<br>
	 *        The caller may not access the data through other means.<br>
	 * @param size size of data in bytes, without the padding. I.e. the full buffer<br>
	 *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.<br>
	 * * @return 0 on success, a negative AVERROR on error<br>
	 * Original signature : <code>int av_packet_from_data(AVPacket*, uint8_t*, int)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:380</i>
	 */
	public static int av_packet_from_data(Pointer<AVPacket > pkt, Pointer<Byte > data, int size) {
		return av_packet_from_data(Pointer.getPeer(pkt), Pointer.getPeer(data), size);
	}
	protected native static int av_packet_from_data(@Ptr long pkt, @Ptr long data, int size);
	/**
	 * Original signature : <code>int av_dup_packet(AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:382</i>
	 */
	public static int av_dup_packet(Pointer<AVPacket > pkt) {
		return av_dup_packet(Pointer.getPeer(pkt));
	}
	protected native static int av_dup_packet(@Ptr long pkt);
	/**
	 * Original signature : <code>int av_copy_packet(AVPacket*, const AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:384</i>
	 */
	public static int av_copy_packet(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
		return av_copy_packet(Pointer.getPeer(dst), Pointer.getPeer(src));
	}
	protected native static int av_copy_packet(@Ptr long dst, @Ptr long src);
	/**
	 * Original signature : <code>int av_copy_packet_side_data(AVPacket*, const AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:386</i>
	 */
	public static int av_copy_packet_side_data(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
		return av_copy_packet_side_data(Pointer.getPeer(dst), Pointer.getPeer(src));
	}
	protected native static int av_copy_packet_side_data(@Ptr long dst, @Ptr long src);
	/**
	 * Original signature : <code>void av_free_packet(AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:388</i>
	 */
	public static void av_free_packet(Pointer<AVPacket > pkt) {
		av_free_packet(Pointer.getPeer(pkt));
	}
	protected native static void av_free_packet(@Ptr long pkt);
	/**
	 * Allocate new information of a packet.<br>
	 * * @param pkt packet<br>
	 * @param type side information type<br>
	 * @param size side information size<br>
	 * @return pointer to fresh allocated data or NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_new_side_data(AVPacket*, AVPacketSideDataType, int)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:397</i>
	 */
	public static Pointer<Byte > av_packet_new_side_data(Pointer<AVPacket > pkt, IntValuedEnum<AvcodecLibrary.AVPacketSideDataType > type, int size) {
		return Pointer.pointerToAddress(av_packet_new_side_data(Pointer.getPeer(pkt), (int)type.value(), size), Byte.class);
	}
	@Ptr 
	protected native static long av_packet_new_side_data(@Ptr long pkt, int type, int size);
	/**
	 * Wrap an existing array as a packet side data.<br>
	 * * @param pkt packet<br>
	 * @param type side information type<br>
	 * @param data the side data array. It must be allocated with the av_malloc()<br>
	 *             family of functions. The ownership of the data is transferred to<br>
	 *             pkt.<br>
	 * @param size side information size<br>
	 * @return a non-negative number on success, a negative AVERROR code on<br>
	 *         failure. On failure, the packet is unchanged and the data remains<br>
	 *         owned by the caller.<br>
	 * Original signature : <code>int av_packet_add_side_data(AVPacket*, AVPacketSideDataType, uint8_t*, size_t)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:411</i>
	 */
	public static int av_packet_add_side_data(Pointer<AVPacket > pkt, IntValuedEnum<AvcodecLibrary.AVPacketSideDataType > type, Pointer<Byte > data, @Ptr long size) {
		return av_packet_add_side_data(Pointer.getPeer(pkt), (int)type.value(), Pointer.getPeer(data), size);
	}
	protected native static int av_packet_add_side_data(@Ptr long pkt, int type, @Ptr long data, @Ptr long size);
	/**
	 * Shrink the already allocated side data buffer<br>
	 * * @param pkt packet<br>
	 * @param type side information type<br>
	 * @param size new side information size<br>
	 * @return 0 on success, < 0 on failure<br>
	 * Original signature : <code>int av_packet_shrink_side_data(AVPacket*, AVPacketSideDataType, int)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:420</i>
	 */
	public static int av_packet_shrink_side_data(Pointer<AVPacket > pkt, IntValuedEnum<AvcodecLibrary.AVPacketSideDataType > type, int size) {
		return av_packet_shrink_side_data(Pointer.getPeer(pkt), (int)type.value(), size);
	}
	protected native static int av_packet_shrink_side_data(@Ptr long pkt, int type, int size);
	/**
	 * Get side information from packet.<br>
	 * * @param pkt packet<br>
	 * @param type desired side information type<br>
	 * @param size If supplied, *size will be set to the size of the side data<br>
	 *             or to zero if the desired side data is not present.<br>
	 * @return pointer to data if present or NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_get_side_data(const AVPacket*, AVPacketSideDataType, int*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:430</i>
	 */
	public static Pointer<Byte > av_packet_get_side_data(Pointer<AVPacket > pkt, IntValuedEnum<AvcodecLibrary.AVPacketSideDataType > type, Pointer<Integer > size) {
		return Pointer.pointerToAddress(av_packet_get_side_data(Pointer.getPeer(pkt), (int)type.value(), Pointer.getPeer(size)), Byte.class);
	}
	@Ptr 
	protected native static long av_packet_get_side_data(@Ptr long pkt, int type, @Ptr long size);
	/**
	 * Original signature : <code>int av_packet_merge_side_data(AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:432</i>
	 */
	public static int av_packet_merge_side_data(Pointer<AVPacket > pkt) {
		return av_packet_merge_side_data(Pointer.getPeer(pkt));
	}
	protected native static int av_packet_merge_side_data(@Ptr long pkt);
	/**
	 * Original signature : <code>int av_packet_split_side_data(AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:434</i>
	 */
	public static int av_packet_split_side_data(Pointer<AVPacket > pkt) {
		return av_packet_split_side_data(Pointer.getPeer(pkt));
	}
	protected native static int av_packet_split_side_data(@Ptr long pkt);
	/**
	 * Original signature : <code>char* av_packet_side_data_name(AVPacketSideDataType)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:436</i>
	 */
	public static Pointer<Byte > av_packet_side_data_name(IntValuedEnum<AvcodecLibrary.AVPacketSideDataType > type) {
		return Pointer.pointerToAddress(av_packet_side_data_name((int)type.value()), Byte.class);
	}
	@Ptr 
	protected native static long av_packet_side_data_name(int type);
	/**
	 * Original signature : <code>uint8_t* av_packet_pack_dictionary(AVDictionary*, int*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:438</i>
	 */
	public static Pointer<Byte > av_packet_pack_dictionary(Pointer<AVDictionary > dict, Pointer<Integer > size) {
		return Pointer.pointerToAddress(av_packet_pack_dictionary(Pointer.getPeer(dict), Pointer.getPeer(size)), Byte.class);
	}
	@Ptr 
	protected native static long av_packet_pack_dictionary(@Ptr long dict, @Ptr long size);
	/**
	 * Original signature : <code>int av_packet_unpack_dictionary(const uint8_t*, int, AVDictionary**)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:440</i>
	 */
	public static int av_packet_unpack_dictionary(Pointer<Byte > data, int size, Pointer<Pointer<AVDictionary > > dict) {
		return av_packet_unpack_dictionary(Pointer.getPeer(data), size, Pointer.getPeer(dict));
	}
	protected native static int av_packet_unpack_dictionary(@Ptr long data, int size, @Ptr long dict);
	/**
	 * Convenience function to free all the side data stored.<br>
	 * All the other fields stay untouched.<br>
	 * * @param pkt packet<br>
	 * Original signature : <code>void av_packet_free_side_data(AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:447</i>
	 */
	public static void av_packet_free_side_data(Pointer<AVPacket > pkt) {
		av_packet_free_side_data(Pointer.getPeer(pkt));
	}
	protected native static void av_packet_free_side_data(@Ptr long pkt);
	/**
	 * Setup a new reference to the data described by a given packet<br>
	 * * If src is reference-counted, setup dst as a new reference to the<br>
	 * buffer in src. Otherwise allocate a new buffer in dst and copy the<br>
	 * data from src into it.<br>
	 * * All the other fields are copied from src.<br>
	 * * @see av_packet_unref<br>
	 * * @param dst Destination packet. Will be completely overwritten.<br>
	 * @param src Source packet<br>
	 * * @return 0 on success, a negative AVERROR on error. On error, dst<br>
	 *         will be blank (as if returned by av_packet_alloc()).<br>
	 * Original signature : <code>int av_packet_ref(AVPacket*, const AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:461</i>
	 */
	public static int av_packet_ref(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
		return av_packet_ref(Pointer.getPeer(dst), Pointer.getPeer(src));
	}
	protected native static int av_packet_ref(@Ptr long dst, @Ptr long src);
	/**
	 * Wipe the packet.<br>
	 * * Unreference the buffer referenced by the packet and reset the<br>
	 * remaining packet fields to their default values.<br>
	 * * @param pkt The packet to be unreferenced.<br>
	 * Original signature : <code>void av_packet_unref(AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:469</i>
	 */
	public static void av_packet_unref(Pointer<AVPacket > pkt) {
		av_packet_unref(Pointer.getPeer(pkt));
	}
	protected native static void av_packet_unref(@Ptr long pkt);
	/**
	 * Move every field in src to dst and reset src.<br>
	 * * @see av_packet_unref<br>
	 * * @param src Source packet, will be reset<br>
	 * @param dst Destination packet<br>
	 * Original signature : <code>void av_packet_move_ref(AVPacket*, AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:477</i>
	 */
	public static void av_packet_move_ref(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
		av_packet_move_ref(Pointer.getPeer(dst), Pointer.getPeer(src));
	}
	protected native static void av_packet_move_ref(@Ptr long dst, @Ptr long src);
	/**
	 * Copy only "properties" fields from src to dst.<br>
	 * * Properties for the purpose of this function are all the fields<br>
	 * beside those related to the packet data (buf, data, size)<br>
	 * * @param dst Destination packet<br>
	 * @param src Source packet<br>
	 * * @return 0 on success AVERROR on failure.<br>
	 * Original signature : <code>int av_packet_copy_props(AVPacket*, const AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:487</i>
	 */
	public static int av_packet_copy_props(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
		return av_packet_copy_props(Pointer.getPeer(dst), Pointer.getPeer(src));
	}
	protected native static int av_packet_copy_props(@Ptr long dst, @Ptr long src);
	/**
	 * Ensure the data described by a given packet is reference counted.<br>
	 * * @note This function does not ensure that the reference will be writable.<br>
	 *       Use av_packet_make_writable instead for that purpose.<br>
	 * * @see av_packet_ref<br>
	 * @see av_packet_make_writable<br>
	 * * @param pkt packet whose data should be made reference counted.<br>
	 * * @return 0 on success, a negative AVERROR on error. On failure, the<br>
	 *         packet is unchanged.<br>
	 * Original signature : <code>int av_packet_make_refcounted(AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:499</i>
	 */
	public static int av_packet_make_refcounted(Pointer<AVPacket > pkt) {
		return av_packet_make_refcounted(Pointer.getPeer(pkt));
	}
	protected native static int av_packet_make_refcounted(@Ptr long pkt);
	/**
	 * Create a writable reference for the data described by a given packet,<br>
	 * avoiding data copy if possible.<br>
	 * * @param pkt Packet whose data should be made writable.<br>
	 * * @return 0 on success, a negative AVERROR on failure. On failure, the<br>
	 *         packet is unchanged.<br>
	 * Original signature : <code>int av_packet_make_writable(AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:508</i>
	 */
	public static int av_packet_make_writable(Pointer<AVPacket > pkt) {
		return av_packet_make_writable(Pointer.getPeer(pkt));
	}
	protected native static int av_packet_make_writable(@Ptr long pkt);
	/**
	 * Convert valid timing fields (timestamps / durations) in a packet from one<br>
	 * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be<br>
	 * ignored.<br>
	 * * @param pkt packet on which the conversion will be performed<br>
	 * @param tb_src source timebase, in which the timing fields in pkt are<br>
	 *               expressed<br>
	 * @param tb_dst destination timebase, to which the timing fields will be<br>
	 *               converted<br>
	 * Original signature : <code>void av_packet_rescale_ts(AVPacket*, AVRational, AVRational)</code><br>
	 * <i>native declaration : ./libavcodec/packet.h:520</i>
	 */
	public static void av_packet_rescale_ts(Pointer<AVPacket > pkt, AVRational tb_src, AVRational tb_dst) {
		av_packet_rescale_ts(Pointer.getPeer(pkt), tb_src, tb_dst);
	}
	protected native static void av_packet_rescale_ts(@Ptr long pkt, AVRational tb_src, AVRational tb_dst);
	/**
	 * @return a bitstream filter with the specified name or NULL if no such<br>
	 *         bitstream filter exists.<br>
	 * Original signature : <code>AVBitStreamFilter* av_bsf_get_by_name(const char*)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:80</i>
	 */
	public static Pointer<AVBitStreamFilter > av_bsf_get_by_name(Pointer<Byte > name) {
		return Pointer.pointerToAddress(av_bsf_get_by_name(Pointer.getPeer(name)), AVBitStreamFilter.class);
	}
	@Ptr 
	protected native static long av_bsf_get_by_name(@Ptr long name);
	/**
	 * Iterate over all registered bitstream filters.<br>
	 * * @param opaque a pointer where libavcodec will store the iteration state. Must<br>
	 *               point to NULL to start the iteration.<br>
	 * * @return the next registered bitstream filter or NULL when the iteration is<br>
	 *         finished<br>
	 * Original signature : <code>AVBitStreamFilter* av_bsf_iterate(void**)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:89</i>
	 */
	public static Pointer<AVBitStreamFilter > av_bsf_iterate(Pointer<Pointer<? > > opaque) {
		return Pointer.pointerToAddress(av_bsf_iterate(Pointer.getPeer(opaque)), AVBitStreamFilter.class);
	}
	@Ptr 
	protected native static long av_bsf_iterate(@Ptr long opaque);
	/**
	 * Allocate a context for a given bitstream filter. The caller must fill in the<br>
	 * context parameters as described in the documentation and then call<br>
	 * av_bsf_init() before sending any data to the filter.<br>
	 * * @param filter the filter for which to allocate an instance.<br>
	 * @param ctx a pointer into which the pointer to the newly-allocated context<br>
	 *            will be written. It must be freed with av_bsf_free() after the<br>
	 *            filtering is done.<br>
	 * * @return 0 on success, a negative AVERROR code on failure<br>
	 * Original signature : <code>int av_bsf_alloc(const AVBitStreamFilter*, AVBSFContext**)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:101</i>
	 */
	public static int av_bsf_alloc(Pointer<AVBitStreamFilter > filter, Pointer<Pointer<AVBSFContext > > ctx) {
		return av_bsf_alloc(Pointer.getPeer(filter), Pointer.getPeer(ctx));
	}
	protected native static int av_bsf_alloc(@Ptr long filter, @Ptr long ctx);
	/**
	 * Prepare the filter for use, after all the parameters and options have been<br>
	 * set.<br>
	 * Original signature : <code>int av_bsf_init(AVBSFContext*)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:107</i>
	 */
	public static int av_bsf_init(Pointer<AVBSFContext > ctx) {
		return av_bsf_init(Pointer.getPeer(ctx));
	}
	protected native static int av_bsf_init(@Ptr long ctx);
	/**
	 * Submit a packet for filtering.<br>
	 * * After sending each packet, the filter must be completely drained by calling<br>
	 * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or<br>
	 * AVERROR_EOF.<br>
	 * * @param pkt the packet to filter. The bitstream filter will take ownership of<br>
	 * the packet and reset the contents of pkt. pkt is not touched if an error occurs.<br>
	 * If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),<br>
	 * it signals the end of the stream (i.e. no more non-empty packets will be sent;<br>
	 * sending more empty packets does nothing) and will cause the filter to output<br>
	 * any packets it may have buffered internally.<br>
	 * * @return 0 on success. AVERROR(EAGAIN) if packets need to be retrieved from the<br>
	 * filter (using av_bsf_receive_packet()) before new input can be consumed. Another<br>
	 * negative AVERROR value if an error occurs.<br>
	 * Original signature : <code>int av_bsf_send_packet(AVBSFContext*, AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:124</i>
	 */
	public static int av_bsf_send_packet(Pointer<AVBSFContext > ctx, Pointer<AVPacket > pkt) {
		return av_bsf_send_packet(Pointer.getPeer(ctx), Pointer.getPeer(pkt));
	}
	protected native static int av_bsf_send_packet(@Ptr long ctx, @Ptr long pkt);
	/**
	 * Retrieve a filtered packet.<br>
	 * * @param[out] pkt this struct will be filled with the contents of the filtered<br>
	 *                 packet. It is owned by the caller and must be freed using<br>
	 *                 av_packet_unref() when it is no longer needed.<br>
	 *                 This parameter should be "clean" (i.e. freshly allocated<br>
	 *                 with av_packet_alloc() or unreffed with av_packet_unref())<br>
	 *                 when this function is called. If this function returns<br>
	 *                 successfully, the contents of pkt will be completely<br>
	 *                 overwritten by the returned data. On failure, pkt is not<br>
	 *                 touched.<br>
	 * * @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the<br>
	 * filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there<br>
	 * will be no further output from the filter. Another negative AVERROR value if<br>
	 * an error occurs.<br>
	 * * @note one input packet may result in several output packets, so after sending<br>
	 * a packet with av_bsf_send_packet(), this function needs to be called<br>
	 * repeatedly until it stops returning 0. It is also possible for a filter to<br>
	 * output fewer packets than were sent to it, so this function may return<br>
	 * AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.<br>
	 * Original signature : <code>int av_bsf_receive_packet(AVBSFContext*, AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:147</i>
	 */
	public static int av_bsf_receive_packet(Pointer<AVBSFContext > ctx, Pointer<AVPacket > pkt) {
		return av_bsf_receive_packet(Pointer.getPeer(ctx), Pointer.getPeer(pkt));
	}
	protected native static int av_bsf_receive_packet(@Ptr long ctx, @Ptr long pkt);
	/**
	 * Reset the internal bitstream filter state. Should be called e.g. when seeking.<br>
	 * Original signature : <code>void av_bsf_flush(AVBSFContext*)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:152</i>
	 */
	public static void av_bsf_flush(Pointer<AVBSFContext > ctx) {
		av_bsf_flush(Pointer.getPeer(ctx));
	}
	protected native static void av_bsf_flush(@Ptr long ctx);
	/**
	 * Free a bitstream filter context and everything associated with it; write NULL<br>
	 * into the supplied pointer.<br>
	 * Original signature : <code>void av_bsf_free(AVBSFContext**)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:158</i>
	 */
	public static void av_bsf_free(Pointer<Pointer<AVBSFContext > > ctx) {
		av_bsf_free(Pointer.getPeer(ctx));
	}
	protected native static void av_bsf_free(@Ptr long ctx);
	/**
	 * Get the AVClass for AVBSFContext. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * * @see av_opt_find().<br>
	 * Original signature : <code>AVClass* av_bsf_get_class()</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:165</i>
	 */
	public static Pointer<AVClass > av_bsf__get_class() {
		return Pointer.pointerToAddress(av_bsf_get_class(), AVClass.class);
	}
	@Ptr 
	protected native static long av_bsf_get_class();
	/**
	 * Allocate empty list of bitstream filters.<br>
	 * The list must be later freed by av_bsf_list_free()<br>
	 * or finalized by av_bsf_list_finalize().<br>
	 * * @return Pointer to @ref AVBSFList on success, NULL in case of failure<br>
	 * Original signature : <code>AVBSFList* av_bsf_list_alloc()</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:178</i>
	 */
	public static Pointer<AvcodecLibrary.AVBSFList > av_bsf__list_alloc() {
		return Pointer.pointerToAddress(av_bsf_list_alloc(), AvcodecLibrary.AVBSFList.class);
	}
	@Ptr 
	protected native static long av_bsf_list_alloc();
	/**
	 * Free list of bitstream filters.<br>
	 * * @param lst Pointer to pointer returned by av_bsf_list_alloc()<br>
	 * Original signature : <code>void av_bsf_list_free(AVBSFList**)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:184</i>
	 */
	public static void av_bsf_list_free(Pointer<Pointer<AvcodecLibrary.AVBSFList > > lst) {
		av_bsf_list_free(Pointer.getPeer(lst));
	}
	protected native static void av_bsf_list_free(@Ptr long lst);
	/**
	 * Append bitstream filter to the list of bitstream filters.<br>
	 * * @param lst List to append to<br>
	 * @param bsf Filter context to be appended<br>
	 * * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_append(AVBSFList*, AVBSFContext*)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:192</i>
	 */
	public static int av_bsf_list_append(Pointer<AvcodecLibrary.AVBSFList > lst, Pointer<AVBSFContext > bsf) {
		return av_bsf_list_append(Pointer.getPeer(lst), Pointer.getPeer(bsf));
	}
	protected native static int av_bsf_list_append(@Ptr long lst, @Ptr long bsf);
	/**
	 * Construct new bitstream filter context given it's name and options<br>
	 * and append it to the list of bitstream filters.<br>
	 * * @param lst      List to append to<br>
	 * @param bsf_name Name of the bitstream filter<br>
	 * @param options  Options for the bitstream filter, can be set to NULL<br>
	 * * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_append2(AVBSFList*, const char*, AVDictionary**)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:202</i>
	 */
	public static int av_bsf_list_append2(Pointer<AvcodecLibrary.AVBSFList > lst, Pointer<Byte > bsf_name, Pointer<Pointer<AVDictionary > > options) {
		return av_bsf_list_append2(Pointer.getPeer(lst), Pointer.getPeer(bsf_name), Pointer.getPeer(options));
	}
	protected native static int av_bsf_list_append2(@Ptr long lst, @Ptr long bsf_name, @Ptr long options);
	/**
	 * Finalize list of bitstream filters.<br>
	 * * This function will transform @ref AVBSFList to single @ref AVBSFContext,<br>
	 * so the whole chain of bitstream filters can be treated as single filter<br>
	 * freshly allocated by av_bsf_alloc().<br>
	 * If the call is successful, @ref AVBSFList structure is freed and lst<br>
	 * will be set to NULL. In case of failure, caller is responsible for<br>
	 * freeing the structure by av_bsf_list_free()<br>
	 * * @param      lst Filter list structure to be transformed<br>
	 * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure<br>
	 *                 representing the chain of bitstream filters<br>
	 * * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_finalize(AVBSFList**, AVBSFContext**)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:217</i>
	 */
	public static int av_bsf_list_finalize(Pointer<Pointer<AvcodecLibrary.AVBSFList > > lst, Pointer<Pointer<AVBSFContext > > bsf) {
		return av_bsf_list_finalize(Pointer.getPeer(lst), Pointer.getPeer(bsf));
	}
	protected native static int av_bsf_list_finalize(@Ptr long lst, @Ptr long bsf);
	/**
	 * Parse string describing list of bitstream filters and create single<br>
	 * @ref AVBSFContext describing the whole chain of bitstream filters.<br>
	 * Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly<br>
	 * allocated by av_bsf_alloc().<br>
	 * * @param      str String describing chain of bitstream filters in format<br>
	 *                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`<br>
	 * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure<br>
	 *                 representing the chain of bitstream filters<br>
	 * * @return >=0 on success, negative AVERROR in case of failure<br>
	 * Original signature : <code>int av_bsf_list_parse_str(const char*, AVBSFContext**)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:230</i>
	 */
	public static int av_bsf_list_parse_str(Pointer<Byte > str, Pointer<Pointer<AVBSFContext > > bsf) {
		return av_bsf_list_parse_str(Pointer.getPeer(str), Pointer.getPeer(bsf));
	}
	protected native static int av_bsf_list_parse_str(@Ptr long str, @Ptr long bsf);
	/**
	 * Get null/pass-through bitstream filter.<br>
	 * * @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter<br>
	 * * @return<br>
	 * Original signature : <code>int av_bsf_get_null_filter(AVBSFContext**)</code><br>
	 * <i>native declaration : ./libavcodec/bsf.h:237</i>
	 */
	public static int av_bsf_get_null_filter(Pointer<Pointer<AVBSFContext > > bsf) {
		return av_bsf_get_null_filter(Pointer.getPeer(bsf));
	}
	protected native static int av_bsf_get_null_filter(@Ptr long bsf);
	/**
	 * Iterate over all registered codecs.<br>
	 * * @param opaque a pointer where libavcodec will store the iteration state. Must<br>
	 *               point to NULL to start the iteration.<br>
	 * * @return the next registered codec or NULL when the iteration is<br>
	 *         finished<br>
	 * Original signature : <code>AVCodec* av_codec_iterate(void**)</code><br>
	 * <i>native declaration : ./libavcodec/codec.h:170</i>
	 */
	public static Pointer<AVCodec > av_codec_iterate(Pointer<Pointer<? > > opaque) {
		return Pointer.pointerToAddress(av_codec_iterate(Pointer.getPeer(opaque)), AVCodec.class);
	}
	@Ptr 
	protected native static long av_codec_iterate(@Ptr long opaque);
	/**
	 * Find a registered decoder with a matching codec ID.<br>
	 * * @param id AVCodecID of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder(AVCodecID)</code><br>
	 * <i>native declaration : ./libavcodec/codec.h:177</i>
	 */
	public static Pointer<AVCodec > avcodec_find_decoder(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
		return Pointer.pointerToAddress(avcodec_find_decoder((int)id.value()), AVCodec.class);
	}
	@Ptr 
	protected native static long avcodec_find_decoder(int id);
	/**
	 * Find a registered decoder with the specified name.<br>
	 * * @param name name of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code><br>
	 * <i>native declaration : ./libavcodec/codec.h:184</i>
	 */
	public static Pointer<AVCodec > avcodec_find_decoder_by_name(Pointer<Byte > name) {
		return Pointer.pointerToAddress(avcodec_find_decoder_by_name(Pointer.getPeer(name)), AVCodec.class);
	}
	@Ptr 
	protected native static long avcodec_find_decoder_by_name(@Ptr long name);
	/**
	 * Find a registered encoder with a matching codec ID.<br>
	 * * @param id AVCodecID of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder(AVCodecID)</code><br>
	 * <i>native declaration : ./libavcodec/codec.h:191</i>
	 */
	public static Pointer<AVCodec > avcodec_find_encoder(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
		return Pointer.pointerToAddress(avcodec_find_encoder((int)id.value()), AVCodec.class);
	}
	@Ptr 
	protected native static long avcodec_find_encoder(int id);
	/**
	 * Find a registered encoder with the specified name.<br>
	 * * @param name name of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code><br>
	 * <i>native declaration : ./libavcodec/codec.h:198</i>
	 */
	public static Pointer<AVCodec > avcodec_find_encoder_by_name(Pointer<Byte > name) {
		return Pointer.pointerToAddress(avcodec_find_encoder_by_name(Pointer.getPeer(name)), AVCodec.class);
	}
	@Ptr 
	protected native static long avcodec_find_encoder_by_name(@Ptr long name);
	/**
	 * @return a non-zero number if codec is an encoder, zero otherwise<br>
	 * Original signature : <code>int av_codec_is_encoder(const AVCodec*)</code><br>
	 * <i>native declaration : ./libavcodec/codec.h:203</i>
	 */
	public static int av_codec_is_encoder(Pointer<AVCodec > codec) {
		return av_codec_is_encoder(Pointer.getPeer(codec));
	}
	protected native static int av_codec_is_encoder(@Ptr long codec);
	/**
	 * @return a non-zero number if codec is a decoder, zero otherwise<br>
	 * Original signature : <code>int av_codec_is_decoder(const AVCodec*)</code><br>
	 * <i>native declaration : ./libavcodec/codec.h:208</i>
	 */
	public static int av_codec_is_decoder(Pointer<AVCodec > codec) {
		return av_codec_is_decoder(Pointer.getPeer(codec));
	}
	protected native static int av_codec_is_decoder(@Ptr long codec);
	/**
	 * Retrieve supported hardware configurations for a codec.<br>
	 * * Values of index from zero to some maximum return the indexed configuration<br>
	 * descriptor; all other values return NULL.  If the codec does not support<br>
	 * any hardware configurations then it will always return NULL.<br>
	 * Original signature : <code>AVCodecHWConfig* avcodec_get_hw_config(const AVCodec*, int)</code><br>
	 * <i>native declaration : ./libavcodec/codec.h:275</i>
	 */
	public static Pointer<AVCodecHWConfig > avcodec_get_hw_config(Pointer<AVCodec > codec, int index) {
		return Pointer.pointerToAddress(avcodec_get_hw_config(Pointer.getPeer(codec), index), AVCodecHWConfig.class);
	}
	@Ptr 
	protected native static long avcodec_get_hw_config(@Ptr long codec, int index);
	/**
	 * @return descriptor for given codec ID or NULL if no descriptor exists.<br>
	 * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get(AVCodecID)</code><br>
	 * <i>native declaration : ./libavcodec/codec_desc.h:38</i>
	 */
	public static Pointer<AVCodecDescriptor > avcodec_descriptor_get(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
		return Pointer.pointerToAddress(avcodec_descriptor_get((int)id.value()), AVCodecDescriptor.class);
	}
	@Ptr 
	protected native static long avcodec_descriptor_get(int id);
	/**
	 * Iterate over all codec descriptors known to libavcodec.<br>
	 * * @param prev previous descriptor. NULL to get the first descriptor.<br>
	 * * @return next descriptor or NULL after the last descriptor<br>
	 * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_next(const AVCodecDescriptor*)</code><br>
	 * <i>native declaration : ./libavcodec/codec_desc.h:45</i>
	 */
	public static Pointer<AVCodecDescriptor > avcodec_descriptor_next(Pointer<AVCodecDescriptor > prev) {
		return Pointer.pointerToAddress(avcodec_descriptor_next(Pointer.getPeer(prev)), AVCodecDescriptor.class);
	}
	@Ptr 
	protected native static long avcodec_descriptor_next(@Ptr long prev);
	/**
	 * @return codec descriptor with the given name or NULL if no such descriptor<br>
	 *         exists.<br>
	 * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get_by_name(const char*)</code><br>
	 * <i>native declaration : ./libavcodec/codec_desc.h:51</i>
	 */
	public static Pointer<AVCodecDescriptor > avcodec_descriptor_get_by_name(Pointer<Byte > name) {
		return Pointer.pointerToAddress(avcodec_descriptor_get_by_name(Pointer.getPeer(name)), AVCodecDescriptor.class);
	}
	@Ptr 
	protected native static long avcodec_descriptor_get_by_name(@Ptr long name);
	/**
	 * Original signature : <code>AVRational av_codec_get_pkt_timebase(const AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1393</i>
	 */
	public static AVRational av_codec_get_pkt_timebase(Pointer<AVCodecContext > avctx) {
		return av_codec_get_pkt_timebase(Pointer.getPeer(avctx));
	}
	protected native static AVRational av_codec_get_pkt_timebase(@Ptr long avctx);
	/**
	 * Original signature : <code>void av_codec_set_pkt_timebase(AVCodecContext*, AVRational)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1395</i>
	 */
	public static void av_codec_set_pkt_timebase(Pointer<AVCodecContext > avctx, AVRational val) {
		av_codec_set_pkt_timebase(Pointer.getPeer(avctx), val);
	}
	protected native static void av_codec_set_pkt_timebase(@Ptr long avctx, AVRational val);
	/**
	 * Original signature : <code>AVCodecDescriptor* av_codec_get_codec_descriptor(const AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1397</i>
	 */
	public static Pointer<AVCodecDescriptor > av_codec_get_codec_descriptor(Pointer<AVCodecContext > avctx) {
		return Pointer.pointerToAddress(av_codec_get_codec_descriptor(Pointer.getPeer(avctx)), AVCodecDescriptor.class);
	}
	@Ptr 
	protected native static long av_codec_get_codec_descriptor(@Ptr long avctx);
	/**
	 * Original signature : <code>void av_codec_set_codec_descriptor(AVCodecContext*, const AVCodecDescriptor*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1399</i>
	 */
	public static void av_codec_set_codec_descriptor(Pointer<AVCodecContext > avctx, Pointer<AVCodecDescriptor > desc) {
		av_codec_set_codec_descriptor(Pointer.getPeer(avctx), Pointer.getPeer(desc));
	}
	protected native static void av_codec_set_codec_descriptor(@Ptr long avctx, @Ptr long desc);
	/**
	 * Original signature : <code>int av_codec_get_codec_properties(const AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1401</i>
	 */
	public static int av_codec_get_codec_properties(Pointer<AVCodecContext > avctx) {
		return av_codec_get_codec_properties(Pointer.getPeer(avctx));
	}
	protected native static int av_codec_get_codec_properties(@Ptr long avctx);
	/**
	 * Original signature : <code>int av_codec_get_lowres(const AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1403</i>
	 */
	public static int av_codec_get_lowres(Pointer<AVCodecContext > avctx) {
		return av_codec_get_lowres(Pointer.getPeer(avctx));
	}
	protected native static int av_codec_get_lowres(@Ptr long avctx);
	/**
	 * Original signature : <code>void av_codec_set_lowres(AVCodecContext*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1405</i>
	 */
	public static void av_codec_set_lowres(Pointer<AVCodecContext > avctx, int val) {
		av_codec_set_lowres(Pointer.getPeer(avctx), val);
	}
	protected native static void av_codec_set_lowres(@Ptr long avctx, int val);
	/**
	 * Original signature : <code>int av_codec_get_seek_preroll(const AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1407</i>
	 */
	public static int av_codec_get_seek_preroll(Pointer<AVCodecContext > avctx) {
		return av_codec_get_seek_preroll(Pointer.getPeer(avctx));
	}
	protected native static int av_codec_get_seek_preroll(@Ptr long avctx);
	/**
	 * Original signature : <code>void av_codec_set_seek_preroll(AVCodecContext*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1409</i>
	 */
	public static void av_codec_set_seek_preroll(Pointer<AVCodecContext > avctx, int val) {
		av_codec_set_seek_preroll(Pointer.getPeer(avctx), val);
	}
	protected native static void av_codec_set_seek_preroll(@Ptr long avctx, int val);
	/**
	 * Original signature : <code>uint16_t* av_codec_get_chroma_intra_matrix(const AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1411</i>
	 */
	public static Pointer<Short > av_codec_get_chroma_intra_matrix(Pointer<AVCodecContext > avctx) {
		return Pointer.pointerToAddress(av_codec_get_chroma_intra_matrix(Pointer.getPeer(avctx)), Short.class);
	}
	@Ptr 
	protected native static long av_codec_get_chroma_intra_matrix(@Ptr long avctx);
	/**
	 * Original signature : <code>void av_codec_set_chroma_intra_matrix(AVCodecContext*, uint16_t*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1413</i>
	 */
	public static void av_codec_set_chroma_intra_matrix(Pointer<AVCodecContext > avctx, Pointer<Short > val) {
		av_codec_set_chroma_intra_matrix(Pointer.getPeer(avctx), Pointer.getPeer(val));
	}
	protected native static void av_codec_set_chroma_intra_matrix(@Ptr long avctx, @Ptr long val);
	/**
	 * Original signature : <code>int av_codec_get_max_lowres(const AVCodec*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1416</i>
	 */
	public static int av_codec_get_max_lowres(Pointer<AVCodec > codec) {
		return av_codec_get_max_lowres(Pointer.getPeer(codec));
	}
	protected native static int av_codec_get_max_lowres(@Ptr long codec);
	/**
	 * Original signature : <code>AVCodec* av_codec_next(const AVCodec*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1622</i>
	 */
	public static Pointer<AVCodec > av_codec_next(Pointer<AVCodec > c) {
		return Pointer.pointerToAddress(av_codec_next(Pointer.getPeer(c)), AVCodec.class);
	}
	@Ptr 
	protected native static long av_codec_next(@Ptr long c);
	/**
	 * Return the LIBAVCODEC_VERSION_INT constant.<br>
	 * Original signature : <code>int avcodec_version()</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1627</i>
	 */
	public static native int avcodec_version();
	/**
	 * Return the libavcodec build-time configuration.<br>
	 * Original signature : <code>char* avcodec_configuration()</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1632</i>
	 */
	public static Pointer<Byte > avcodec__configuration() {
		return Pointer.pointerToAddress(avcodec_configuration(), Byte.class);
	}
	@Ptr 
	protected native static long avcodec_configuration();
	/**
	 * Return the libavcodec license.<br>
	 * Original signature : <code>char* avcodec_license()</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1637</i>
	 */
	public static Pointer<Byte > avcodec__license() {
		return Pointer.pointerToAddress(avcodec_license(), Byte.class);
	}
	@Ptr 
	protected native static long avcodec_license();
	/**
	 * Original signature : <code>void avcodec_register(AVCodec*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1639</i>
	 */
	public static void avcodec_register(Pointer<AVCodec > codec) {
		avcodec_register(Pointer.getPeer(codec));
	}
	protected native static void avcodec_register(@Ptr long codec);
	/**
	 * Original signature : <code>void avcodec_register_all()</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1641</i>
	 */
	public static native void avcodec_register_all();
	/**
	 * Allocate an AVCodecContext and set its fields to default values. The<br>
	 * resulting struct should be freed with avcodec_free_context().<br>
	 * * @param codec if non-NULL, allocate private data and initialize defaults<br>
	 *              for the given codec. It is illegal to then call avcodec_open2()<br>
	 *              with a different codec.<br>
	 *              If NULL, then the codec-specific defaults won't be initialized,<br>
	 *              which may result in suboptimal default settings (this is<br>
	 *              important mainly for encoders, e.g. libx264).<br>
	 * * @return An AVCodecContext filled with default values or NULL on failure.<br>
	 * Original signature : <code>AVCodecContext* avcodec_alloc_context3(const AVCodec*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1654</i>
	 */
	public static Pointer<AVCodecContext > avcodec_alloc_context3(Pointer<AVCodec > codec) {
		return Pointer.pointerToAddress(avcodec_alloc_context3(Pointer.getPeer(codec)), AVCodecContext.class);
	}
	@Ptr 
	protected native static long avcodec_alloc_context3(@Ptr long codec);
	/**
	 * Free the codec context and everything associated with it and write NULL to<br>
	 * the provided pointer.<br>
	 * Original signature : <code>void avcodec_free_context(AVCodecContext**)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1660</i>
	 */
	public static void avcodec_free_context(Pointer<Pointer<AVCodecContext > > avctx) {
		avcodec_free_context(Pointer.getPeer(avctx));
	}
	protected native static void avcodec_free_context(@Ptr long avctx);
	/**
	 * @deprecated This function should not be used, as closing and opening a codec<br>
	 * context multiple time is not supported. A new codec context should be<br>
	 * allocated for each new use.<br>
	 * Original signature : <code>int avcodec_get_context_defaults3(AVCodecContext*, const AVCodec*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1667</i>
	 */
	public static int avcodec_get_context_defaults3(Pointer<AVCodecContext > s, Pointer<AVCodec > codec) {
		return avcodec_get_context_defaults3(Pointer.getPeer(s), Pointer.getPeer(codec));
	}
	protected native static int avcodec_get_context_defaults3(@Ptr long s, @Ptr long codec);
	/**
	 * Get the AVClass for AVCodecContext. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * * @see av_opt_find().<br>
	 * Original signature : <code>AVClass* avcodec_get_class()</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1674</i>
	 */
	public static Pointer<AVClass > avcodec__get_class() {
		return Pointer.pointerToAddress(avcodec_get_class(), AVClass.class);
	}
	@Ptr 
	protected native static long avcodec_get_class();
	/**
	 * Original signature : <code>AVClass* avcodec_get_frame_class()</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1676</i>
	 */
	public static Pointer<AVClass > avcodec__get_frame_class() {
		return Pointer.pointerToAddress(avcodec_get_frame_class(), AVClass.class);
	}
	@Ptr 
	protected native static long avcodec_get_frame_class();
	/**
	 * Get the AVClass for AVSubtitleRect. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * * @see av_opt_find().<br>
	 * Original signature : <code>AVClass* avcodec_get_subtitle_rect_class()</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1683</i>
	 */
	public static Pointer<AVClass > avcodec__get_subtitle_rect_class() {
		return Pointer.pointerToAddress(avcodec_get_subtitle_rect_class(), AVClass.class);
	}
	@Ptr 
	protected native static long avcodec_get_subtitle_rect_class();
	/**
	 * Original signature : <code>int avcodec_copy_context(AVCodecContext*, const AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1685</i>
	 */
	public static int avcodec_copy_context(Pointer<AVCodecContext > dest, Pointer<AVCodecContext > src) {
		return avcodec_copy_context(Pointer.getPeer(dest), Pointer.getPeer(src));
	}
	protected native static int avcodec_copy_context(@Ptr long dest, @Ptr long src);
	/**
	 * Fill the parameters struct based on the values from the supplied codec<br>
	 * context. Any allocated fields in par are freed and replaced with duplicates<br>
	 * of the corresponding fields in codec.<br>
	 * * @return >= 0 on success, a negative AVERROR code on failure<br>
	 * Original signature : <code>int avcodec_parameters_from_context(AVCodecParameters*, const AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1693</i>
	 */
	public static int avcodec_parameters_from_context(Pointer<AVCodecParameters > par, Pointer<AVCodecContext > codec) {
		return avcodec_parameters_from_context(Pointer.getPeer(par), Pointer.getPeer(codec));
	}
	protected native static int avcodec_parameters_from_context(@Ptr long par, @Ptr long codec);
	/**
	 * Fill the codec context based on the values from the supplied codec<br>
	 * parameters. Any allocated fields in codec that have a corresponding field in<br>
	 * par are freed and replaced with duplicates of the corresponding field in par.<br>
	 * Fields in codec that do not have a counterpart in par are not touched.<br>
	 * * @return >= 0 on success, a negative AVERROR code on failure.<br>
	 * Original signature : <code>int avcodec_parameters_to_context(AVCodecContext*, const AVCodecParameters*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1702</i>
	 */
	public static int avcodec_parameters_to_context(Pointer<AVCodecContext > codec, Pointer<AVCodecParameters > par) {
		return avcodec_parameters_to_context(Pointer.getPeer(codec), Pointer.getPeer(par));
	}
	protected native static int avcodec_parameters_to_context(@Ptr long codec, @Ptr long par);
	/**
	 * Initialize the AVCodecContext to use the given AVCodec. Prior to using this<br>
	 * function the context has to be allocated with avcodec_alloc_context3().<br>
	 * * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),<br>
	 * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for<br>
	 * retrieving a codec.<br>
	 * * @warning This function is not thread safe!<br>
	 * * @note Always call this function before using decoding routines (such as<br>
	 * @ref avcodec_receive_frame()).<br>
	 * * @code<br>
	 * av_dict_set(&opts, "b", "2.5M", 0);<br>
	 * codec = avcodec_find_decoder(AV_CODEC_ID_H264);<br>
	 * if (!codec)<br>
	 *     exit(1);<br>
	 * * context = avcodec_alloc_context3(codec);<br>
	 * * if (avcodec_open2(context, codec, opts) < 0)<br>
	 *     exit(1);<br>
	 * @endcode<br>
	 * * @param avctx The context to initialize.<br>
	 * @param codec The codec to open this context for. If a non-NULL codec has been<br>
	 *              previously passed to avcodec_alloc_context3() or<br>
	 *              for this context, then this parameter MUST be either NULL or<br>
	 *              equal to the previously passed codec.<br>
	 * @param options A dictionary filled with AVCodecContext and codec-private options.<br>
	 *                On return this object will be filled with options that were not found.<br>
	 * * @return zero on success, a negative value on error<br>
	 * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),<br>
	 *      av_dict_set(), av_opt_find().<br>
	 * Original signature : <code>int avcodec_open2(AVCodecContext*, const AVCodec*, AVDictionary**)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1733</i>
	 */
	public static int avcodec_open2(Pointer<AVCodecContext > avctx, Pointer<AVCodec > codec, Pointer<Pointer<AVDictionary > > options) {
		return avcodec_open2(Pointer.getPeer(avctx), Pointer.getPeer(codec), Pointer.getPeer(options));
	}
	protected native static int avcodec_open2(@Ptr long avctx, @Ptr long codec, @Ptr long options);
	/**
	 * Close a given AVCodecContext and free all the data associated with it<br>
	 * (but not the AVCodecContext itself).<br>
	 * * Calling this function on an AVCodecContext that hasn't been opened will free<br>
	 * the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL<br>
	 * codec. Subsequent calls will do nothing.<br>
	 * * @note Do not use this function. Use avcodec_free_context() to destroy a<br>
	 * codec context (either open or closed). Opening and closing a codec context<br>
	 * multiple times is not supported anymore -- use multiple codec contexts<br>
	 * instead.<br>
	 * Original signature : <code>int avcodec_close(AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1746</i>
	 */
	public static int avcodec_close(Pointer<AVCodecContext > avctx) {
		return avcodec_close(Pointer.getPeer(avctx));
	}
	protected native static int avcodec_close(@Ptr long avctx);
	/**
	 * Free all allocated data in the given subtitle struct.<br>
	 * * @param sub AVSubtitle to free.<br>
	 * Original signature : <code>void avsubtitle_free(AVSubtitle*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1752</i>
	 */
	public static void avsubtitle_free(Pointer<AVSubtitle > sub) {
		avsubtitle_free(Pointer.getPeer(sub));
	}
	protected native static void avsubtitle_free(@Ptr long sub);
	/**
	 * The default callback for AVCodecContext.get_buffer2(). It is made public so<br>
	 * it can be called by custom get_buffer2() implementations for decoders without<br>
	 * AV_CODEC_CAP_DR1 set.<br>
	 * Original signature : <code>int avcodec_default_get_buffer2(AVCodecContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1759</i>
	 */
	public static int avcodec_default_get_buffer2(Pointer<AVCodecContext > s, Pointer<AVFrame > frame, int flags) {
		return avcodec_default_get_buffer2(Pointer.getPeer(s), Pointer.getPeer(frame), flags);
	}
	protected native static int avcodec_default_get_buffer2(@Ptr long s, @Ptr long frame, int flags);
	/**
	 * The default callback for AVCodecContext.get_encode_buffer(). It is made public so<br>
	 * it can be called by custom get_encode_buffer() implementations for encoders without<br>
	 * AV_CODEC_CAP_DR1 set.<br>
	 * Original signature : <code>int avcodec_default_get_encode_buffer(AVCodecContext*, AVPacket*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1766</i>
	 */
	public static int avcodec_default_get_encode_buffer(Pointer<AVCodecContext > s, Pointer<AVPacket > pkt, int flags) {
		return avcodec_default_get_encode_buffer(Pointer.getPeer(s), Pointer.getPeer(pkt), flags);
	}
	protected native static int avcodec_default_get_encode_buffer(@Ptr long s, @Ptr long pkt, int flags);
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you do not use any horizontal<br>
	 * padding.<br>
	 * * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.<br>
	 * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1774</i>
	 */
	public static void avcodec_align_dimensions(Pointer<AVCodecContext > s, Pointer<Integer > width, Pointer<Integer > height) {
		avcodec_align_dimensions(Pointer.getPeer(s), Pointer.getPeer(width), Pointer.getPeer(height));
	}
	protected native static void avcodec_align_dimensions(@Ptr long s, @Ptr long width, @Ptr long height);
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you also ensure that all<br>
	 * line sizes are a multiple of the respective linesize_align[i].<br>
	 * * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.<br>
	 * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[8])</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1782</i>
	 */
	public static void avcodec_align_dimensions2(Pointer<AVCodecContext > s, Pointer<Integer > width, Pointer<Integer > height, Pointer<Integer > linesize_align) {
		avcodec_align_dimensions2(Pointer.getPeer(s), Pointer.getPeer(width), Pointer.getPeer(height), Pointer.getPeer(linesize_align));
	}
	protected native static void avcodec_align_dimensions2(@Ptr long s, @Ptr long width, @Ptr long height, @Ptr long linesize_align);
	/**
	 * Converts AVChromaLocation to swscale x/y chroma position.<br>
	 * * The positions represent the chroma (0,0) position in a coordinates system<br>
	 * with luma (0,0) representing the origin and luma(1,1) representing 256,256<br>
	 * * @param xpos  horizontal chroma sample position<br>
	 * @param ypos  vertical   chroma sample position<br>
	 * Original signature : <code>int avcodec_enum_to_chroma_pos(int*, int*, AVChromaLocation)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1791</i>
	 */
	public static int avcodec_enum_to_chroma_pos(Pointer<Integer > xpos, Pointer<Integer > ypos, IntValuedEnum<AVChromaLocation > pos) {
		return avcodec_enum_to_chroma_pos(Pointer.getPeer(xpos), Pointer.getPeer(ypos), (int)pos.value());
	}
	protected native static int avcodec_enum_to_chroma_pos(@Ptr long xpos, @Ptr long ypos, int pos);
	/**
	 * Converts swscale x/y chroma position to AVChromaLocation.<br>
	 * * The positions represent the chroma (0,0) position in a coordinates system<br>
	 * with luma (0,0) representing the origin and luma(1,1) representing 256,256<br>
	 * * @param xpos  horizontal chroma sample position<br>
	 * @param ypos  vertical   chroma sample position<br>
	 * Original signature : <code>AVChromaLocation avcodec_chroma_pos_to_enum(int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1800</i>
	 */
	public static IntValuedEnum<AVChromaLocation > avcodec__chroma_pos_to_enum(int xpos, int ypos) {
		return FlagSet.fromValue(avcodec_chroma_pos_to_enum(xpos, ypos), AVChromaLocation.class);
	}
	protected native static int avcodec_chroma_pos_to_enum(int xpos, int ypos);
	/**
	 * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1802</i>
	 */
	public static int avcodec_decode_audio4(Pointer<AVCodecContext > avctx, Pointer<AVFrame > frame, Pointer<Integer > got_frame_ptr, Pointer<AVPacket > avpkt) {
		return avcodec_decode_audio4(Pointer.getPeer(avctx), Pointer.getPeer(frame), Pointer.getPeer(got_frame_ptr), Pointer.getPeer(avpkt));
	}
	protected native static int avcodec_decode_audio4(@Ptr long avctx, @Ptr long frame, @Ptr long got_frame_ptr, @Ptr long avpkt);
	/**
	 * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1804</i>
	 */
	public static int avcodec_decode_video2(Pointer<AVCodecContext > avctx, Pointer<AVFrame > picture, Pointer<Integer > got_picture_ptr, Pointer<AVPacket > avpkt) {
		return avcodec_decode_video2(Pointer.getPeer(avctx), Pointer.getPeer(picture), Pointer.getPeer(got_picture_ptr), Pointer.getPeer(avpkt));
	}
	protected native static int avcodec_decode_video2(@Ptr long avctx, @Ptr long picture, @Ptr long got_picture_ptr, @Ptr long avpkt);
	/**
	 * Decode a subtitle message.<br>
	 * Return a negative value on error, otherwise return the number of bytes used.<br>
	 * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
	 * Otherwise, the subtitle is stored in *sub.<br>
	 * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for<br>
	 * simplicity, because the performance difference is expected to be negligible<br>
	 * and reusing a get_buffer written for video codecs would probably perform badly<br>
	 * due to a potentially very different allocation pattern.<br>
	 * * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input<br>
	 * and output. This means that for some packets they will not immediately<br>
	 * produce decoded output and need to be flushed at the end of decoding to get<br>
	 * all the decoded data. Flushing is done by calling this function with packets<br>
	 * with avpkt->data set to NULL and avpkt->size set to 0 until it stops<br>
	 * returning subtitles. It is safe to flush even those decoders that are not<br>
	 * marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.<br>
	 * * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
	 * before packets may be fed to the decoder.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] sub The preallocated AVSubtitle in which the decoded subtitle will be stored,<br>
	 *                 must be freed with avsubtitle_free if *got_sub_ptr is set.<br>
	 * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1830</i>
	 */
	public static int avcodec_decode_subtitle2(Pointer<AVCodecContext > avctx, Pointer<AVSubtitle > sub, Pointer<Integer > got_sub_ptr, Pointer<AVPacket > avpkt) {
		return avcodec_decode_subtitle2(Pointer.getPeer(avctx), Pointer.getPeer(sub), Pointer.getPeer(got_sub_ptr), Pointer.getPeer(avpkt));
	}
	protected native static int avcodec_decode_subtitle2(@Ptr long avctx, @Ptr long sub, @Ptr long got_sub_ptr, @Ptr long avpkt);
	/**
	 * Supply raw packet data as input to a decoder.<br>
	 * * Internally, this call will copy relevant AVCodecContext fields, which can<br>
	 * influence decoding per-packet, and apply them when the packet is actually<br>
	 * decoded. (For example AVCodecContext.skip_frame, which might direct the<br>
	 * decoder to drop the frame contained by the packet sent with this function.)<br>
	 * * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE<br>
	 *          larger than the actual read bytes because some optimized bitstream<br>
	 *          readers read 32 or 64 bits at once and could read over the end.<br>
	 * * @warning Do not mix this API with the legacy API (like avcodec_decode_video2())<br>
	 *          on the same AVCodecContext. It will return unexpected results now<br>
	 *          or in future libavcodec versions.<br>
	 * * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
	 *       before packets may be fed to the decoder.<br>
	 * * @param avctx codec context<br>
	 * @param[in] avpkt The input AVPacket. Usually, this will be a single video<br>
	 *                  frame, or several complete audio frames.<br>
	 *                  Ownership of the packet remains with the caller, and the<br>
	 *                  decoder will not write to the packet. The decoder may create<br>
	 *                  a reference to the packet data (or copy it if the packet is<br>
	 *                  not reference-counted).<br>
	 *                  Unlike with older APIs, the packet is always fully consumed,<br>
	 *                  and if it contains multiple frames (e.g. some audio codecs),<br>
	 *                  will require you to call avcodec_receive_frame() multiple<br>
	 *                  times afterwards before you can send a new packet.<br>
	 *                  It can be NULL (or an AVPacket with data set to NULL and<br>
	 *                  size set to 0); in this case, it is considered a flush<br>
	 *                  packet, which signals the end of the stream. Sending the<br>
	 *                  first flush packet will return success. Subsequent ones are<br>
	 *                  unnecessary and will return AVERROR_EOF. If the decoder<br>
	 *                  still has frames buffered, it will return them after sending<br>
	 *                  a flush packet.<br>
	 * * @return 0 on success, otherwise negative error code:<br>
	 *      AVERROR(EAGAIN):   input is not accepted in the current state - user<br>
	 *                         must read output with avcodec_receive_frame() (once<br>
	 *                         all output is read, the packet should be resent, and<br>
	 *                         the call will not fail with EAGAIN).<br>
	 *      AVERROR_EOF:       the decoder has been flushed, and no new packets can<br>
	 *                         be sent to it (also returned if more than 1 flush<br>
	 *                         packet is sent)<br>
	 *      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush<br>
	 *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar<br>
	 *      other errors: legitimate decoding errors<br>
	 * Original signature : <code>int avcodec_send_packet(AVCodecContext*, const AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1876</i>
	 */
	public static int avcodec_send_packet(Pointer<AVCodecContext > avctx, Pointer<AVPacket > avpkt) {
		return avcodec_send_packet(Pointer.getPeer(avctx), Pointer.getPeer(avpkt));
	}
	protected native static int avcodec_send_packet(@Ptr long avctx, @Ptr long avpkt);
	/**
	 * Return decoded output data from a decoder.<br>
	 * * @param avctx codec context<br>
	 * @param frame This will be set to a reference-counted video or audio<br>
	 *              frame (depending on the decoder type) allocated by the<br>
	 *              decoder. Note that the function will always call<br>
	 *              av_frame_unref(frame) before doing anything else.<br>
	 * * @return<br>
	 *      0:                 success, a frame was returned<br>
	 *      AVERROR(EAGAIN):   output is not available in this state - user must try<br>
	 *                         to send new input<br>
	 *      AVERROR_EOF:       the decoder has been fully flushed, and there will be<br>
	 *                         no more output frames<br>
	 *      AVERROR(EINVAL):   codec not opened, or it is an encoder<br>
	 *      AVERROR_INPUT_CHANGED:   current decoded frame has changed parameters<br>
	 *                               with respect to first decoded frame. Applicable<br>
	 *                               when flag AV_CODEC_FLAG_DROPCHANGED is set.<br>
	 *      other negative values: legitimate decoding errors<br>
	 * Original signature : <code>int avcodec_receive_frame(AVCodecContext*, AVFrame*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1897</i>
	 */
	public static int avcodec_receive_frame(Pointer<AVCodecContext > avctx, Pointer<AVFrame > frame) {
		return avcodec_receive_frame(Pointer.getPeer(avctx), Pointer.getPeer(frame));
	}
	protected native static int avcodec_receive_frame(@Ptr long avctx, @Ptr long frame);
	/**
	 * Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()<br>
	 * to retrieve buffered output packets.<br>
	 * * @param avctx     codec context<br>
	 * @param[in] frame AVFrame containing the raw audio or video frame to be encoded.<br>
	 *                  Ownership of the frame remains with the caller, and the<br>
	 *                  encoder will not write to the frame. The encoder may create<br>
	 *                  a reference to the frame data (or copy it if the frame is<br>
	 *                  not reference-counted).<br>
	 *                  It can be NULL, in which case it is considered a flush<br>
	 *                  packet.  This signals the end of the stream. If the encoder<br>
	 *                  still has packets buffered, it will return them after this<br>
	 *                  call. Once flushing mode has been entered, additional flush<br>
	 *                  packets are ignored, and sending frames will return<br>
	 *                  AVERROR_EOF.<br>
	 * *                  For audio:<br>
	 *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame<br>
	 *                  can have any number of samples.<br>
	 *                  If it is not set, frame->nb_samples must be equal to<br>
	 *                  avctx->frame_size for all frames except the last.<br>
	 *                  The final frame may be smaller than avctx->frame_size.<br>
	 * @return 0 on success, otherwise negative error code:<br>
	 *      AVERROR(EAGAIN):   input is not accepted in the current state - user<br>
	 *                         must read output with avcodec_receive_packet() (once<br>
	 *                         all output is read, the packet should be resent, and<br>
	 *                         the call will not fail with EAGAIN).<br>
	 *      AVERROR_EOF:       the encoder has been flushed, and no new frames can<br>
	 *                         be sent to it<br>
	 *      AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a<br>
	 *                         decoder, or requires flush<br>
	 *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar<br>
	 *      other errors: legitimate encoding errors<br>
	 * Original signature : <code>int avcodec_send_frame(AVCodecContext*, const AVFrame*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1932</i>
	 */
	public static int avcodec_send_frame(Pointer<AVCodecContext > avctx, Pointer<AVFrame > frame) {
		return avcodec_send_frame(Pointer.getPeer(avctx), Pointer.getPeer(frame));
	}
	protected native static int avcodec_send_frame(@Ptr long avctx, @Ptr long frame);
	/**
	 * Read encoded data from the encoder.<br>
	 * * @param avctx codec context<br>
	 * @param avpkt This will be set to a reference-counted packet allocated by the<br>
	 *              encoder. Note that the function will always call<br>
	 *              av_packet_unref(avpkt) before doing anything else.<br>
	 * @return 0 on success, otherwise negative error code:<br>
	 *      AVERROR(EAGAIN):   output is not available in the current state - user<br>
	 *                         must try to send input<br>
	 *      AVERROR_EOF:       the encoder has been fully flushed, and there will be<br>
	 *                         no more output packets<br>
	 *      AVERROR(EINVAL):   codec not opened, or it is a decoder<br>
	 *      other errors: legitimate encoding errors<br>
	 * Original signature : <code>int avcodec_receive_packet(AVCodecContext*, AVPacket*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:1948</i>
	 */
	public static int avcodec_receive_packet(Pointer<AVCodecContext > avctx, Pointer<AVPacket > avpkt) {
		return avcodec_receive_packet(Pointer.getPeer(avctx), Pointer.getPeer(avpkt));
	}
	protected native static int avcodec_receive_packet(@Ptr long avctx, @Ptr long avpkt);
	/**
	 * Create and return a AVHWFramesContext with values adequate for hardware<br>
	 * decoding. This is meant to get called from the get_format callback, and is<br>
	 * a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.<br>
	 * This API is for decoding with certain hardware acceleration modes/APIs only.<br>
	 * * The returned AVHWFramesContext is not initialized. The caller must do this<br>
	 * with av_hwframe_ctx_init().<br>
	 * * Calling this function is not a requirement, but makes it simpler to avoid<br>
	 * codec or hardware API specific details when manually allocating frames.<br>
	 * * Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,<br>
	 * which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes<br>
	 * it unnecessary to call this function or having to care about<br>
	 * AVHWFramesContext initialization at all.<br>
	 * * There are a number of requirements for calling this function:<br>
	 * * - It must be called from get_format with the same avctx parameter that was<br>
	 *   passed to get_format. Calling it outside of get_format is not allowed, and<br>
	 *   can trigger undefined behavior.<br>
	 * - The function is not always supported (see description of return values).<br>
	 *   Even if this function returns successfully, hwaccel initialization could<br>
	 *   fail later. (The degree to which implementations check whether the stream<br>
	 *   is actually supported varies. Some do this check only after the user's<br>
	 *   get_format callback returns.)<br>
	 * - The hw_pix_fmt must be one of the choices suggested by get_format. If the<br>
	 *   user decides to use a AVHWFramesContext prepared with this API function,<br>
	 *   the user must return the same hw_pix_fmt from get_format.<br>
	 * - The device_ref passed to this function must support the given hw_pix_fmt.<br>
	 * - After calling this API function, it is the user's responsibility to<br>
	 *   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),<br>
	 *   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done<br>
	 *   before returning from get_format (this is implied by the normal<br>
	 *   AVCodecContext.hw_frames_ctx API rules).<br>
	 * - The AVHWFramesContext parameters may change every time time get_format is<br>
	 *   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So<br>
	 *   you are inherently required to go through this process again on every<br>
	 *   get_format call.<br>
	 * - It is perfectly possible to call this function without actually using<br>
	 *   the resulting AVHWFramesContext. One use-case might be trying to reuse a<br>
	 *   previously initialized AVHWFramesContext, and calling this API function<br>
	 *   only to test whether the required frame parameters have changed.<br>
	 * - Fields that use dynamically allocated values of any kind must not be set<br>
	 *   by the user unless setting them is explicitly allowed by the documentation.<br>
	 *   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,<br>
	 *   the new free callback must call the potentially set previous free callback.<br>
	 *   This API call may set any dynamically allocated fields, including the free<br>
	 *   callback.<br>
	 * * The function will set at least the following fields on AVHWFramesContext<br>
	 * (potentially more, depending on hwaccel API):<br>
	 * * - All fields set by av_hwframe_ctx_alloc().<br>
	 * - Set the format field to hw_pix_fmt.<br>
	 * - Set the sw_format field to the most suited and most versatile format. (An<br>
	 *   implication is that this will prefer generic formats over opaque formats<br>
	 *   with arbitrary restrictions, if possible.)<br>
	 * - Set the width/height fields to the coded frame size, rounded up to the<br>
	 *   API-specific minimum alignment.<br>
	 * - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size<br>
	 *   field to the number of maximum reference surfaces possible with the codec,<br>
	 *   plus 1 surface for the user to work (meaning the user can safely reference<br>
	 *   at most 1 decoded surface at a time), plus additional buffering introduced<br>
	 *   by frame threading. If the hwaccel does not require pre-allocation, the<br>
	 *   field is left to 0, and the decoder will allocate new surfaces on demand<br>
	 *   during decoding.<br>
	 * - Possibly AVHWFramesContext.hwctx fields, depending on the underlying<br>
	 *   hardware API.<br>
	 * * Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but<br>
	 * with basic frame parameters set.<br>
	 * * The function is stateless, and does not change the AVCodecContext or the<br>
	 * device_ref AVHWDeviceContext.<br>
	 * * @param avctx The context which is currently calling get_format, and which<br>
	 *              implicitly contains all state needed for filling the returned<br>
	 *              AVHWFramesContext properly.<br>
	 * @param device_ref A reference to the AVHWDeviceContext describing the device<br>
	 *                   which will be used by the hardware decoder.<br>
	 * @param hw_pix_fmt The hwaccel format you are going to return from get_format.<br>
	 * @param out_frames_ref On success, set to a reference to an _uninitialized_<br>
	 *                       AVHWFramesContext, created from the given device_ref.<br>
	 *                       Fields will be set to values required for decoding.<br>
	 *                       Not changed if an error is returned.<br>
	 * @return zero on success, a negative value on error. The following error codes<br>
	 *         have special semantics:<br>
	 *      AVERROR(ENOENT): the decoder does not support this functionality. Setup<br>
	 *                       is always manual, or it is a decoder which does not<br>
	 *                       support setting AVCodecContext.hw_frames_ctx at all,<br>
	 *                       or it is a software format.<br>
	 *      AVERROR(EINVAL): it is known that hardware decoding is not supported for<br>
	 *                       this configuration, or the device_ref is not supported<br>
	 *                       for the hwaccel referenced by hw_pix_fmt.<br>
	 * Original signature : <code>int avcodec_get_hw_frames_parameters(AVCodecContext*, AVBufferRef*, AVPixelFormat, AVBufferRef**)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2037</i>
	 */
	public static int avcodec_get_hw_frames_parameters(Pointer<AVCodecContext > avctx, Pointer<AVBufferRef > device_ref, IntValuedEnum<AVPixelFormat > hw_pix_fmt, Pointer<Pointer<AVBufferRef > > out_frames_ref) {
		return avcodec_get_hw_frames_parameters(Pointer.getPeer(avctx), Pointer.getPeer(device_ref), (int)hw_pix_fmt.value(), Pointer.getPeer(out_frames_ref));
	}
	protected native static int avcodec_get_hw_frames_parameters(@Ptr long avctx, @Ptr long device_ref, int hw_pix_fmt, @Ptr long out_frames_ref);
	/**
	 * Iterate over all registered codec parsers.<br>
	 * * @param opaque a pointer where libavcodec will store the iteration state. Must<br>
	 *               point to NULL to start the iteration.<br>
	 * * @return the next registered codec parser or NULL when the iteration is<br>
	 *         finished<br>
	 * Original signature : <code>AVCodecParser* av_parser_iterate(void**)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2190</i>
	 */
	public static Pointer<AVCodecParser > av_parser_iterate(Pointer<Pointer<? > > opaque) {
		return Pointer.pointerToAddress(av_parser_iterate(Pointer.getPeer(opaque)), AVCodecParser.class);
	}
	@Ptr 
	protected native static long av_parser_iterate(@Ptr long opaque);
	/**
	 * Original signature : <code>AVCodecParser* av_parser_next(const AVCodecParser*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2192</i>
	 */
	public static Pointer<AVCodecParser > av_parser_next(Pointer<AVCodecParser > c) {
		return Pointer.pointerToAddress(av_parser_next(Pointer.getPeer(c)), AVCodecParser.class);
	}
	@Ptr 
	protected native static long av_parser_next(@Ptr long c);
	/**
	 * Original signature : <code>void av_register_codec_parser(AVCodecParser*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2194</i>
	 */
	public static void av_register_codec_parser(Pointer<AVCodecParser > parser) {
		av_register_codec_parser(Pointer.getPeer(parser));
	}
	protected native static void av_register_codec_parser(@Ptr long parser);
	/**
	 * Original signature : <code>AVCodecParserContext* av_parser_init(int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2196</i>
	 */
	public static Pointer<AVCodecParserContext > av__parser_init(int codec_id) {
		return Pointer.pointerToAddress(av_parser_init(codec_id), AVCodecParserContext.class);
	}
	@Ptr 
	protected native static long av_parser_init(int codec_id);
	/**
	 * Parse a packet.<br>
	 * * @param s             parser context.<br>
	 * @param avctx         codec context.<br>
	 * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
	 * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
	 * @param buf           input buffer.<br>
	 * @param buf_size      buffer size in bytes without the padding. I.e. the full buffer<br>
	 * size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.<br>
	 * To signal EOF, this should be 0 (so that the last frame<br>
	 * can be output).<br>
	 * @param pts           input presentation timestamp.<br>
	 * @param dts           input decoding timestamp.<br>
	 * @param pos           input byte position in stream.<br>
	 * @return the number of bytes of the input bitstream used.<br>
	 * * Example:<br>
	 * @code<br>
	 *   while(in_len){<br>
	 *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
	 *                                        in_data, in_len,<br>
	 *                                        pts, dts, pos);<br>
	 *       in_data += len;<br>
	 *       in_len  -= len;<br>
	 * *       if(size)<br>
	 *          decode_frame(data, size);<br>
	 *   }<br>
	 * @endcode<br>
	 * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2226</i>
	 */
	public static int av_parser_parse2(Pointer<AVCodecParserContext > s, Pointer<AVCodecContext > avctx, Pointer<Pointer<Byte > > poutbuf, Pointer<Integer > poutbuf_size, Pointer<Byte > buf, int buf_size, long pts, long dts, long pos) {
		return av_parser_parse2(Pointer.getPeer(s), Pointer.getPeer(avctx), Pointer.getPeer(poutbuf), Pointer.getPeer(poutbuf_size), Pointer.getPeer(buf), buf_size, pts, dts, pos);
	}
	protected native static int av_parser_parse2(@Ptr long s, @Ptr long avctx, @Ptr long poutbuf, @Ptr long poutbuf_size, @Ptr long buf, int buf_size, long pts, long dts, long pos);
	/**
	 * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2228</i>
	 */
	public static int av_parser_change(Pointer<AVCodecParserContext > s, Pointer<AVCodecContext > avctx, Pointer<Pointer<Byte > > poutbuf, Pointer<Integer > poutbuf_size, Pointer<Byte > buf, int buf_size, int keyframe) {
		return av_parser_change(Pointer.getPeer(s), Pointer.getPeer(avctx), Pointer.getPeer(poutbuf), Pointer.getPeer(poutbuf_size), Pointer.getPeer(buf), buf_size, keyframe);
	}
	protected native static int av_parser_change(@Ptr long s, @Ptr long avctx, @Ptr long poutbuf, @Ptr long poutbuf_size, @Ptr long buf, int buf_size, int keyframe);
	/**
	 * Original signature : <code>void av_parser_close(AVCodecParserContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2230</i>
	 */
	public static void av_parser_close(Pointer<AVCodecParserContext > s) {
		av_parser_close(Pointer.getPeer(s));
	}
	protected native static void av_parser_close(@Ptr long s);
	/**
	 * Original signature : <code>int avcodec_encode_audio2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2232</i>
	 */
	public static int avcodec_encode_audio2(Pointer<AVCodecContext > avctx, Pointer<AVPacket > avpkt, Pointer<AVFrame > frame, Pointer<Integer > got_packet_ptr) {
		return avcodec_encode_audio2(Pointer.getPeer(avctx), Pointer.getPeer(avpkt), Pointer.getPeer(frame), Pointer.getPeer(got_packet_ptr));
	}
	protected native static int avcodec_encode_audio2(@Ptr long avctx, @Ptr long avpkt, @Ptr long frame, @Ptr long got_packet_ptr);
	/**
	 * Original signature : <code>int avcodec_encode_video2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2234</i>
	 */
	public static int avcodec_encode_video2(Pointer<AVCodecContext > avctx, Pointer<AVPacket > avpkt, Pointer<AVFrame > frame, Pointer<Integer > got_packet_ptr) {
		return avcodec_encode_video2(Pointer.getPeer(avctx), Pointer.getPeer(avpkt), Pointer.getPeer(frame), Pointer.getPeer(got_packet_ptr));
	}
	protected native static int avcodec_encode_video2(@Ptr long avctx, @Ptr long avpkt, @Ptr long frame, @Ptr long got_packet_ptr);
	/**
	 * Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2236</i>
	 */
	public static int avcodec_encode_subtitle(Pointer<AVCodecContext > avctx, Pointer<Byte > buf, int buf_size, Pointer<AVSubtitle > sub) {
		return avcodec_encode_subtitle(Pointer.getPeer(avctx), Pointer.getPeer(buf), buf_size, Pointer.getPeer(sub));
	}
	protected native static int avcodec_encode_subtitle(@Ptr long avctx, @Ptr long buf, int buf_size, @Ptr long sub);
	/**
	 * Original signature : <code>int avpicture_alloc(AVPicture*, AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2238</i>
	 */
	public static int avpicture_alloc(Pointer<AVPicture > picture, IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
		return avpicture_alloc(Pointer.getPeer(picture), (int)pix_fmt.value(), width, height);
	}
	protected native static int avpicture_alloc(@Ptr long picture, int pix_fmt, int width, int height);
	/**
	 * Original signature : <code>void avpicture_free(AVPicture*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2240</i>
	 */
	public static void avpicture_free(Pointer<AVPicture > picture) {
		avpicture_free(Pointer.getPeer(picture));
	}
	protected native static void avpicture_free(@Ptr long picture);
	/**
	 * Original signature : <code>int avpicture_fill(AVPicture*, const uint8_t*, AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2242</i>
	 */
	public static int avpicture_fill(Pointer<AVPicture > picture, Pointer<Byte > ptr, IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
		return avpicture_fill(Pointer.getPeer(picture), Pointer.getPeer(ptr), (int)pix_fmt.value(), width, height);
	}
	protected native static int avpicture_fill(@Ptr long picture, @Ptr long ptr, int pix_fmt, int width, int height);
	/**
	 * Original signature : <code>int avpicture_layout(const AVPicture*, AVPixelFormat, int, int, unsigned char*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2244</i>
	 */
	public static int avpicture_layout(Pointer<AVPicture > src, IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height, Pointer<Byte > dest, int dest_size) {
		return avpicture_layout(Pointer.getPeer(src), (int)pix_fmt.value(), width, height, Pointer.getPeer(dest), dest_size);
	}
	protected native static int avpicture_layout(@Ptr long src, int pix_fmt, int width, int height, @Ptr long dest, int dest_size);
	/**
	 * Original signature : <code>int avpicture_get_size(AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2246</i>
	 */
	public static int avpicture_get_size(IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
		return avpicture_get_size((int)pix_fmt.value(), width, height);
	}
	protected native static int avpicture_get_size(int pix_fmt, int width, int height);
	/**
	 * Original signature : <code>void av_picture_copy(AVPicture*, const AVPicture*, AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2248</i>
	 */
	public static void av_picture_copy(Pointer<AVPicture > dst, Pointer<AVPicture > src, IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
		av_picture_copy(Pointer.getPeer(dst), Pointer.getPeer(src), (int)pix_fmt.value(), width, height);
	}
	protected native static void av_picture_copy(@Ptr long dst, @Ptr long src, int pix_fmt, int width, int height);
	/**
	 * Original signature : <code>int av_picture_crop(AVPicture*, const AVPicture*, AVPixelFormat, int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2250</i>
	 */
	public static int av_picture_crop(Pointer<AVPicture > dst, Pointer<AVPicture > src, IntValuedEnum<AVPixelFormat > pix_fmt, int top_band, int left_band) {
		return av_picture_crop(Pointer.getPeer(dst), Pointer.getPeer(src), (int)pix_fmt.value(), top_band, left_band);
	}
	protected native static int av_picture_crop(@Ptr long dst, @Ptr long src, int pix_fmt, int top_band, int left_band);
	/**
	 * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, AVPixelFormat, int, int, int, int, int*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2252</i>
	 */
	public static int av_picture_pad(Pointer<AVPicture > dst, Pointer<AVPicture > src, int height, int width, IntValuedEnum<AVPixelFormat > pix_fmt, int padtop, int padbottom, int padleft, int padright, Pointer<Integer > color) {
		return av_picture_pad(Pointer.getPeer(dst), Pointer.getPeer(src), height, width, (int)pix_fmt.value(), padtop, padbottom, padleft, padright, Pointer.getPeer(color));
	}
	protected native static int av_picture_pad(@Ptr long dst, @Ptr long src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, @Ptr long color);
	/**
	 * Original signature : <code>void avcodec_get_chroma_sub_sample(AVPixelFormat, int*, int*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2254</i>
	 */
	public static void avcodec_get_chroma_sub_sample(IntValuedEnum<AVPixelFormat > pix_fmt, Pointer<Integer > h_shift, Pointer<Integer > v_shift) {
		avcodec_get_chroma_sub_sample((int)pix_fmt.value(), Pointer.getPeer(h_shift), Pointer.getPeer(v_shift));
	}
	protected native static void avcodec_get_chroma_sub_sample(int pix_fmt, @Ptr long h_shift, @Ptr long v_shift);
	/**
	 * Return a value representing the fourCC code associated to the<br>
	 * pixel format pix_fmt, or 0 if no associated fourCC code can be<br>
	 * found.<br>
	 * Original signature : <code>int avcodec_pix_fmt_to_codec_tag(AVPixelFormat)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2261</i>
	 */
	public static int avcodec_pix_fmt_to_codec_tag(IntValuedEnum<AVPixelFormat > pix_fmt) {
		return avcodec_pix_fmt_to_codec_tag((int)pix_fmt.value());
	}
	protected native static int avcodec_pix_fmt_to_codec_tag(int pix_fmt);
	/**
	 * Find the best pixel format to convert to given a certain source pixel<br>
	 * format.  When converting from one pixel format to another, information loss<br>
	 * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
	 * information will be lost. Similarly, other losses occur when converting from<br>
	 * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of<br>
	 * the given pixel formats should be used to suffer the least amount of loss.<br>
	 * The pixel formats from which it chooses one, are determined by the<br>
	 * pix_fmt_list parameter.<br>
	 * *<br>
	 * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
	 * @return The best pixel format to convert to or -1 if none was found.<br>
	 * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_list(AVPixelFormat*, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2279</i>
	 */
	public static IntValuedEnum<AVPixelFormat > avcodec_find_best_pix_fmt_of_list(Pointer<IntValuedEnum<AVPixelFormat > > pix_fmt_list, IntValuedEnum<AVPixelFormat > src_pix_fmt, int has_alpha, Pointer<Integer > loss_ptr) {
		return FlagSet.fromValue(avcodec_find_best_pix_fmt_of_list(Pointer.getPeer(pix_fmt_list), (int)src_pix_fmt.value(), has_alpha, Pointer.getPeer(loss_ptr)), AVPixelFormat.class);
	}
	protected native static int avcodec_find_best_pix_fmt_of_list(@Ptr long pix_fmt_list, int src_pix_fmt, int has_alpha, @Ptr long loss_ptr);
	/**
	 * Original signature : <code>int avcodec_get_pix_fmt_loss(AVPixelFormat, AVPixelFormat, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2281</i>
	 */
	public static int avcodec_get_pix_fmt_loss(IntValuedEnum<AVPixelFormat > dst_pix_fmt, IntValuedEnum<AVPixelFormat > src_pix_fmt, int has_alpha) {
		return avcodec_get_pix_fmt_loss((int)dst_pix_fmt.value(), (int)src_pix_fmt.value(), has_alpha);
	}
	protected native static int avcodec_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha);
	/**
	 * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2283</i>
	 */
	public static IntValuedEnum<AVPixelFormat > avcodec_find_best_pix_fmt_of_2(IntValuedEnum<AVPixelFormat > dst_pix_fmt1, IntValuedEnum<AVPixelFormat > dst_pix_fmt2, IntValuedEnum<AVPixelFormat > src_pix_fmt, int has_alpha, Pointer<Integer > loss_ptr) {
		return FlagSet.fromValue(avcodec_find_best_pix_fmt_of_2((int)dst_pix_fmt1.value(), (int)dst_pix_fmt2.value(), (int)src_pix_fmt.value(), has_alpha, Pointer.getPeer(loss_ptr)), AVPixelFormat.class);
	}
	protected native static int avcodec_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, @Ptr long loss_ptr);
	/**
	 * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2285</i>
	 */
	public static IntValuedEnum<AVPixelFormat > avcodec_find_best_pix_fmt2(IntValuedEnum<AVPixelFormat > dst_pix_fmt1, IntValuedEnum<AVPixelFormat > dst_pix_fmt2, IntValuedEnum<AVPixelFormat > src_pix_fmt, int has_alpha, Pointer<Integer > loss_ptr) {
		return FlagSet.fromValue(avcodec_find_best_pix_fmt2((int)dst_pix_fmt1.value(), (int)dst_pix_fmt2.value(), (int)src_pix_fmt.value(), has_alpha, Pointer.getPeer(loss_ptr)), AVPixelFormat.class);
	}
	protected native static int avcodec_find_best_pix_fmt2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, @Ptr long loss_ptr);
	/**
	 * Original signature : <code>AVPixelFormat avcodec_default_get_format(AVCodecContext*, AVPixelFormat*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2287</i>
	 */
	public static IntValuedEnum<AVPixelFormat > avcodec_default_get_format(Pointer<AVCodecContext > s, Pointer<IntValuedEnum<AVPixelFormat > > fmt) {
		return FlagSet.fromValue(avcodec_default_get_format(Pointer.getPeer(s), Pointer.getPeer(fmt)), AVPixelFormat.class);
	}
	protected native static int avcodec_default_get_format(@Ptr long s, @Ptr long fmt);
	/**
	 * Original signature : <code>size_t av_get_codec_tag_string(char*, size_t, unsigned int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2289</i>
	 */
	@Ptr 
	public static long av_get_codec_tag_string(Pointer<Byte > buf, @Ptr long buf_size, int codec_tag) {
		return av_get_codec_tag_string(Pointer.getPeer(buf), buf_size, codec_tag);
	}
	@Ptr 
	protected native static long av_get_codec_tag_string(@Ptr long buf, @Ptr long buf_size, int codec_tag);
	/**
	 * Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2291</i>
	 */
	public static void avcodec_string(Pointer<Byte > buf, int buf_size, Pointer<AVCodecContext > enc, int encode) {
		avcodec_string(Pointer.getPeer(buf), buf_size, Pointer.getPeer(enc), encode);
	}
	protected native static void avcodec_string(@Ptr long buf, int buf_size, @Ptr long enc, int encode);
	/**
	 * Return a name for the specified profile, if available.<br>
	 * * @param codec the codec that is searched for the given profile<br>
	 * @param profile the profile value for which a name is requested<br>
	 * @return A name for the profile if found, NULL otherwise.<br>
	 * Original signature : <code>char* av_get_profile_name(const AVCodec*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2299</i>
	 */
	public static Pointer<Byte > av_get_profile_name(Pointer<AVCodec > codec, int profile) {
		return Pointer.pointerToAddress(av_get_profile_name(Pointer.getPeer(codec), profile), Byte.class);
	}
	@Ptr 
	protected native static long av_get_profile_name(@Ptr long codec, int profile);
	/**
	 * Return a name for the specified profile, if available.<br>
	 * * @param codec_id the ID of the codec to which the requested profile belongs<br>
	 * @param profile the profile value for which a name is requested<br>
	 * @return A name for the profile if found, NULL otherwise.<br>
	 * * @note unlike av_get_profile_name(), which searches a list of profiles<br>
	 *       supported by a specific decoder or encoder implementation, this<br>
	 *       function searches the list of profiles from the AVCodecDescriptor<br>
	 * Original signature : <code>char* avcodec_profile_name(AVCodecID, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2310</i>
	 */
	public static Pointer<Byte > avcodec_profile_name(IntValuedEnum<AvcodecLibrary.AVCodecID > codec_id, int profile) {
		return Pointer.pointerToAddress(avcodec_profile_name((int)codec_id.value(), profile), Byte.class);
	}
	@Ptr 
	protected native static long avcodec_profile_name(int codec_id, int profile);
	/**
	 * Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_func_callback*, void*, int*, int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2312</i>
	 */
	public static int avcodec_default_execute(Pointer<AVCodecContext > c, Pointer<AvcodecLibrary.avcodec_default_execute_func_callback > func, Pointer<? > arg, Pointer<Integer > ret, int count, int size) {
		return avcodec_default_execute(Pointer.getPeer(c), Pointer.getPeer(func), Pointer.getPeer(arg), Pointer.getPeer(ret), count, size);
	}
	protected native static int avcodec_default_execute(@Ptr long c, @Ptr long func, @Ptr long arg, @Ptr long ret, int count, int size);
	/**
	 * Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_func_callback*, void*, int*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2314</i>
	 */
	public static int avcodec_default_execute2(Pointer<AVCodecContext > c, Pointer<AvcodecLibrary.avcodec_default_execute2_func_callback > func, Pointer<? > arg, Pointer<Integer > ret, int count) {
		return avcodec_default_execute2(Pointer.getPeer(c), Pointer.getPeer(func), Pointer.getPeer(arg), Pointer.getPeer(ret), count);
	}
	protected native static int avcodec_default_execute2(@Ptr long c, @Ptr long func, @Ptr long arg, @Ptr long ret, int count);
	/**
	 * Fill AVFrame audio data and linesize pointers.<br>
	 * * The buffer buf must be a preallocated buffer with a size big enough<br>
	 * to contain the specified samples amount. The filled AVFrame data<br>
	 * pointers will point to this buffer.<br>
	 * * AVFrame extended_data channel pointers are allocated if necessary for<br>
	 * planar audio.<br>
	 * * @param frame       the AVFrame<br>
	 *                    frame->nb_samples must be set prior to calling the<br>
	 *                    function. This function fills in frame->data,<br>
	 *                    frame->extended_data, frame->linesize[0].<br>
	 * @param nb_channels channel count<br>
	 * @param sample_fmt  sample format<br>
	 * @param buf         buffer to use for frame data<br>
	 * @param buf_size    size of buffer<br>
	 * @param align       plane size sample alignment (0 = default)<br>
	 * @return            >=0 on success, negative error code on failure<br>
	 * @todo return the size in bytes required to store the samples in<br>
	 * case of success, at the next libavutil bump<br>
	 * Original signature : <code>int avcodec_fill_audio_frame(AVFrame*, int, AVSampleFormat, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2336</i>
	 */
	public static int avcodec_fill_audio_frame(Pointer<AVFrame > frame, int nb_channels, IntValuedEnum<AVSampleFormat > sample_fmt, Pointer<Byte > buf, int buf_size, int align) {
		return avcodec_fill_audio_frame(Pointer.getPeer(frame), nb_channels, (int)sample_fmt.value(), Pointer.getPeer(buf), buf_size, align);
	}
	protected native static int avcodec_fill_audio_frame(@Ptr long frame, int nb_channels, int sample_fmt, @Ptr long buf, int buf_size, int align);
	/**
	 * Reset the internal codec state / flush internal buffers. Should be called<br>
	 * e.g. when seeking or when switching to a different stream.<br>
	 * * @note for decoders, when refcounted frames are not used<br>
	 * (i.e. avctx->refcounted_frames is 0), this invalidates the frames previously<br>
	 * returned from the decoder. When refcounted frames are used, the decoder just<br>
	 * releases any references it might keep internally, but the caller's reference<br>
	 * remains valid.<br>
	 * * @note for encoders, this function will only do something if the encoder<br>
	 * declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder<br>
	 * will drain any remaining packets, and can then be re-used for a different<br>
	 * stream (as opposed to sending a null frame which will leave the encoder<br>
	 * in a permanent EOF state after draining). This can be desirable if the<br>
	 * cost of tearing down and replacing the encoder instance is high.<br>
	 * Original signature : <code>void avcodec_flush_buffers(AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2353</i>
	 */
	public static void avcodec_flush_buffers(Pointer<AVCodecContext > avctx) {
		avcodec_flush_buffers(Pointer.getPeer(avctx));
	}
	protected native static void avcodec_flush_buffers(@Ptr long avctx);
	/**
	 * Return codec bits per sample.<br>
	 * * @param[in] codec_id the codec<br>
	 * @return Number of bits per sample or zero if unknown for the given codec.<br>
	 * Original signature : <code>int av_get_bits_per_sample(AVCodecID)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2360</i>
	 */
	public static int av_get_bits_per_sample(IntValuedEnum<AvcodecLibrary.AVCodecID > codec_id) {
		return av_get_bits_per_sample((int)codec_id.value());
	}
	protected native static int av_get_bits_per_sample(int codec_id);
	/**
	 * Return the PCM codec associated with a sample format.<br>
	 * @param be  endianness, 0 for little, 1 for big,<br>
	 *            -1 (or anything else) for native<br>
	 * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE<br>
	 * Original signature : <code>AVCodecID av_get_pcm_codec(AVSampleFormat, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2368</i>
	 */
	public static IntValuedEnum<AvcodecLibrary.AVCodecID > av_get_pcm_codec(IntValuedEnum<AVSampleFormat > fmt, int be) {
		return FlagSet.fromValue(av_get_pcm_codec((int)fmt.value(), be), AvcodecLibrary.AVCodecID.class);
	}
	protected native static int av_get_pcm_codec(int fmt, int be);
	/**
	 * Return codec bits per sample.<br>
	 * Only return non-zero if the bits per sample is exactly correct, not an<br>
	 * approximation.<br>
	 * * @param[in] codec_id the codec<br>
	 * @return Number of bits per sample or zero if unknown for the given codec.<br>
	 * Original signature : <code>int av_get_exact_bits_per_sample(AVCodecID)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2377</i>
	 */
	public static int av_get_exact_bits_per_sample(IntValuedEnum<AvcodecLibrary.AVCodecID > codec_id) {
		return av_get_exact_bits_per_sample((int)codec_id.value());
	}
	protected native static int av_get_exact_bits_per_sample(int codec_id);
	/**
	 * Return audio frame duration.<br>
	 * * @param avctx        codec context<br>
	 * @param frame_bytes  size of the frame, or 0 if unknown<br>
	 * @return             frame duration, in samples, if known. 0 if not able to<br>
	 *                     determine.<br>
	 * Original signature : <code>int av_get_audio_frame_duration(AVCodecContext*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2386</i>
	 */
	public static int av_get_audio_frame_duration(Pointer<AVCodecContext > avctx, int frame_bytes) {
		return av_get_audio_frame_duration(Pointer.getPeer(avctx), frame_bytes);
	}
	protected native static int av_get_audio_frame_duration(@Ptr long avctx, int frame_bytes);
	/**
	 * This function is the same as av_get_audio_frame_duration(), except it works<br>
	 * with AVCodecParameters instead of an AVCodecContext.<br>
	 * Original signature : <code>int av_get_audio_frame_duration2(AVCodecParameters*, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2392</i>
	 */
	public static int av_get_audio_frame_duration2(Pointer<AVCodecParameters > par, int frame_bytes) {
		return av_get_audio_frame_duration2(Pointer.getPeer(par), frame_bytes);
	}
	protected native static int av_get_audio_frame_duration2(@Ptr long par, int frame_bytes);
	/**
	 * Original signature : <code>void av_register_bitstream_filter(AVBitStreamFilter*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2405</i>
	 */
	public static void av_register_bitstream_filter(Pointer<AVBitStreamFilter > bsf) {
		av_register_bitstream_filter(Pointer.getPeer(bsf));
	}
	protected native static void av_register_bitstream_filter(@Ptr long bsf);
	/**
	 * Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2407</i>
	 */
	public static Pointer<AVBitStreamFilterContext > av_bitstream_filter_init(Pointer<Byte > name) {
		return Pointer.pointerToAddress(av_bitstream_filter_init(Pointer.getPeer(name)), AVBitStreamFilterContext.class);
	}
	@Ptr 
	protected native static long av_bitstream_filter_init(@Ptr long name);
	/**
	 * Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2409</i>
	 */
	public static int av_bitstream_filter_filter(Pointer<AVBitStreamFilterContext > bsfc, Pointer<AVCodecContext > avctx, Pointer<Byte > args, Pointer<Pointer<Byte > > poutbuf, Pointer<Integer > poutbuf_size, Pointer<Byte > buf, int buf_size, int keyframe) {
		return av_bitstream_filter_filter(Pointer.getPeer(bsfc), Pointer.getPeer(avctx), Pointer.getPeer(args), Pointer.getPeer(poutbuf), Pointer.getPeer(poutbuf_size), Pointer.getPeer(buf), buf_size, keyframe);
	}
	protected native static int av_bitstream_filter_filter(@Ptr long bsfc, @Ptr long avctx, @Ptr long args, @Ptr long poutbuf, @Ptr long poutbuf_size, @Ptr long buf, int buf_size, int keyframe);
	/**
	 * Original signature : <code>void av_bitstream_filter_close(AVBitStreamFilterContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2411</i>
	 */
	public static void av_bitstream_filter_close(Pointer<AVBitStreamFilterContext > bsf) {
		av_bitstream_filter_close(Pointer.getPeer(bsf));
	}
	protected native static void av_bitstream_filter_close(@Ptr long bsf);
	/**
	 * Original signature : <code>AVBitStreamFilter* av_bitstream_filter_next(const AVBitStreamFilter*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2413</i>
	 */
	public static Pointer<AVBitStreamFilter > av_bitstream_filter_next(Pointer<AVBitStreamFilter > f) {
		return Pointer.pointerToAddress(av_bitstream_filter_next(Pointer.getPeer(f)), AVBitStreamFilter.class);
	}
	@Ptr 
	protected native static long av_bitstream_filter_next(@Ptr long f);
	/**
	 * Original signature : <code>AVBitStreamFilter* av_bsf_next(void**)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2415</i>
	 */
	public static Pointer<AVBitStreamFilter > av_bsf_next(Pointer<Pointer<? > > opaque) {
		return Pointer.pointerToAddress(av_bsf_next(Pointer.getPeer(opaque)), AVBitStreamFilter.class);
	}
	@Ptr 
	protected native static long av_bsf_next(@Ptr long opaque);
	/**
	 * Same behaviour av_fast_malloc but the buffer has additional<br>
	 * AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.<br>
	 * * In addition the whole buffer will initially and after resizes<br>
	 * be 0-initialized so that no uninitialized data will ever appear.<br>
	 * Original signature : <code>void av_fast_padded_malloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2423</i>
	 */
	public static void av_fast_padded_malloc(Pointer<? > ptr, Pointer<Integer > size, @Ptr long min_size) {
		av_fast_padded_malloc(Pointer.getPeer(ptr), Pointer.getPeer(size), min_size);
	}
	protected native static void av_fast_padded_malloc(@Ptr long ptr, @Ptr long size, @Ptr long min_size);
	/**
	 * Same behaviour av_fast_padded_malloc except that buffer will always<br>
	 * be 0-initialized after call.<br>
	 * Original signature : <code>void av_fast_padded_mallocz(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2429</i>
	 */
	public static void av_fast_padded_mallocz(Pointer<? > ptr, Pointer<Integer > size, @Ptr long min_size) {
		av_fast_padded_mallocz(Pointer.getPeer(ptr), Pointer.getPeer(size), min_size);
	}
	protected native static void av_fast_padded_mallocz(@Ptr long ptr, @Ptr long size, @Ptr long min_size);
	/**
	 * Encode extradata length to a buffer. Used by xiph codecs.<br>
	 * * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
	 * @param v size of extradata in bytes<br>
	 * @return number of bytes written to the buffer.<br>
	 * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2437</i>
	 */
	public static int av_xiphlacing(Pointer<Byte > s, int v) {
		return av_xiphlacing(Pointer.getPeer(s), v);
	}
	protected native static int av_xiphlacing(@Ptr long s, int v);
	/**
	 * Original signature : <code>void av_register_hwaccel(AVHWAccel*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2439</i>
	 */
	public static void av_register_hwaccel(Pointer<AVHWAccel > hwaccel) {
		av_register_hwaccel(Pointer.getPeer(hwaccel));
	}
	protected native static void av_register_hwaccel(@Ptr long hwaccel);
	/**
	 * Original signature : <code>AVHWAccel* av_hwaccel_next(const AVHWAccel*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2441</i>
	 */
	public static Pointer<AVHWAccel > av_hwaccel_next(Pointer<AVHWAccel > hwaccel) {
		return Pointer.pointerToAddress(av_hwaccel_next(Pointer.getPeer(hwaccel)), AVHWAccel.class);
	}
	@Ptr 
	protected native static long av_hwaccel_next(@Ptr long hwaccel);
	/**
	 * @return a positive value if s is open (i.e. avcodec_open2() was called on it<br>
	 * with no corresponding avcodec_close()), 0 otherwise.<br>
	 * Original signature : <code>int avcodec_is_open(AVCodecContext*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2461</i>
	 */
	public static int avcodec_is_open(Pointer<AVCodecContext > s) {
		return avcodec_is_open(Pointer.getPeer(s));
	}
	protected native static int avcodec_is_open(@Ptr long s);
	/**
	 * Allocate a CPB properties structure and initialize its fields to default<br>
	 * values.<br>
	 * * @param size if non-NULL, the size of the allocated struct will be written<br>
	 *             here. This is useful for embedding it in side data.<br>
	 * * @return the newly allocated struct or NULL on failure<br>
	 * Original signature : <code>AVCPBProperties* av_cpb_properties_alloc(size_t*)</code><br>
	 * <i>native declaration : ./libavcodec/avcodec.h:2470</i>
	 */
	public static Pointer<AVCPBProperties > av_cpb_properties_alloc(Pointer<SizeT > size) {
		return Pointer.pointerToAddress(av_cpb_properties_alloc(Pointer.getPeer(size)), AVCPBProperties.class);
	}
	@Ptr 
	protected native static long av_cpb_properties_alloc(@Ptr long size);
	/** Undefined type */
	public static interface AVCodecHWConfigInternal {
		
	};
	/** Undefined type */
	public static interface MpegEncContext {
		
	};
	/** Undefined type */
	public static interface AVBSFInternal {
		
	};
	/** Undefined type */
	public static interface AVCodecDefault {
		
	};
	/** Undefined type */
	public static interface AVBSFList {
		
	};
}
