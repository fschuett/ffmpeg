package org.ffmpeg.avcodec;
import org.bridj.BridJ;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.ffmpeg.avcodec.AvcodecLibrary.AVCodecID;
import org.ffmpeg.avcodec.AvcodecLibrary.AVFieldOrder;
import org.ffmpeg.avutil.AVRational;
import org.ffmpeg.avutil.AvutilLibrary.AVChromaLocation;
import org.ffmpeg.avutil.AvutilLibrary.AVColorPrimaries;
import org.ffmpeg.avutil.AvutilLibrary.AVColorRange;
import org.ffmpeg.avutil.AvutilLibrary.AVColorSpace;
import org.ffmpeg.avutil.AvutilLibrary.AVColorTransferCharacteristic;
import org.ffmpeg.avutil.AvutilLibrary.AVMediaType;
/**
 * <i>native declaration : ./libavcodec/codec_par.h:136</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avcodec") 
public class AVCodecParameters extends StructObject {
	static {
		BridJ.register();
	}
	/**
	 * General type of the encoded data.<br>
	 * C type : AVMediaType
	 */
	@Field(0) 
	public IntValuedEnum<AVMediaType > codec_type() {
		return this.io.getEnumField(this, 0);
	}
	/**
	 * General type of the encoded data.<br>
	 * C type : AVMediaType
	 */
	@Field(0) 
	public AVCodecParameters codec_type(IntValuedEnum<AVMediaType > codec_type) {
		this.io.setEnumField(this, 0, codec_type);
		return this;
	}
	/**
	 * Specific type of the encoded data (the codec used).<br>
	 * C type : AVCodecID
	 */
	@Field(1) 
	public IntValuedEnum<AVCodecID > codec_id() {
		return this.io.getEnumField(this, 1);
	}
	/**
	 * Specific type of the encoded data (the codec used).<br>
	 * C type : AVCodecID
	 */
	@Field(1) 
	public AVCodecParameters codec_id(IntValuedEnum<AVCodecID > codec_id) {
		this.io.setEnumField(this, 1, codec_id);
		return this;
	}
	/** Additional information about the codec (corresponds to the AVI FOURCC). */
	@Field(2) 
	public int codec_tag() {
		return this.io.getIntField(this, 2);
	}
	/** Additional information about the codec (corresponds to the AVI FOURCC). */
	@Field(2) 
	public AVCodecParameters codec_tag(int codec_tag) {
		this.io.setIntField(this, 2, codec_tag);
		return this;
	}
	/**
	 * Extra binary data needed for initializing the decoder, codec-dependent.<br>
	 * * Must be allocated with av_malloc() and will be freed by<br>
	 * avcodec_parameters_free(). The allocated size of extradata must be at<br>
	 * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding<br>
	 * bytes zeroed.<br>
	 * C type : uint8_t*
	 */
	@Field(3) 
	public Pointer<Byte > extradata() {
		return this.io.getPointerField(this, 3);
	}
	/**
	 * Extra binary data needed for initializing the decoder, codec-dependent.<br>
	 * * Must be allocated with av_malloc() and will be freed by<br>
	 * avcodec_parameters_free(). The allocated size of extradata must be at<br>
	 * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding<br>
	 * bytes zeroed.<br>
	 * C type : uint8_t*
	 */
	@Field(3) 
	public AVCodecParameters extradata(Pointer<Byte > extradata) {
		this.io.setPointerField(this, 3, extradata);
		return this;
	}
	/** Size of the extradata content in bytes. */
	@Field(4) 
	public int extradata_size() {
		return this.io.getIntField(this, 4);
	}
	/** Size of the extradata content in bytes. */
	@Field(4) 
	public AVCodecParameters extradata_size(int extradata_size) {
		this.io.setIntField(this, 4, extradata_size);
		return this;
	}
	/**
	 * - video: the pixel format, the value corresponds to enum AVPixelFormat.<br>
	 * - audio: the sample format, the value corresponds to enum AVSampleFormat.
	 */
	@Field(5) 
	public int format() {
		return this.io.getIntField(this, 5);
	}
	/**
	 * - video: the pixel format, the value corresponds to enum AVPixelFormat.<br>
	 * - audio: the sample format, the value corresponds to enum AVSampleFormat.
	 */
	@Field(5) 
	public AVCodecParameters format(int format) {
		this.io.setIntField(this, 5, format);
		return this;
	}
	/** The average bitrate of the encoded data (in bits per second). */
	@Field(6) 
	public long bit_rate() {
		return this.io.getLongField(this, 6);
	}
	/** The average bitrate of the encoded data (in bits per second). */
	@Field(6) 
	public AVCodecParameters bit_rate(long bit_rate) {
		this.io.setLongField(this, 6, bit_rate);
		return this;
	}
	/**
	 * The number of bits per sample in the codedwords.<br>
	 * * This is basically the bitrate per sample. It is mandatory for a bunch of<br>
	 * formats to actually decode them. It's the number of bits for one sample in<br>
	 * the actual coded bitstream.<br>
	 * * This could be for example 4 for ADPCM<br>
	 * For PCM formats this matches bits_per_raw_sample<br>
	 * Can be 0
	 */
	@Field(7) 
	public int bits_per_coded_sample() {
		return this.io.getIntField(this, 7);
	}
	/**
	 * The number of bits per sample in the codedwords.<br>
	 * * This is basically the bitrate per sample. It is mandatory for a bunch of<br>
	 * formats to actually decode them. It's the number of bits for one sample in<br>
	 * the actual coded bitstream.<br>
	 * * This could be for example 4 for ADPCM<br>
	 * For PCM formats this matches bits_per_raw_sample<br>
	 * Can be 0
	 */
	@Field(7) 
	public AVCodecParameters bits_per_coded_sample(int bits_per_coded_sample) {
		this.io.setIntField(this, 7, bits_per_coded_sample);
		return this;
	}
	/**
	 * This is the number of valid bits in each output sample. If the<br>
	 * sample format has more bits, the least significant bits are additional<br>
	 * padding bits, which are always 0. Use right shifts to reduce the sample<br>
	 * to its actual size. For example, audio formats with 24 bit samples will<br>
	 * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.<br>
	 * To get the original sample use "(int32_t)sample >> 8"."<br>
	 * * For ADPCM this might be 12 or 16 or similar<br>
	 * Can be 0
	 */
	@Field(8) 
	public int bits_per_raw_sample() {
		return this.io.getIntField(this, 8);
	}
	/**
	 * This is the number of valid bits in each output sample. If the<br>
	 * sample format has more bits, the least significant bits are additional<br>
	 * padding bits, which are always 0. Use right shifts to reduce the sample<br>
	 * to its actual size. For example, audio formats with 24 bit samples will<br>
	 * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.<br>
	 * To get the original sample use "(int32_t)sample >> 8"."<br>
	 * * For ADPCM this might be 12 or 16 or similar<br>
	 * Can be 0
	 */
	@Field(8) 
	public AVCodecParameters bits_per_raw_sample(int bits_per_raw_sample) {
		this.io.setIntField(this, 8, bits_per_raw_sample);
		return this;
	}
	/** Codec-specific bitstream restrictions that the stream conforms to. */
	@Field(9) 
	public int profile() {
		return this.io.getIntField(this, 9);
	}
	/** Codec-specific bitstream restrictions that the stream conforms to. */
	@Field(9) 
	public AVCodecParameters profile(int profile) {
		this.io.setIntField(this, 9, profile);
		return this;
	}
	@Field(10) 
	public int level() {
		return this.io.getIntField(this, 10);
	}
	@Field(10) 
	public AVCodecParameters level(int level) {
		this.io.setIntField(this, 10, level);
		return this;
	}
	/** Video only. The dimensions of the video frame in pixels. */
	@Field(11) 
	public int width() {
		return this.io.getIntField(this, 11);
	}
	/** Video only. The dimensions of the video frame in pixels. */
	@Field(11) 
	public AVCodecParameters width(int width) {
		this.io.setIntField(this, 11, width);
		return this;
	}
	@Field(12) 
	public int height() {
		return this.io.getIntField(this, 12);
	}
	@Field(12) 
	public AVCodecParameters height(int height) {
		this.io.setIntField(this, 12, height);
		return this;
	}
	/**
	 * Video only. The aspect ratio (width / height) which a single pixel<br>
	 * should have when displayed.<br>
	 * * When the aspect ratio is unknown / undefined, the numerator should be<br>
	 * set to 0 (the denominator may have any value).<br>
	 * C type : AVRational
	 */
	@Field(13) 
	public AVRational sample_aspect_ratio() {
		return this.io.getNativeObjectField(this, 13);
	}
	/**
	 * Video only. The aspect ratio (width / height) which a single pixel<br>
	 * should have when displayed.<br>
	 * * When the aspect ratio is unknown / undefined, the numerator should be<br>
	 * set to 0 (the denominator may have any value).<br>
	 * C type : AVRational
	 */
	@Field(13) 
	public AVCodecParameters sample_aspect_ratio(AVRational sample_aspect_ratio) {
		this.io.setNativeObjectField(this, 13, sample_aspect_ratio);
		return this;
	}
	/**
	 * Video only. The order of the fields in interlaced video.<br>
	 * C type : AVFieldOrder
	 */
	@Field(14) 
	public IntValuedEnum<AVFieldOrder > field_order() {
		return this.io.getEnumField(this, 14);
	}
	/**
	 * Video only. The order of the fields in interlaced video.<br>
	 * C type : AVFieldOrder
	 */
	@Field(14) 
	public AVCodecParameters field_order(IntValuedEnum<AVFieldOrder > field_order) {
		this.io.setEnumField(this, 14, field_order);
		return this;
	}
	/**
	 * Video only. Additional colorspace characteristics.<br>
	 * C type : AVColorRange
	 */
	@Field(15) 
	public IntValuedEnum<AVColorRange > color_range() {
		return this.io.getEnumField(this, 15);
	}
	/**
	 * Video only. Additional colorspace characteristics.<br>
	 * C type : AVColorRange
	 */
	@Field(15) 
	public AVCodecParameters color_range(IntValuedEnum<AVColorRange > color_range) {
		this.io.setEnumField(this, 15, color_range);
		return this;
	}
	/** C type : AVColorPrimaries */
	@Field(16) 
	public IntValuedEnum<AVColorPrimaries > color_primaries() {
		return this.io.getEnumField(this, 16);
	}
	/** C type : AVColorPrimaries */
	@Field(16) 
	public AVCodecParameters color_primaries(IntValuedEnum<AVColorPrimaries > color_primaries) {
		this.io.setEnumField(this, 16, color_primaries);
		return this;
	}
	/** C type : AVColorTransferCharacteristic */
	@Field(17) 
	public IntValuedEnum<AVColorTransferCharacteristic > color_trc() {
		return this.io.getEnumField(this, 17);
	}
	/** C type : AVColorTransferCharacteristic */
	@Field(17) 
	public AVCodecParameters color_trc(IntValuedEnum<AVColorTransferCharacteristic > color_trc) {
		this.io.setEnumField(this, 17, color_trc);
		return this;
	}
	/** C type : AVColorSpace */
	@Field(18) 
	public IntValuedEnum<AVColorSpace > color_space() {
		return this.io.getEnumField(this, 18);
	}
	/** C type : AVColorSpace */
	@Field(18) 
	public AVCodecParameters color_space(IntValuedEnum<AVColorSpace > color_space) {
		this.io.setEnumField(this, 18, color_space);
		return this;
	}
	/** C type : AVChromaLocation */
	@Field(19) 
	public IntValuedEnum<AVChromaLocation > chroma_location() {
		return this.io.getEnumField(this, 19);
	}
	/** C type : AVChromaLocation */
	@Field(19) 
	public AVCodecParameters chroma_location(IntValuedEnum<AVChromaLocation > chroma_location) {
		this.io.setEnumField(this, 19, chroma_location);
		return this;
	}
	/** Video only. Number of delayed frames. */
	@Field(20) 
	public int video_delay() {
		return this.io.getIntField(this, 20);
	}
	/** Video only. Number of delayed frames. */
	@Field(20) 
	public AVCodecParameters video_delay(int video_delay) {
		this.io.setIntField(this, 20, video_delay);
		return this;
	}
	/**
	 * Audio only. The channel layout bitmask. May be 0 if the channel layout is<br>
	 * unknown or unspecified, otherwise the number of bits set must be equal to<br>
	 * the channels field.
	 */
	@Field(21) 
	public long channel_layout() {
		return this.io.getLongField(this, 21);
	}
	/**
	 * Audio only. The channel layout bitmask. May be 0 if the channel layout is<br>
	 * unknown or unspecified, otherwise the number of bits set must be equal to<br>
	 * the channels field.
	 */
	@Field(21) 
	public AVCodecParameters channel_layout(long channel_layout) {
		this.io.setLongField(this, 21, channel_layout);
		return this;
	}
	/** Audio only. The number of audio channels. */
	@Field(22) 
	public int channels() {
		return this.io.getIntField(this, 22);
	}
	/** Audio only. The number of audio channels. */
	@Field(22) 
	public AVCodecParameters channels(int channels) {
		this.io.setIntField(this, 22, channels);
		return this;
	}
	/** Audio only. The number of audio samples per second. */
	@Field(23) 
	public int sample_rate() {
		return this.io.getIntField(this, 23);
	}
	/** Audio only. The number of audio samples per second. */
	@Field(23) 
	public AVCodecParameters sample_rate(int sample_rate) {
		this.io.setIntField(this, 23, sample_rate);
		return this;
	}
	/**
	 * Audio only. The number of bytes per coded audio frame, required by some<br>
	 * formats.<br>
	 * * Corresponds to nBlockAlign in WAVEFORMATEX.
	 */
	@Field(24) 
	public int block_align() {
		return this.io.getIntField(this, 24);
	}
	/**
	 * Audio only. The number of bytes per coded audio frame, required by some<br>
	 * formats.<br>
	 * * Corresponds to nBlockAlign in WAVEFORMATEX.
	 */
	@Field(24) 
	public AVCodecParameters block_align(int block_align) {
		this.io.setIntField(this, 24, block_align);
		return this;
	}
	/** Audio only. Audio frame size, if known. Required by some formats to be static. */
	@Field(25) 
	public int frame_size() {
		return this.io.getIntField(this, 25);
	}
	/** Audio only. Audio frame size, if known. Required by some formats to be static. */
	@Field(25) 
	public AVCodecParameters frame_size(int frame_size) {
		this.io.setIntField(this, 25, frame_size);
		return this;
	}
	/**
	 * Audio only. The amount of padding (in samples) inserted by the encoder at<br>
	 * the beginning of the audio. I.e. this number of leading decoded samples<br>
	 * must be discarded by the caller to get the original audio without leading<br>
	 * padding.
	 */
	@Field(26) 
	public int initial_padding() {
		return this.io.getIntField(this, 26);
	}
	/**
	 * Audio only. The amount of padding (in samples) inserted by the encoder at<br>
	 * the beginning of the audio. I.e. this number of leading decoded samples<br>
	 * must be discarded by the caller to get the original audio without leading<br>
	 * padding.
	 */
	@Field(26) 
	public AVCodecParameters initial_padding(int initial_padding) {
		this.io.setIntField(this, 26, initial_padding);
		return this;
	}
	/**
	 * Audio only. The amount of padding (in samples) appended by the encoder to<br>
	 * the end of the audio. I.e. this number of decoded samples must be<br>
	 * discarded by the caller from the end of the stream to get the original<br>
	 * audio without any trailing padding.
	 */
	@Field(27) 
	public int trailing_padding() {
		return this.io.getIntField(this, 27);
	}
	/**
	 * Audio only. The amount of padding (in samples) appended by the encoder to<br>
	 * the end of the audio. I.e. this number of decoded samples must be<br>
	 * discarded by the caller from the end of the stream to get the original<br>
	 * audio without any trailing padding.
	 */
	@Field(27) 
	public AVCodecParameters trailing_padding(int trailing_padding) {
		this.io.setIntField(this, 27, trailing_padding);
		return this;
	}
	/** Audio only. Number of samples to skip after a discontinuity. */
	@Field(28) 
	public int seek_preroll() {
		return this.io.getIntField(this, 28);
	}
	/** Audio only. Number of samples to skip after a discontinuity. */
	@Field(28) 
	public AVCodecParameters seek_preroll(int seek_preroll) {
		this.io.setIntField(this, 28, seek_preroll);
		return this;
	}
	public AVCodecParameters() {
		super();
	}
	public AVCodecParameters(Pointer pointer) {
		super(pointer);
	}
}
