package org.ffmpeg.avutil;
import org.bridj.BridJ;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * <i>native declaration : libavutil/frame.h:203</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avutil") 
public class AVRegionOfInterest extends StructObject {
	static {
		BridJ.register();
	}
	/**
	 * Must be set to the size of this data structure (that is,<br>
	 * sizeof(AVRegionOfInterest)).
	 */
	@Field(0) 
	public int self_size() {
		return this.io.getIntField(this, 0);
	}
	/**
	 * Must be set to the size of this data structure (that is,<br>
	 * sizeof(AVRegionOfInterest)).
	 */
	@Field(0) 
	public AVRegionOfInterest self_size(int self_size) {
		this.io.setIntField(this, 0, self_size);
		return this;
	}
	/**
	 * Distance in pixels from the top edge of the frame to the top and<br>
	 * bottom edges and from the left edge of the frame to the left and<br>
	 * right edges of the rectangle defining this region of interest.<br>
	 * * The constraints on a region are encoder dependent, so the region<br>
	 * actually affected may be slightly larger for alignment or other<br>
	 * reasons.
	 */
	@Field(1) 
	public int top() {
		return this.io.getIntField(this, 1);
	}
	/**
	 * Distance in pixels from the top edge of the frame to the top and<br>
	 * bottom edges and from the left edge of the frame to the left and<br>
	 * right edges of the rectangle defining this region of interest.<br>
	 * * The constraints on a region are encoder dependent, so the region<br>
	 * actually affected may be slightly larger for alignment or other<br>
	 * reasons.
	 */
	@Field(1) 
	public AVRegionOfInterest top(int top) {
		this.io.setIntField(this, 1, top);
		return this;
	}
	@Field(2) 
	public int bottom() {
		return this.io.getIntField(this, 2);
	}
	@Field(2) 
	public AVRegionOfInterest bottom(int bottom) {
		this.io.setIntField(this, 2, bottom);
		return this;
	}
	@Field(3) 
	public int left() {
		return this.io.getIntField(this, 3);
	}
	@Field(3) 
	public AVRegionOfInterest left(int left) {
		this.io.setIntField(this, 3, left);
		return this;
	}
	@Field(4) 
	public int right() {
		return this.io.getIntField(this, 4);
	}
	@Field(4) 
	public AVRegionOfInterest right(int right) {
		this.io.setIntField(this, 4, right);
		return this;
	}
	/**
	 * Quantisation offset.<br>
	 * * Must be in the range -1 to +1.  A value of zero indicates no quality<br>
	 * change.  A negative value asks for better quality (less quantisation),<br>
	 * while a positive value asks for worse quality (greater quantisation).<br>
	 * * The range is calibrated so that the extreme values indicate the<br>
	 * largest possible offset - if the rest of the frame is encoded with the<br>
	 * worst possible quality, an offset of -1 indicates that this region<br>
	 * should be encoded with the best possible quality anyway.  Intermediate<br>
	 * values are then interpolated in some codec-dependent way.<br>
	 * * For example, in 10-bit H.264 the quantisation parameter varies between<br>
	 * -12 and 51.  A typical qoffset value of -1/10 therefore indicates that<br>
	 * this region should be encoded with a QP around one-tenth of the full<br>
	 * range better than the rest of the frame.  So, if most of the frame<br>
	 * were to be encoded with a QP of around 30, this region would get a QP<br>
	 * of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3).<br>
	 * An extreme value of -1 would indicate that this region should be<br>
	 * encoded with the best possible quality regardless of the treatment of<br>
	 * the rest of the frame - that is, should be encoded at a QP of -12.<br>
	 * C type : AVRational
	 */
	@Field(5) 
	public AVRational qoffset() {
		return this.io.getNativeObjectField(this, 5);
	}
	/**
	 * Quantisation offset.<br>
	 * * Must be in the range -1 to +1.  A value of zero indicates no quality<br>
	 * change.  A negative value asks for better quality (less quantisation),<br>
	 * while a positive value asks for worse quality (greater quantisation).<br>
	 * * The range is calibrated so that the extreme values indicate the<br>
	 * largest possible offset - if the rest of the frame is encoded with the<br>
	 * worst possible quality, an offset of -1 indicates that this region<br>
	 * should be encoded with the best possible quality anyway.  Intermediate<br>
	 * values are then interpolated in some codec-dependent way.<br>
	 * * For example, in 10-bit H.264 the quantisation parameter varies between<br>
	 * -12 and 51.  A typical qoffset value of -1/10 therefore indicates that<br>
	 * this region should be encoded with a QP around one-tenth of the full<br>
	 * range better than the rest of the frame.  So, if most of the frame<br>
	 * were to be encoded with a QP of around 30, this region would get a QP<br>
	 * of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3).<br>
	 * An extreme value of -1 would indicate that this region should be<br>
	 * encoded with the best possible quality regardless of the treatment of<br>
	 * the rest of the frame - that is, should be encoded at a QP of -12.<br>
	 * C type : AVRational
	 */
	@Field(5) 
	public AVRegionOfInterest qoffset(AVRational qoffset) {
		this.io.setNativeObjectField(this, 5, qoffset);
		return this;
	}
	public AVRegionOfInterest() {
		super();
	}
	public AVRegionOfInterest(Pointer pointer) {
		super(pointer);
	}
}
