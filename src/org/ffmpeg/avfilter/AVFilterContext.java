package org.ffmpeg.avfilter;
import org.bridj.BridJ;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import org.ffmpeg.avutil.AVBufferRef;
import org.ffmpeg.avutil.AVClass;
/**
 * An instance of a filter<br>
 * <i>native declaration : libavfilter/avfilter.h:232</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avfilter") 
public class AVFilterContext extends StructObject {
	static {
		BridJ.register();
	}
	/**
	 * < needed for av_log() and filters common options<br>
	 * C type : const AVClass*
	 */
	@Field(0) 
	public Pointer<AVClass > av_class() {
		return this.io.getPointerField(this, 0);
	}
	/**
	 * < needed for av_log() and filters common options<br>
	 * C type : const AVClass*
	 */
	@Field(0) 
	public AVFilterContext av_class(Pointer<AVClass > av_class) {
		this.io.setPointerField(this, 0, av_class);
		return this;
	}
	/**
	 * < the AVFilter of which this is an instance<br>
	 * C type : const AVFilter*
	 */
	@Field(1) 
	public Pointer<AVFilter > filter() {
		return this.io.getPointerField(this, 1);
	}
	/**
	 * < the AVFilter of which this is an instance<br>
	 * C type : const AVFilter*
	 */
	@Field(1) 
	public AVFilterContext filter(Pointer<AVFilter > filter) {
		this.io.setPointerField(this, 1, filter);
		return this;
	}
	/**
	 * < name of this filter instance<br>
	 * C type : char*
	 */
	@Field(2) 
	public Pointer<Byte > name() {
		return this.io.getPointerField(this, 2);
	}
	/**
	 * < name of this filter instance<br>
	 * C type : char*
	 */
	@Field(2) 
	public AVFilterContext name(Pointer<Byte > name) {
		this.io.setPointerField(this, 2, name);
		return this;
	}
	/**
	 * < array of input pads<br>
	 * C type : AVFilterPad*
	 */
	@Field(3) 
	public Pointer<AVFilterPad > input_pads() {
		return this.io.getPointerField(this, 3);
	}
	/**
	 * < array of input pads<br>
	 * C type : AVFilterPad*
	 */
	@Field(3) 
	public AVFilterContext input_pads(Pointer<AVFilterPad > input_pads) {
		this.io.setPointerField(this, 3, input_pads);
		return this;
	}
	/**
	 * < array of pointers to input links<br>
	 * C type : AVFilterLink**
	 */
	@Field(4) 
	public Pointer<Pointer<AVFilterLink > > inputs() {
		return this.io.getPointerField(this, 4);
	}
	/**
	 * < array of pointers to input links<br>
	 * C type : AVFilterLink**
	 */
	@Field(4) 
	public AVFilterContext inputs(Pointer<Pointer<AVFilterLink > > inputs) {
		this.io.setPointerField(this, 4, inputs);
		return this;
	}
	/** < number of input pads */
	@Field(5) 
	public int nb_inputs() {
		return this.io.getIntField(this, 5);
	}
	/** < number of input pads */
	@Field(5) 
	public AVFilterContext nb_inputs(int nb_inputs) {
		this.io.setIntField(this, 5, nb_inputs);
		return this;
	}
	/**
	 * < array of output pads<br>
	 * C type : AVFilterPad*
	 */
	@Field(6) 
	public Pointer<AVFilterPad > output_pads() {
		return this.io.getPointerField(this, 6);
	}
	/**
	 * < array of output pads<br>
	 * C type : AVFilterPad*
	 */
	@Field(6) 
	public AVFilterContext output_pads(Pointer<AVFilterPad > output_pads) {
		this.io.setPointerField(this, 6, output_pads);
		return this;
	}
	/**
	 * < array of pointers to output links<br>
	 * C type : AVFilterLink**
	 */
	@Field(7) 
	public Pointer<Pointer<AVFilterLink > > outputs() {
		return this.io.getPointerField(this, 7);
	}
	/**
	 * < array of pointers to output links<br>
	 * C type : AVFilterLink**
	 */
	@Field(7) 
	public AVFilterContext outputs(Pointer<Pointer<AVFilterLink > > outputs) {
		this.io.setPointerField(this, 7, outputs);
		return this;
	}
	/** < number of output pads */
	@Field(8) 
	public int nb_outputs() {
		return this.io.getIntField(this, 8);
	}
	/** < number of output pads */
	@Field(8) 
	public AVFilterContext nb_outputs(int nb_outputs) {
		this.io.setIntField(this, 8, nb_outputs);
		return this;
	}
	/**
	 * < private data for use by the filter<br>
	 * C type : void*
	 */
	@Field(9) 
	public Pointer<? > priv() {
		return this.io.getPointerField(this, 9);
	}
	/**
	 * < private data for use by the filter<br>
	 * C type : void*
	 */
	@Field(9) 
	public AVFilterContext priv(Pointer<? > priv) {
		this.io.setPointerField(this, 9, priv);
		return this;
	}
	/**
	 * < filtergraph this filter belongs to<br>
	 * C type : AVFilterGraph*
	 */
	@Field(10) 
	public Pointer<AVFilterGraph > graph() {
		return this.io.getPointerField(this, 10);
	}
	/**
	 * < filtergraph this filter belongs to<br>
	 * C type : AVFilterGraph*
	 */
	@Field(10) 
	public AVFilterContext graph(Pointer<AVFilterGraph > graph) {
		this.io.setPointerField(this, 10, graph);
		return this;
	}
	/**
	 * Type of multithreading being allowed/used. A combination of<br>
	 * AVFILTER_THREAD_* flags.<br>
	 * * May be set by the caller before initializing the filter to forbid some<br>
	 * or all kinds of multithreading for this filter. The default is allowing<br>
	 * everything.<br>
	 * * When the filter is initialized, this field is combined using bit AND with<br>
	 * AVFilterGraph.thread_type to get the final mask used for determining<br>
	 * allowed threading types. I.e. a threading type needs to be set in both<br>
	 * to be allowed.<br>
	 * * After the filter is initialized, libavfilter sets this field to the<br>
	 * threading type that is actually used (0 for no multithreading).
	 */
	@Field(11) 
	public int thread_type() {
		return this.io.getIntField(this, 11);
	}
	/**
	 * Type of multithreading being allowed/used. A combination of<br>
	 * AVFILTER_THREAD_* flags.<br>
	 * * May be set by the caller before initializing the filter to forbid some<br>
	 * or all kinds of multithreading for this filter. The default is allowing<br>
	 * everything.<br>
	 * * When the filter is initialized, this field is combined using bit AND with<br>
	 * AVFilterGraph.thread_type to get the final mask used for determining<br>
	 * allowed threading types. I.e. a threading type needs to be set in both<br>
	 * to be allowed.<br>
	 * * After the filter is initialized, libavfilter sets this field to the<br>
	 * threading type that is actually used (0 for no multithreading).
	 */
	@Field(11) 
	public AVFilterContext thread_type(int thread_type) {
		this.io.setIntField(this, 11, thread_type);
		return this;
	}
	/**
	 * An opaque struct for libavfilter internal use.<br>
	 * C type : AVFilterInternal*
	 */
	@Field(12) 
	public Pointer<AVFilterInternal > internal() {
		return this.io.getPointerField(this, 12);
	}
	/**
	 * An opaque struct for libavfilter internal use.<br>
	 * C type : AVFilterInternal*
	 */
	@Field(12) 
	public AVFilterContext internal(Pointer<AVFilterInternal > internal) {
		this.io.setPointerField(this, 12, internal);
		return this;
	}
	/** C type : AVFilterCommand* */
	@Field(13) 
	public Pointer<AVFilterCommand > command_queue() {
		return this.io.getPointerField(this, 13);
	}
	/** C type : AVFilterCommand* */
	@Field(13) 
	public AVFilterContext command_queue(Pointer<AVFilterCommand > command_queue) {
		this.io.setPointerField(this, 13, command_queue);
		return this;
	}
	/**
	 * < enable expression string<br>
	 * C type : char*
	 */
	@Field(14) 
	public Pointer<Byte > enable_str() {
		return this.io.getPointerField(this, 14);
	}
	/**
	 * < enable expression string<br>
	 * C type : char*
	 */
	@Field(14) 
	public AVFilterContext enable_str(Pointer<Byte > enable_str) {
		this.io.setPointerField(this, 14, enable_str);
		return this;
	}
	/**
	 * < parsed expression (AVExpr*)<br>
	 * C type : void*
	 */
	@Field(15) 
	public Pointer<? > enable() {
		return this.io.getPointerField(this, 15);
	}
	/**
	 * < parsed expression (AVExpr*)<br>
	 * C type : void*
	 */
	@Field(15) 
	public AVFilterContext enable(Pointer<? > enable) {
		this.io.setPointerField(this, 15, enable);
		return this;
	}
	/**
	 * < variable values for the enable expression<br>
	 * C type : double*
	 */
	@Field(16) 
	public Pointer<Double > var_values() {
		return this.io.getPointerField(this, 16);
	}
	/**
	 * < variable values for the enable expression<br>
	 * C type : double*
	 */
	@Field(16) 
	public AVFilterContext var_values(Pointer<Double > var_values) {
		this.io.setPointerField(this, 16, var_values);
		return this;
	}
	/** < the enabled state from the last expression evaluation */
	@Field(17) 
	public int is_disabled() {
		return this.io.getIntField(this, 17);
	}
	/** < the enabled state from the last expression evaluation */
	@Field(17) 
	public AVFilterContext is_disabled(int is_disabled) {
		this.io.setIntField(this, 17, is_disabled);
		return this;
	}
	/**
	 * For filters which will create hardware frames, sets the device the<br>
	 * filter should create them in.  All other filters will ignore this field:<br>
	 * in particular, a filter which consumes or processes hardware frames will<br>
	 * instead use the hw_frames_ctx field in AVFilterLink to carry the<br>
	 * hardware context information.<br>
	 * C type : AVBufferRef*
	 */
	@Field(18) 
	public Pointer<AVBufferRef > hw_device_ctx() {
		return this.io.getPointerField(this, 18);
	}
	/**
	 * For filters which will create hardware frames, sets the device the<br>
	 * filter should create them in.  All other filters will ignore this field:<br>
	 * in particular, a filter which consumes or processes hardware frames will<br>
	 * instead use the hw_frames_ctx field in AVFilterLink to carry the<br>
	 * hardware context information.<br>
	 * C type : AVBufferRef*
	 */
	@Field(18) 
	public AVFilterContext hw_device_ctx(Pointer<AVBufferRef > hw_device_ctx) {
		this.io.setPointerField(this, 18, hw_device_ctx);
		return this;
	}
	public AVFilterContext() {
		super();
	}
	public AVFilterContext(Pointer pointer) {
		super(pointer);
	}
}
