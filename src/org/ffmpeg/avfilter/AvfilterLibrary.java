package org.ffmpeg.avfilter;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;
import org.ffmpeg.avutil.AVClass;
import org.ffmpeg.avutil.AVDictionary;
import org.ffmpeg.avutil.AVFrame;
import org.ffmpeg.avutil.AVRational;
import org.ffmpeg.avutil.AvutilLibrary.AVMediaType;
/**
 * Wrapper for library <b>avfilter</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avfilter") 
@Runtime(CRuntime.class) 
public class AvfilterLibrary {
	static {
		BridJ.register();
	}
	/** < all automatic conversions enabled */
	public static final int AVFILTER_AUTO_CONVERT_ALL = 0;
	/** < all automatic conversions disabled */
	public static final int AVFILTER_AUTO_CONVERT_NONE = -1;
	/** Do not check for format changes. */
	public static final int AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1;
	/** Immediately push the frame to the output. */
	public static final int AV_BUFFERSRC_FLAG_PUSH = 4;
	/**
	 * Keep a reference to the frame.<br>
	 * If the frame if reference-counted, create a new reference; otherwise<br>
	 * copy the frame data.
	 */
	public static final int AV_BUFFERSRC_FLAG_KEEP_REF = 8;
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil/rational.h:0</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_THREAD_SLICE = (int)(1 << 0);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final String LIBAVFILTER_IDENT = (String)"Lavfi6.31.100";
	/** <i>native declaration : libavfilter/buffersink.h</i> */
	public static final int AV_BUFFERSINK_FLAG_PEEK = (int)1;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_AVFILTER_INIT_FILTER = (boolean)(6 < 7);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE = (int)((1 << 16) | (1 << 17));
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_VERSION_MICRO = (int)100;
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_DYNAMIC_OUTPUTS = (int)(1 << 1);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_CMD_FLAG_FAST = (int)2;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_OLD_FILTER_REGISTER = (boolean)(6 < 7);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_VERSION_INT = (int)((6) << 16 | (31) << 8 | (100));
	/** <i>native declaration : libavfilter/buffersink.h</i> */
	public static final int AV_BUFFERSINK_FLAG_NO_REQUEST = (int)2;
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = (int)(1 << 16);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_DYNAMIC_INPUTS = (int)(1 << 0);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_OLD_FILTER_OPTS_ERROR = (boolean)(6 < 7);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_CMD_FLAG_ONE = (int)1;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_AVFILTER_OPEN = (boolean)(6 < 7);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_VERSION_MAJOR = (int)6;
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = (int)(1 << 17);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_NOCONST_GET_NAME = (boolean)(6 < 7);
	/**
	 * define<br>
	 * Conversion Error : 6.31.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : ./libavfilter/version.h:0</i><br>
	 * 6.31.
	 */
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final boolean FF_API_OLD_FILTER_OPTS = (boolean)(6 < 7);
	/** <i>native declaration : libavfilter/avfilter.h</i> */
	public static final int AVFILTER_FLAG_SLICE_THREADS = (int)(1 << 2);
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_VERSION_MINOR = (int)31;
	/** <i>native declaration : ./libavfilter/version.h</i> */
	public static final int LIBAVFILTER_BUILD = (int)((6) << 16 | (31) << 8 | (100));
	/**
	 * A function pointer passed to the @ref AVFilterGraph.execute callback to be<br>
	 * executed multiple times, possibly in parallel.<br>
	 * * @param ctx the filter context the job belongs to<br>
	 * @param arg an opaque parameter passed through from @ref<br>
	 *            AVFilterGraph.execute<br>
	 * @param jobnr the index of the job being executed<br>
	 * @param nb_jobs the total number of jobs<br>
	 * * @return 0 on success, a negative AVERROR on error<br>
	 * <i>native declaration : libavfilter/avfilter.h:541</i>
	 */
	public static abstract class avfilter_action_func extends Callback<avfilter_action_func > {
		public int apply(Pointer<AVFilterContext > ctx, Pointer<? > arg, int jobnr, int nb_jobs) {
			return apply(Pointer.getPeer(ctx), Pointer.getPeer(arg), jobnr, nb_jobs);
		}
		public int apply(@Ptr long ctx, @Ptr long arg, int jobnr, int nb_jobs) {
			return apply(Pointer.pointerToAddress(ctx, AVFilterContext.class), Pointer.pointerToAddress(arg), jobnr, nb_jobs);
		}
	};
	/**
	 * A function executing multiple jobs, possibly in parallel.<br>
	 * * @param ctx the filter context to which the jobs belong<br>
	 * @param func the function to be called multiple times<br>
	 * @param arg the argument to be passed to func<br>
	 * @param ret a nb_jobs-sized array to be filled with return values from each<br>
	 *            invocation of func<br>
	 * @param nb_jobs the number of jobs to execute<br>
	 * * @return 0 on success, a negative AVERROR on error<br>
	 * <i>native declaration : libavfilter/avfilter.h:552</i>
	 */
	public static abstract class avfilter_execute_func extends Callback<avfilter_execute_func > {
		public int apply(Pointer<AVFilterContext > ctx, Pointer<AvfilterLibrary.avfilter_action_func > func, Pointer<? > arg, Pointer<Integer > ret, int nb_jobs) {
			return apply(Pointer.getPeer(ctx), Pointer.getPeer(func), Pointer.getPeer(arg), Pointer.getPeer(ret), nb_jobs);
		}
		public int apply(@Ptr long ctx, @Ptr long func, @Ptr long arg, @Ptr long ret, int nb_jobs) {
			return apply(Pointer.pointerToAddress(ctx, AVFilterContext.class), Pointer.pointerToAddress(func, AvfilterLibrary.avfilter_action_func.class), Pointer.pointerToAddress(arg), Pointer.pointerToAddress(ret, Integer.class), nb_jobs);
		}
	};
	/**
	 * Return the LIBAVFILTER_VERSION_INT constant.<br>
	 * Original signature : <code>int avfilter_version()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:4</i>
	 */
	public static native int avfilter_version();
	/**
	 * Return the libavfilter build-time configuration.<br>
	 * Original signature : <code>char* avfilter_configuration()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:9</i>
	 */
	public static Pointer<Byte > avfilter__configuration() {
		return Pointer.pointerToAddress(avfilter_configuration(), Byte.class);
	}
	@Ptr 
	protected native static long avfilter_configuration();
	/**
	 * Return the libavfilter license.<br>
	 * Original signature : <code>char* avfilter_license()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:14</i>
	 */
	public static Pointer<Byte > avfilter__license() {
		return Pointer.pointerToAddress(avfilter_license(), Byte.class);
	}
	@Ptr 
	protected native static long avfilter_license();
	/**
	 * Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.<br>
	 * AVFilter.inputs/outputs).<br>
	 * Original signature : <code>int avfilter_pad_count(const AVFilterPad*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:28</i>
	 */
	public static int avfilter_pad_count(Pointer<AVFilterPad > pads) {
		return avfilter_pad_count(Pointer.getPeer(pads));
	}
	protected native static int avfilter_pad_count(@Ptr long pads);
	/**
	 * Get the name of an AVFilterPad.<br>
	 * * @param pads an array of AVFilterPads<br>
	 * @param pad_idx index of the pad in the array it; is the caller's<br>
	 *                responsibility to ensure the index is valid<br>
	 * * @return name of the pad_idx'th pad in pads<br>
	 * Original signature : <code>char* avfilter_pad_get_name(const AVFilterPad*, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:37</i>
	 */
	public static Pointer<Byte > avfilter_pad_get_name(Pointer<AVFilterPad > pads, int pad_idx) {
		return Pointer.pointerToAddress(avfilter_pad_get_name(Pointer.getPeer(pads), pad_idx), Byte.class);
	}
	@Ptr 
	protected native static long avfilter_pad_get_name(@Ptr long pads, int pad_idx);
	/**
	 * Get the type of an AVFilterPad.<br>
	 * * @param pads an array of AVFilterPads<br>
	 * @param pad_idx index of the pad in the array; it is the caller's<br>
	 *                responsibility to ensure the index is valid<br>
	 * * @return type of the pad_idx'th pad in pads<br>
	 * Original signature : <code>AVMediaType avfilter_pad_get_type(const AVFilterPad*, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:46</i>
	 */
	public static IntValuedEnum<AVMediaType > avfilter_pad_get_type(Pointer<AVFilterPad > pads, int pad_idx) {
		return FlagSet.fromValue(avfilter_pad_get_type(Pointer.getPeer(pads), pad_idx), AVMediaType.class);
	}
	protected native static int avfilter_pad_get_type(@Ptr long pads, int pad_idx);
	/**
	 * Link two filters together.<br>
	 * * @param src    the source filter<br>
	 * @param srcpad index of the output pad on the source filter<br>
	 * @param dst    the destination filter<br>
	 * @param dstpad index of the input pad on the destination filter<br>
	 * @return       zero on success<br>
	 * Original signature : <code>int avfilter_link(AVFilterContext*, unsigned, AVFilterContext*, unsigned)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:382</i>
	 */
	public static int avfilter_link(Pointer<AVFilterContext > src, int srcpad, Pointer<AVFilterContext > dst, int dstpad) {
		return avfilter_link(Pointer.getPeer(src), srcpad, Pointer.getPeer(dst), dstpad);
	}
	protected native static int avfilter_link(@Ptr long src, int srcpad, @Ptr long dst, int dstpad);
	/**
	 * Free the link in *link, and set its pointer to NULL.<br>
	 * Original signature : <code>void avfilter_link_free(AVFilterLink**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:387</i>
	 */
	public static void avfilter_link_free(Pointer<Pointer<AVFilterLink > > link) {
		avfilter_link_free(Pointer.getPeer(link));
	}
	protected native static void avfilter_link_free(@Ptr long link);
	/**
	 * Get the number of channels of a link.<br>
	 * Original signature : <code>int avfilter_link_get_channels(AVFilterLink*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:392</i>
	 */
	public static int avfilter_link_get_channels(Pointer<AVFilterLink > link) {
		return avfilter_link_get_channels(Pointer.getPeer(link));
	}
	protected native static int avfilter_link_get_channels(@Ptr long link);
	/**
	 * Set the closed field of a link.<br>
	 * @deprecated applications are not supposed to mess with links, they should<br>
	 * close the sinks.<br>
	 * Original signature : <code>void avfilter_link_set_closed(AVFilterLink*, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:399</i>
	 */
	public static void avfilter_link_set_closed(Pointer<AVFilterLink > link, int closed) {
		avfilter_link_set_closed(Pointer.getPeer(link), closed);
	}
	protected native static void avfilter_link_set_closed(@Ptr long link, int closed);
	/**
	 * Negotiate the media format, dimensions, etc of all inputs to a filter.<br>
	 * * @param filter the filter to negotiate the properties for its inputs<br>
	 * @return       zero on successful negotiation<br>
	 * Original signature : <code>int avfilter_config_links(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:406</i>
	 */
	public static int avfilter_config_links(Pointer<AVFilterContext > filter) {
		return avfilter_config_links(Pointer.getPeer(filter));
	}
	protected native static int avfilter_config_links(@Ptr long filter);
	/**
	 * Make the filter instance process a command.<br>
	 * It is recommended to use avfilter_graph_send_command().<br>
	 * Original signature : <code>int avfilter_process_command(AVFilterContext*, const char*, const char*, char*, int, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:412</i>
	 */
	public static int avfilter_process_command(Pointer<AVFilterContext > filter, Pointer<Byte > cmd, Pointer<Byte > arg, Pointer<Byte > res, int res_len, int flags) {
		return avfilter_process_command(Pointer.getPeer(filter), Pointer.getPeer(cmd), Pointer.getPeer(arg), Pointer.getPeer(res), res_len, flags);
	}
	protected native static int avfilter_process_command(@Ptr long filter, @Ptr long cmd, @Ptr long arg, @Ptr long res, int res_len, int flags);
	/**
	 * Initialize the filter system. Register all builtin filters.<br>
	 * Original signature : <code>void avfilter_register_all()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:417</i>
	 */
	public static native void avfilter_register_all();
	/**
	 * Uninitialize the filter system. Unregister all filters.<br>
	 * Original signature : <code>void avfilter_uninit()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:422</i>
	 */
	public static native void avfilter_uninit();
	/**
	 * Register a filter. This is only needed if you plan to use<br>
	 * avfilter_get_by_name later to lookup the AVFilter structure by name. A<br>
	 * filter can still by instantiated with avfilter_graph_alloc_filter even if it<br>
	 * is not registered.<br>
	 * * @param filter the filter to register<br>
	 * @return 0 if the registration was successful, a negative value<br>
	 * otherwise<br>
	 * Original signature : <code>int avfilter_register(AVFilter*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:433</i>
	 */
	public static int avfilter_register(Pointer<AVFilter > filter) {
		return avfilter_register(Pointer.getPeer(filter));
	}
	protected native static int avfilter_register(@Ptr long filter);
	/**
	 * Original signature : <code>AVFilter* avfilter_get_by_name(const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:435</i>
	 */
	public static Pointer<AVFilter > avfilter_get_by_name(Pointer<Byte > name) {
		return Pointer.pointerToAddress(avfilter_get_by_name(Pointer.getPeer(name)), AVFilter.class);
	}
	@Ptr 
	protected native static long avfilter_get_by_name(@Ptr long name);
	/**
	 * Iterate over all registered filters.<br>
	 * @return If prev is non-NULL, next registered filter after prev or NULL if<br>
	 * prev is the last filter. If prev is NULL, return the first registered filter.<br>
	 * Original signature : <code>AVFilter* avfilter_next(const AVFilter*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:442</i>
	 */
	public static Pointer<AVFilter > avfilter_next(Pointer<AVFilter > prev) {
		return Pointer.pointerToAddress(avfilter_next(Pointer.getPeer(prev)), AVFilter.class);
	}
	@Ptr 
	protected native static long avfilter_next(@Ptr long prev);
	/**
	 * If filter is NULL, returns a pointer to the first registered filter pointer,<br>
	 * if filter is non-NULL, returns the next pointer after filter.<br>
	 * If the returned pointer points to NULL, the last registered filter<br>
	 * was already reached.<br>
	 * @deprecated use avfilter_next()<br>
	 * Original signature : <code>AVFilter** av_filter_next(AVFilter**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:451</i>
	 */
	public static Pointer<Pointer<AVFilter > > av_filter_next(Pointer<Pointer<AVFilter > > filter) {
		return Pointer.pointerToAddress(av_filter_next(Pointer.getPeer(filter)), DefaultParameterizedType.paramType(Pointer.class, AVFilter.class));
	}
	@Ptr 
	protected native static long av_filter_next(@Ptr long filter);
	/**
	 * Create a filter instance.<br>
	 * * @param filter_ctx put here a pointer to the created filter context<br>
	 * on success, NULL on failure<br>
	 * @param filter    the filter to create an instance of<br>
	 * @param inst_name Name to give to the new instance. Can be NULL for none.<br>
	 * @return >= 0 in case of success, a negative error code otherwise<br>
	 * @deprecated use avfilter_graph_alloc_filter() instead<br>
	 * Original signature : <code>int avfilter_open(AVFilterContext**, AVFilter*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:462</i>
	 */
	public static int avfilter_open(Pointer<Pointer<AVFilterContext > > filter_ctx, Pointer<AVFilter > filter, Pointer<Byte > inst_name) {
		return avfilter_open(Pointer.getPeer(filter_ctx), Pointer.getPeer(filter), Pointer.getPeer(inst_name));
	}
	protected native static int avfilter_open(@Ptr long filter_ctx, @Ptr long filter, @Ptr long inst_name);
	/**
	 * Initialize a filter.<br>
	 * * @param filter the filter to initialize<br>
	 * @param args   A string of parameters to use when initializing the filter.<br>
	 *               The format and meaning of this string varies by filter.<br>
	 * @param opaque Any extra non-string data needed by the filter. The meaning<br>
	 *               of this parameter varies by filter.<br>
	 * @return       zero on success<br>
	 * Original signature : <code>int avfilter_init_filter(AVFilterContext*, const char*, void*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:473</i>
	 */
	public static int avfilter_init_filter(Pointer<AVFilterContext > filter, Pointer<Byte > args, Pointer<? > opaque) {
		return avfilter_init_filter(Pointer.getPeer(filter), Pointer.getPeer(args), Pointer.getPeer(opaque));
	}
	protected native static int avfilter_init_filter(@Ptr long filter, @Ptr long args, @Ptr long opaque);
	/**
	 * Initialize a filter with the supplied parameters.<br>
	 * * @param ctx  uninitialized filter context to initialize<br>
	 * @param args Options to initialize the filter with. This must be a<br>
	 *             ':'-separated list of options in the 'key=value' form.<br>
	 *             May be NULL if the options have been set directly using the<br>
	 *             AVOptions API or there are no options that need to be set.<br>
	 * @return 0 on success, a negative AVERROR on failure<br>
	 * Original signature : <code>int avfilter_init_str(AVFilterContext*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:484</i>
	 */
	public static int avfilter_init_str(Pointer<AVFilterContext > ctx, Pointer<Byte > args) {
		return avfilter_init_str(Pointer.getPeer(ctx), Pointer.getPeer(args));
	}
	protected native static int avfilter_init_str(@Ptr long ctx, @Ptr long args);
	/**
	 * Initialize a filter with the supplied dictionary of options.<br>
	 * * @param ctx     uninitialized filter context to initialize<br>
	 * @param options An AVDictionary filled with options for this filter. On<br>
	 *                return this parameter will be destroyed and replaced with<br>
	 *                a dict containing options that were not found. This dictionary<br>
	 *                must be freed by the caller.<br>
	 *                May be NULL, then this function is equivalent to<br>
	 *                avfilter_init_str() with the second parameter set to NULL.<br>
	 * @return 0 on success, a negative AVERROR on failure<br>
	 * * @note This function and avfilter_init_str() do essentially the same thing,<br>
	 * the difference is in manner in which the options are passed. It is up to the<br>
	 * calling code to choose whichever is more preferable. The two functions also<br>
	 * behave differently when some of the provided options are not declared as<br>
	 * supported by the filter. In such a case, avfilter_init_str() will fail, but<br>
	 * this function will leave those extra options in the options AVDictionary and<br>
	 * continue as usual.<br>
	 * Original signature : <code>int avfilter_init_dict(AVFilterContext*, AVDictionary**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:504</i>
	 */
	public static int avfilter_init_dict(Pointer<AVFilterContext > ctx, Pointer<Pointer<AVDictionary > > options) {
		return avfilter_init_dict(Pointer.getPeer(ctx), Pointer.getPeer(options));
	}
	protected native static int avfilter_init_dict(@Ptr long ctx, @Ptr long options);
	/**
	 * Free a filter context. This will also remove the filter from its<br>
	 * filtergraph's list of filters.<br>
	 * * @param filter the filter to free<br>
	 * Original signature : <code>void avfilter_free(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:511</i>
	 */
	public static void avfilter_free(Pointer<AVFilterContext > filter) {
		avfilter_free(Pointer.getPeer(filter));
	}
	protected native static void avfilter_free(@Ptr long filter);
	/**
	 * Insert a filter in the middle of an existing link.<br>
	 * * @param link the link into which the filter should be inserted<br>
	 * @param filt the filter to be inserted<br>
	 * @param filt_srcpad_idx the input pad on the filter to connect<br>
	 * @param filt_dstpad_idx the output pad on the filter to connect<br>
	 * @return     zero on success<br>
	 * Original signature : <code>int avfilter_insert_filter(AVFilterLink*, AVFilterContext*, unsigned, unsigned)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:521</i>
	 */
	public static int avfilter_insert_filter(Pointer<AVFilterLink > link, Pointer<AVFilterContext > filt, int filt_srcpad_idx, int filt_dstpad_idx) {
		return avfilter_insert_filter(Pointer.getPeer(link), Pointer.getPeer(filt), filt_srcpad_idx, filt_dstpad_idx);
	}
	protected native static int avfilter_insert_filter(@Ptr long link, @Ptr long filt, int filt_srcpad_idx, int filt_dstpad_idx);
	/**
	 * @return AVClass for AVFilterContext.<br>
	 * * @see av_opt_find().<br>
	 * Original signature : <code>AVClass* avfilter_get_class()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:527</i>
	 */
	public static Pointer<AVClass > avfilter__get_class() {
		return Pointer.pointerToAddress(avfilter_get_class(), AVClass.class);
	}
	@Ptr 
	protected native static long avfilter_get_class();
	/**
	 * Allocate a filter graph.<br>
	 * * @return the allocated filter graph on success or NULL.<br>
	 * Original signature : <code>AVFilterGraph* avfilter_graph_alloc()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:608</i>
	 */
	public static Pointer<AVFilterGraph > avfilter__graph_alloc() {
		return Pointer.pointerToAddress(avfilter_graph_alloc(), AVFilterGraph.class);
	}
	@Ptr 
	protected native static long avfilter_graph_alloc();
	/**
	 * Create a new filter instance in a filter graph.<br>
	 * * @param graph graph in which the new filter will be used<br>
	 * @param filter the filter to create an instance of<br>
	 * @param name Name to give to the new instance (will be copied to<br>
	 *             AVFilterContext.name). This may be used by the caller to identify<br>
	 *             different filters, libavfilter itself assigns no semantics to<br>
	 *             this parameter. May be NULL.<br>
	 * * @return the context of the newly created filter instance (note that it is<br>
	 *         also retrievable directly through AVFilterGraph.filters or with<br>
	 *         avfilter_graph_get_filter()) on success or NULL on failure.<br>
	 * Original signature : <code>AVFilterContext* avfilter_graph_alloc_filter(AVFilterGraph*, const AVFilter*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:622</i>
	 */
	public static Pointer<AVFilterContext > avfilter_graph_alloc_filter(Pointer<AVFilterGraph > graph, Pointer<AVFilter > filter, Pointer<Byte > name) {
		return Pointer.pointerToAddress(avfilter_graph_alloc_filter(Pointer.getPeer(graph), Pointer.getPeer(filter), Pointer.getPeer(name)), AVFilterContext.class);
	}
	@Ptr 
	protected native static long avfilter_graph_alloc_filter(@Ptr long graph, @Ptr long filter, @Ptr long name);
	/**
	 * Get a filter instance identified by instance name from graph.<br>
	 * * @param graph filter graph to search through.<br>
	 * @param name filter instance name (should be unique in the graph).<br>
	 * @return the pointer to the found filter instance or NULL if it<br>
	 * cannot be found.<br>
	 * Original signature : <code>AVFilterContext* avfilter_graph_get_filter(AVFilterGraph*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:631</i>
	 */
	public static Pointer<AVFilterContext > avfilter_graph_get_filter(Pointer<AVFilterGraph > graph, Pointer<Byte > name) {
		return Pointer.pointerToAddress(avfilter_graph_get_filter(Pointer.getPeer(graph), Pointer.getPeer(name)), AVFilterContext.class);
	}
	@Ptr 
	protected native static long avfilter_graph_get_filter(@Ptr long graph, @Ptr long name);
	/**
	 * Add an existing filter instance to a filter graph.<br>
	 * * @param graphctx  the filter graph<br>
	 * @param filter the filter to be added<br>
	 * * @deprecated use avfilter_graph_alloc_filter() to allocate a filter in a<br>
	 * filter graph<br>
	 * Original signature : <code>int avfilter_graph_add_filter(AVFilterGraph*, AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:640</i>
	 */
	public static int avfilter_graph_add_filter(Pointer<AVFilterGraph > graphctx, Pointer<AVFilterContext > filter) {
		return avfilter_graph_add_filter(Pointer.getPeer(graphctx), Pointer.getPeer(filter));
	}
	protected native static int avfilter_graph_add_filter(@Ptr long graphctx, @Ptr long filter);
	/**
	 * Create and add a filter instance into an existing graph.<br>
	 * The filter instance is created from the filter filt and inited<br>
	 * with the parameters args and opaque.<br>
	 * * In case of success put in *filt_ctx the pointer to the created<br>
	 * filter instance, otherwise set *filt_ctx to NULL.<br>
	 * * @param name the instance name to give to the created filter instance<br>
	 * @param graph_ctx the filter graph<br>
	 * @return a negative AVERROR error code in case of failure, a non<br>
	 * negative value otherwise<br>
	 * Original signature : <code>int avfilter_graph_create_filter(AVFilterContext**, const AVFilter*, const char*, const char*, void*, AVFilterGraph*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:653</i>
	 */
	public static int avfilter_graph_create_filter(Pointer<Pointer<AVFilterContext > > filt_ctx, Pointer<AVFilter > filt, Pointer<Byte > name, Pointer<Byte > args, Pointer<? > opaque, Pointer<AVFilterGraph > graph_ctx) {
		return avfilter_graph_create_filter(Pointer.getPeer(filt_ctx), Pointer.getPeer(filt), Pointer.getPeer(name), Pointer.getPeer(args), Pointer.getPeer(opaque), Pointer.getPeer(graph_ctx));
	}
	protected native static int avfilter_graph_create_filter(@Ptr long filt_ctx, @Ptr long filt, @Ptr long name, @Ptr long args, @Ptr long opaque, @Ptr long graph_ctx);
	/**
	 * Enable or disable automatic format conversion inside the graph.<br>
	 * * Note that format conversion can still happen inside explicitly inserted<br>
	 * scale and aresample filters.<br>
	 * * @param flags  any of the AVFILTER_AUTO_CONVERT_* constants<br>
	 * Original signature : <code>void avfilter_graph_set_auto_convert(AVFilterGraph*, unsigned)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:661</i>
	 */
	public static void avfilter_graph_set_auto_convert(Pointer<AVFilterGraph > graph, int flags) {
		avfilter_graph_set_auto_convert(Pointer.getPeer(graph), flags);
	}
	protected native static void avfilter_graph_set_auto_convert(@Ptr long graph, int flags);
	/**
	 * Check validity and configure all the links and formats in the graph.<br>
	 * * @param graphctx the filter graph<br>
	 * @param log_ctx context used for logging<br>
	 * @return >= 0 in case of success, a negative AVERROR code otherwise<br>
	 * Original signature : <code>int avfilter_graph_config(AVFilterGraph*, void*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:673</i>
	 */
	public static int avfilter_graph_config(Pointer<AVFilterGraph > graphctx, Pointer<? > log_ctx) {
		return avfilter_graph_config(Pointer.getPeer(graphctx), Pointer.getPeer(log_ctx));
	}
	protected native static int avfilter_graph_config(@Ptr long graphctx, @Ptr long log_ctx);
	/**
	 * Free a graph, destroy its links, and set *graph to NULL.<br>
	 * If *graph is NULL, do nothing.<br>
	 * Original signature : <code>void avfilter_graph_free(AVFilterGraph**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:679</i>
	 */
	public static void avfilter_graph_free(Pointer<Pointer<AVFilterGraph > > graph) {
		avfilter_graph_free(Pointer.getPeer(graph));
	}
	protected native static void avfilter_graph_free(@Ptr long graph);
	/**
	 * Allocate a single AVFilterInOut entry.<br>
	 * Must be freed with avfilter_inout_free().<br>
	 * @return allocated AVFilterInOut on success, NULL on failure.<br>
	 * Original signature : <code>AVFilterInOut* avfilter_inout_alloc()</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:704</i>
	 */
	public static Pointer<AVFilterInOut > avfilter__inout_alloc() {
		return Pointer.pointerToAddress(avfilter_inout_alloc(), AVFilterInOut.class);
	}
	@Ptr 
	protected native static long avfilter_inout_alloc();
	/**
	 * Free the supplied list of AVFilterInOut and set *inout to NULL.<br>
	 * If *inout is NULL, do nothing.<br>
	 * Original signature : <code>void avfilter_inout_free(AVFilterInOut**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:710</i>
	 */
	public static void avfilter_inout_free(Pointer<Pointer<AVFilterInOut > > inout) {
		avfilter_inout_free(Pointer.getPeer(inout));
	}
	protected native static void avfilter_inout_free(@Ptr long inout);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * * @note The caller must provide the lists of inputs and outputs,<br>
	 * which therefore must be known before calling the function.<br>
	 * * @note The inputs parameter describes inputs of the already existing<br>
	 * part of the graph; i.e. from the point of view of the newly created<br>
	 * part, they are outputs. Similarly the outputs parameter describes<br>
	 * outputs of the already existing filters, which are provided as<br>
	 * inputs to the parsed filters.<br>
	 * * @param graph   the filter graph where to link the parsed graph context<br>
	 * @param filters string to be parsed<br>
	 * @param inputs  linked list to the inputs of the graph<br>
	 * @param outputs linked list to the outputs of the graph<br>
	 * @return zero on success, a negative AVERROR code on error<br>
	 * Original signature : <code>int avfilter_graph_parse(AVFilterGraph*, const char*, AVFilterInOut*, AVFilterInOut*, void*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:727</i>
	 */
	public static int avfilter_graph_parse(Pointer<AVFilterGraph > graph, Pointer<Byte > filters, Pointer<AVFilterInOut > inputs, Pointer<AVFilterInOut > outputs, Pointer<? > log_ctx) {
		return avfilter_graph_parse(Pointer.getPeer(graph), Pointer.getPeer(filters), Pointer.getPeer(inputs), Pointer.getPeer(outputs), Pointer.getPeer(log_ctx));
	}
	protected native static int avfilter_graph_parse(@Ptr long graph, @Ptr long filters, @Ptr long inputs, @Ptr long outputs, @Ptr long log_ctx);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * * In the graph filters description, if the input label of the first<br>
	 * filter is not specified, "in" is assumed; if the output label of<br>
	 * the last filter is not specified, "out" is assumed.<br>
	 * * @param graph   the filter graph where to link the parsed graph context<br>
	 * @param filters string to be parsed<br>
	 * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.<br>
	 *                If non-NULL, *inputs is updated to contain the list of open inputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.<br>
	 *                If non-NULL, *outputs is updated to contain the list of open outputs<br>
	 *                after the parsing, should be freed with avfilter_inout_free().<br>
	 * @return non negative on success, a negative AVERROR code on error<br>
	 * Original signature : <code>int avfilter_graph_parse_ptr(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**, void*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:744</i>
	 */
	public static int avfilter_graph_parse_ptr(Pointer<AVFilterGraph > graph, Pointer<Byte > filters, Pointer<Pointer<AVFilterInOut > > inputs, Pointer<Pointer<AVFilterInOut > > outputs, Pointer<? > log_ctx) {
		return avfilter_graph_parse_ptr(Pointer.getPeer(graph), Pointer.getPeer(filters), Pointer.getPeer(inputs), Pointer.getPeer(outputs), Pointer.getPeer(log_ctx));
	}
	protected native static int avfilter_graph_parse_ptr(@Ptr long graph, @Ptr long filters, @Ptr long inputs, @Ptr long outputs, @Ptr long log_ctx);
	/**
	 * Add a graph described by a string to a graph.<br>
	 * * @param[in]  graph   the filter graph where to link the parsed graph context<br>
	 * @param[in]  filters string to be parsed<br>
	 * @param[out] inputs  a linked list of all free (unlinked) inputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed<br>
	 *                     by the caller using avfilter_inout_free().<br>
	 * @param[out] outputs a linked list of all free (unlinked) outputs of the<br>
	 *                     parsed graph will be returned here. It is to be freed by the<br>
	 *                     caller using avfilter_inout_free().<br>
	 * @return zero on success, a negative AVERROR code on error<br>
	 * * @note This function returns the inputs and outputs that are left<br>
	 * unlinked after parsing the graph and the caller then deals with<br>
	 * them.<br>
	 * @note This function makes no reference whatsoever to already<br>
	 * existing parts of the graph and the inputs parameter will on return<br>
	 * contain inputs of the newly parsed part of the graph.  Analogously<br>
	 * the outputs parameter will contain outputs of the newly created<br>
	 * filters.<br>
	 * Original signature : <code>int avfilter_graph_parse2(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:766</i>
	 */
	public static int avfilter_graph_parse2(Pointer<AVFilterGraph > graph, Pointer<Byte > filters, Pointer<Pointer<AVFilterInOut > > inputs, Pointer<Pointer<AVFilterInOut > > outputs) {
		return avfilter_graph_parse2(Pointer.getPeer(graph), Pointer.getPeer(filters), Pointer.getPeer(inputs), Pointer.getPeer(outputs));
	}
	protected native static int avfilter_graph_parse2(@Ptr long graph, @Ptr long filters, @Ptr long inputs, @Ptr long outputs);
	/**
	 * Send a command to one or more filter instances.<br>
	 * * @param graph  the filter graph<br>
	 * @param target the filter(s) to which the command should be sent<br>
	 *               "all" sends to all filters<br>
	 *               otherwise it can be a filter or filter instance name<br>
	 *               which will send the command to all matching filters.<br>
	 * @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only<br>
	 * @param arg    the argument for the command<br>
	 * @param res    a buffer with size res_size where the filter(s) can return a response.<br>
	 * * @returns >=0 on success otherwise an error code.<br>
	 *              AVERROR(ENOSYS) on unsupported commands<br>
	 * Original signature : <code>int avfilter_graph_send_command(AVFilterGraph*, const char*, const char*, const char*, char*, int, int)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:781</i>
	 */
	public static int avfilter_graph_send_command(Pointer<AVFilterGraph > graph, Pointer<Byte > target, Pointer<Byte > cmd, Pointer<Byte > arg, Pointer<Byte > res, int res_len, int flags) {
		return avfilter_graph_send_command(Pointer.getPeer(graph), Pointer.getPeer(target), Pointer.getPeer(cmd), Pointer.getPeer(arg), Pointer.getPeer(res), res_len, flags);
	}
	protected native static int avfilter_graph_send_command(@Ptr long graph, @Ptr long target, @Ptr long cmd, @Ptr long arg, @Ptr long res, int res_len, int flags);
	/**
	 * Queue a command for one or more filter instances.<br>
	 * * @param graph  the filter graph<br>
	 * @param target the filter(s) to which the command should be sent<br>
	 *               "all" sends to all filters<br>
	 *               otherwise it can be a filter or filter instance name<br>
	 *               which will send the command to all matching filters.<br>
	 * @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only<br>
	 * @param arg    the argument for the command<br>
	 * @param ts     time at which the command should be sent to the filter<br>
	 * * @note As this executes commands after this function returns, no return code<br>
	 *       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.<br>
	 * Original signature : <code>int avfilter_graph_queue_command(AVFilterGraph*, const char*, const char*, const char*, int, double)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:796</i>
	 */
	public static int avfilter_graph_queue_command(Pointer<AVFilterGraph > graph, Pointer<Byte > target, Pointer<Byte > cmd, Pointer<Byte > arg, int flags, double ts) {
		return avfilter_graph_queue_command(Pointer.getPeer(graph), Pointer.getPeer(target), Pointer.getPeer(cmd), Pointer.getPeer(arg), flags, ts);
	}
	protected native static int avfilter_graph_queue_command(@Ptr long graph, @Ptr long target, @Ptr long cmd, @Ptr long arg, int flags, double ts);
	/**
	 * Dump a graph into a human-readable string representation.<br>
	 * * @param graph    the graph to dump<br>
	 * @param options  formatting options; currently ignored<br>
	 * @return  a string, or NULL in case of memory allocation failure;<br>
	 *          the string must be freed using av_free<br>
	 * Original signature : <code>char* avfilter_graph_dump(AVFilterGraph*, const char*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:805</i>
	 */
	public static Pointer<Byte > avfilter_graph_dump(Pointer<AVFilterGraph > graph, Pointer<Byte > options) {
		return Pointer.pointerToAddress(avfilter_graph_dump(Pointer.getPeer(graph), Pointer.getPeer(options)), Byte.class);
	}
	@Ptr 
	protected native static long avfilter_graph_dump(@Ptr long graph, @Ptr long options);
	/**
	 * Request a frame on the oldest sink link.<br>
	 * * If the request returns AVERROR_EOF, try the next.<br>
	 * * Note that this function is not meant to be the sole scheduling mechanism<br>
	 * of a filtergraph, only a convenience function to help drain a filtergraph<br>
	 * in a balanced way under normal circumstances.<br>
	 * * Also note that AVERROR_EOF does not mean that frames did not arrive on<br>
	 * some of the sinks during the process.<br>
	 * When there are multiple sink links, in case the requested link<br>
	 * returns an EOF, this may cause a filter to flush pending frames<br>
	 * which are sent to another sink link, although unrequested.<br>
	 * * @return  the return value of ff_request_frame(),<br>
	 *          or AVERROR_EOF if all links returned AVERROR_EOF<br>
	 * Original signature : <code>int avfilter_graph_request_oldest(AVFilterGraph*)</code><br>
	 * <i>native declaration : libavfilter/avfilter.h:821</i>
	 */
	public static int avfilter_graph_request_oldest(Pointer<AVFilterGraph > graph) {
		return avfilter_graph_request_oldest(Pointer.getPeer(graph));
	}
	protected native static int avfilter_graph_request_oldest(@Ptr long graph);
	/**
	 * Get a frame with filtered data from sink and put it in frame.<br>
	 * * @param ctx    pointer to a buffersink or abuffersink filter context.<br>
	 * @param frame  pointer to an allocated frame that will be filled with data.<br>
	 *               The data must be freed using av_frame_unref() / av_frame_free()<br>
	 * @param flags  a combination of AV_BUFFERSINK_FLAG_* flags<br>
	 * * @return  >= 0 in for success, a negative AVERROR code for failure.<br>
	 * Original signature : <code>int av_buffersink_get_frame_flags(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:9</i>
	 */
	public static int av_buffersink_get_frame_flags(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame, int flags) {
		return av_buffersink_get_frame_flags(Pointer.getPeer(ctx), Pointer.getPeer(frame), flags);
	}
	protected native static int av_buffersink_get_frame_flags(@Ptr long ctx, @Ptr long frame, int flags);
	/**
	 * Create an AVBufferSinkParams structure.<br>
	 * * Must be freed with av_free().<br>
	 * Original signature : <code>AVBufferSinkParams* av_buffersink_params_alloc()</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:22</i>
	 */
	public static Pointer<AVBufferSinkParams > av__buffersink_params_alloc() {
		return Pointer.pointerToAddress(av_buffersink_params_alloc(), AVBufferSinkParams.class);
	}
	@Ptr 
	protected native static long av_buffersink_params_alloc();
	/**
	 * Create an AVABufferSinkParams structure.<br>
	 * * Must be freed with av_free().<br>
	 * Original signature : <code>AVABufferSinkParams* av_abuffersink_params_alloc()</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:43</i>
	 */
	public static Pointer<AVABufferSinkParams > av__abuffersink_params_alloc() {
		return Pointer.pointerToAddress(av_abuffersink_params_alloc(), AVABufferSinkParams.class);
	}
	@Ptr 
	protected native static long av_abuffersink_params_alloc();
	/**
	 * Set the frame size for an audio buffer sink.<br>
	 * * All calls to av_buffersink_get_buffer_ref will return a buffer with<br>
	 * exactly the specified number of samples, or AVERROR(EAGAIN) if there is<br>
	 * not enough. The last buffer at EOF will be padded with 0.<br>
	 * Original signature : <code>void av_buffersink_set_frame_size(AVFilterContext*, unsigned)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:51</i>
	 */
	public static void av_buffersink_set_frame_size(Pointer<AVFilterContext > ctx, int frame_size) {
		av_buffersink_set_frame_size(Pointer.getPeer(ctx), frame_size);
	}
	protected native static void av_buffersink_set_frame_size(@Ptr long ctx, int frame_size);
	/**
	 * Get the frame rate of the input.<br>
	 * Original signature : <code>AVRational av_buffersink_get_frame_rate(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:56</i>
	 */
	public static AVRational av_buffersink_get_frame_rate(Pointer<AVFilterContext > ctx) {
		return av_buffersink_get_frame_rate(Pointer.getPeer(ctx));
	}
	protected native static AVRational av_buffersink_get_frame_rate(@Ptr long ctx);
	/**
	 * Get a frame with filtered data from sink and put it in frame.<br>
	 * * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.<br>
	 * @param frame pointer to an allocated frame that will be filled with data.<br>
	 *              The data must be freed using av_frame_unref() / av_frame_free()<br>
	 * * @return<br>
	 *         - >= 0 if a frame was successfully returned.<br>
	 *         - AVERROR(EAGAIN) if no frames are available at this point; more<br>
	 *           input frames must be added to the filtergraph to get more output.<br>
	 *         - AVERROR_EOF if there will be no more output frames on this sink.<br>
	 *         - A different negative AVERROR code in other failure cases.<br>
	 * Original signature : <code>int av_buffersink_get_frame(AVFilterContext*, AVFrame*)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:70</i>
	 */
	public static int av_buffersink_get_frame(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame) {
		return av_buffersink_get_frame(Pointer.getPeer(ctx), Pointer.getPeer(frame));
	}
	protected native static int av_buffersink_get_frame(@Ptr long ctx, @Ptr long frame);
	/**
	 * Same as av_buffersink_get_frame(), but with the ability to specify the number<br>
	 * of samples read. This function is less efficient than<br>
	 * av_buffersink_get_frame(), because it copies the data around.<br>
	 * * @param ctx pointer to a context of the abuffersink AVFilter.<br>
	 * @param frame pointer to an allocated frame that will be filled with data.<br>
	 *              The data must be freed using av_frame_unref() / av_frame_free()<br>
	 *              frame will contain exactly nb_samples audio samples, except at<br>
	 *              the end of stream, when it can contain less than nb_samples.<br>
	 * * @return The return codes have the same meaning as for<br>
	 *         av_buffersink_get_samples().<br>
	 * * @warning do not mix this function with av_buffersink_get_frame(). Use only one or<br>
	 * the other with a single sink, not both.<br>
	 * Original signature : <code>int av_buffersink_get_samples(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter/buffersink.h:86</i>
	 */
	public static int av_buffersink_get_samples(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame, int nb_samples) {
		return av_buffersink_get_samples(Pointer.getPeer(ctx), Pointer.getPeer(frame), nb_samples);
	}
	protected native static int av_buffersink_get_samples(@Ptr long ctx, @Ptr long frame, int nb_samples);
	/**
	 * Get the number of failed requests.<br>
	 * * A failed request is when the request_frame method is called while no<br>
	 * frame is present in the buffer.<br>
	 * The number is reset when a frame is added.<br>
	 * Original signature : <code>int av_buffersrc_get_nb_failed_requests(AVFilterContext*)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:19</i>
	 */
	public static int av_buffersrc_get_nb_failed_requests(Pointer<AVFilterContext > buffer_src) {
		return av_buffersrc_get_nb_failed_requests(Pointer.getPeer(buffer_src));
	}
	protected native static int av_buffersrc_get_nb_failed_requests(@Ptr long buffer_src);
	/**
	 * Original signature : <code>int av_buffersrc_write_frame(AVFilterContext*, const AVFrame*)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:21</i>
	 */
	public static int av_buffersrc_write_frame(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame) {
		return av_buffersrc_write_frame(Pointer.getPeer(ctx), Pointer.getPeer(frame));
	}
	protected native static int av_buffersrc_write_frame(@Ptr long ctx, @Ptr long frame);
	/**
	 * Original signature : <code>int av_buffersrc_add_frame(AVFilterContext*, AVFrame*)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:23</i>
	 */
	public static int av_buffersrc_add_frame(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame) {
		return av_buffersrc_add_frame(Pointer.getPeer(ctx), Pointer.getPeer(frame));
	}
	protected native static int av_buffersrc_add_frame(@Ptr long ctx, @Ptr long frame);
	/**
	 * Original signature : <code>int av_buffersrc_add_frame_flags(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : libavfilter/buffersrc.h:25</i>
	 */
	public static int av_buffersrc_add_frame_flags(Pointer<AVFilterContext > buffer_src, Pointer<AVFrame > frame, int flags) {
		return av_buffersrc_add_frame_flags(Pointer.getPeer(buffer_src), Pointer.getPeer(frame), flags);
	}
	protected native static int av_buffersrc_add_frame_flags(@Ptr long buffer_src, @Ptr long frame, int flags);
	public int dummy() {
		try {
			return (int)BridJ.getNativeLibrary("avfilter").getSymbolPointer("dummy").as(int.class).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	public AvfilterLibrary dummy(int dummy) {
		try {
			{
				BridJ.getNativeLibrary("avfilter").getSymbolPointer("dummy").as(int.class).set(dummy);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** Undefined type */
	public static interface AVFilterChannelLayouts {
		
	};
}
