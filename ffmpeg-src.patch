diff -pruN generated/org/ffmpeg/avcodec/AVCodecContext.java src/org/ffmpeg/avcodec/AVCodecContext.java
--- generated/org/ffmpeg/avcodec/AVCodecContext.java	2021-06-15 09:23:37.523199388 +0200
+++ src/org/ffmpeg/avcodec/AVCodecContext.java	2021-06-15 09:24:07.395078694 +0200
@@ -9,6 +9,7 @@ import org.bridj.ann.CLong;
 import org.bridj.ann.Field;
 import org.bridj.ann.Library;
 import org.bridj.ann.Ptr;
+import org.bridj.ann.Struct;
 import org.ffmpeg.avcodec.AvcodecLibrary.AVAudioServiceType;
 import org.ffmpeg.avcodec.AvcodecLibrary.AVCodecID;
 import org.ffmpeg.avcodec.AvcodecLibrary.AVDiscard;
@@ -25,6 +26,7 @@ import org.ffmpeg.avutil.AvutilLibrary.A
 import org.ffmpeg.avutil.AvutilLibrary.AVMediaType;
 import org.ffmpeg.avutil.AvutilLibrary.AVPixelFormat;
 import org.ffmpeg.avutil.AvutilLibrary.AVSampleFormat;
+import org.ffmpeg.util.AlignmentCustomizer;
 /**
  * <i>native declaration : ./libavcodec/avcodec.h:1391</i><br>
  * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
@@ -4050,9 +4052,11 @@ public class AVCodecContext extends Stru
 			return apply(Pointer.pointerToAddress(s, AVCodecContext.class), Pointer.pointerToAddress(pkt, AVPacket.class), flags);
 		}
 	};
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVCodecContext() {
 		super();
 	}
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVCodecContext(Pointer pointer) {
 		super(pointer);
 	}
diff -pruN generated/org/ffmpeg/avcodec/AvcodecLibrary.java src/org/ffmpeg/avcodec/AvcodecLibrary.java
--- generated/org/ffmpeg/avcodec/AvcodecLibrary.java	2021-06-15 09:23:38.243196474 +0200
+++ src/org/ffmpeg/avcodec/AvcodecLibrary.java	2021-06-15 13:21:32.785290705 +0200
@@ -1809,11 +1809,11 @@ public class AvcodecLibrary {
 	 * Original signature : <code>AVCodecParameters* avcodec_parameters_alloc()</code><br>
 	 * <i>native declaration : ./libavcodec/codec_par.h:143</i>
 	 */
-	public static Pointer<AVCodecParameters > avcodec_parameters_alloc() {
-		return Pointer.pointerToAddress(avcodec_parameters_alloc$2(), AVCodecParameters.class);
+	public static Pointer<AVCodecParameters > avcodec__parameters_alloc() {
+		return Pointer.pointerToAddress(avcodec_parameters_alloc(), AVCodecParameters.class);
 	}
 	@Ptr 
-	protected native static long avcodec_parameters_alloc$2();
+	protected native static long avcodec_parameters_alloc();
 	/**
 	 * Free an AVCodecParameters instance and everything associated with it and<br>
 	 * write NULL to the supplied pointer.<br>
@@ -1845,11 +1845,11 @@ public class AvcodecLibrary {
 	 * Original signature : <code>AVPacket* av_packet_alloc()</code><br>
 	 * <i>native declaration : ./libavcodec/packet.h:325</i>
 	 */
-	public static Pointer<AVPacket > av_packet_alloc() {
-		return Pointer.pointerToAddress(av_packet_alloc$2(), AVPacket.class);
+	public static Pointer<AVPacket > av_packet__alloc() {
+		return Pointer.pointerToAddress(av_packet_alloc(), AVPacket.class);
 	}
 	@Ptr 
-	protected native static long av_packet_alloc$2();
+	protected native static long av_packet_alloc();
 	/**
 	 * Create a new packet that references the same data as src.<br>
 	 * * This is a shortcut for av_packet_alloc()+av_packet_ref().<br>
@@ -2307,11 +2307,11 @@ public class AvcodecLibrary {
 	 * Original signature : <code>AVClass* av_bsf_get_class()</code><br>
 	 * <i>native declaration : ./libavcodec/bsf.h:165</i>
 	 */
-	public static Pointer<AVClass > av_bsf_get_class() {
-		return Pointer.pointerToAddress(av_bsf_get_class$2(), AVClass.class);
+	public static Pointer<AVClass > av_bsf__get_class() {
+		return Pointer.pointerToAddress(av_bsf_get_class(), AVClass.class);
 	}
 	@Ptr 
-	protected native static long av_bsf_get_class$2();
+	protected native static long av_bsf_get_class();
 	/**
 	 * Allocate empty list of bitstream filters.<br>
 	 * The list must be later freed by av_bsf_list_free()<br>
@@ -2320,11 +2320,11 @@ public class AvcodecLibrary {
 	 * Original signature : <code>AVBSFList* av_bsf_list_alloc()</code><br>
 	 * <i>native declaration : ./libavcodec/bsf.h:178</i>
 	 */
-	public static Pointer<AvcodecLibrary.AVBSFList > av_bsf_list_alloc() {
-		return Pointer.pointerToAddress(av_bsf_list_alloc$2(), AvcodecLibrary.AVBSFList.class);
+	public static Pointer<AvcodecLibrary.AVBSFList > av_bsf__list_alloc() {
+		return Pointer.pointerToAddress(av_bsf_list_alloc(), AvcodecLibrary.AVBSFList.class);
 	}
 	@Ptr 
-	protected native static long av_bsf_list_alloc$2();
+	protected native static long av_bsf_list_alloc();
 	/**
 	 * Free list of bitstream filters.<br>
 	 * * @param lst Pointer to pointer returned by av_bsf_list_alloc()<br>
@@ -2652,21 +2652,21 @@ public class AvcodecLibrary {
 	 * Original signature : <code>char* avcodec_configuration()</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:1632</i>
 	 */
-	public static Pointer<Byte > avcodec_configuration() {
-		return Pointer.pointerToAddress(avcodec_configuration$2(), Byte.class);
+	public static Pointer<Byte > avcodec__configuration() {
+		return Pointer.pointerToAddress(avcodec_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avcodec_configuration$2();
+	protected native static long avcodec_configuration();
 	/**
 	 * Return the libavcodec license.<br>
 	 * Original signature : <code>char* avcodec_license()</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:1637</i>
 	 */
-	public static Pointer<Byte > avcodec_license() {
-		return Pointer.pointerToAddress(avcodec_license$2(), Byte.class);
+	public static Pointer<Byte > avcodec__license() {
+		return Pointer.pointerToAddress(avcodec_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avcodec_license$2();
+	protected native static long avcodec_license();
 	/**
 	 * Original signature : <code>void avcodec_register(AVCodec*)</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:1639</i>
@@ -2726,20 +2726,20 @@ public class AvcodecLibrary {
 	 * Original signature : <code>AVClass* avcodec_get_class()</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:1674</i>
 	 */
-	public static Pointer<AVClass > avcodec_get_class() {
-		return Pointer.pointerToAddress(avcodec_get_class$2(), AVClass.class);
+	public static Pointer<AVClass > avcodec__get_class() {
+		return Pointer.pointerToAddress(avcodec_get_class(), AVClass.class);
 	}
 	@Ptr 
-	protected native static long avcodec_get_class$2();
+	protected native static long avcodec_get_class();
 	/**
 	 * Original signature : <code>AVClass* avcodec_get_frame_class()</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:1676</i>
 	 */
-	public static Pointer<AVClass > avcodec_get_frame_class() {
-		return Pointer.pointerToAddress(avcodec_get_frame_class$2(), AVClass.class);
+	public static Pointer<AVClass > avcodec__get_frame_class() {
+		return Pointer.pointerToAddress(avcodec_get_frame_class(), AVClass.class);
 	}
 	@Ptr 
-	protected native static long avcodec_get_frame_class$2();
+	protected native static long avcodec_get_frame_class();
 	/**
 	 * Get the AVClass for AVSubtitleRect. It can be used in combination with<br>
 	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
@@ -2747,11 +2747,11 @@ public class AvcodecLibrary {
 	 * Original signature : <code>AVClass* avcodec_get_subtitle_rect_class()</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:1683</i>
 	 */
-	public static Pointer<AVClass > avcodec_get_subtitle_rect_class() {
-		return Pointer.pointerToAddress(avcodec_get_subtitle_rect_class$2(), AVClass.class);
+	public static Pointer<AVClass > avcodec__get_subtitle_rect_class() {
+		return Pointer.pointerToAddress(avcodec_get_subtitle_rect_class(), AVClass.class);
 	}
 	@Ptr 
-	protected native static long avcodec_get_subtitle_rect_class$2();
+	protected native static long avcodec_get_subtitle_rect_class();
 	/**
 	 * Original signature : <code>int avcodec_copy_context(AVCodecContext*, const AVCodecContext*)</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:1685</i>
@@ -2915,10 +2915,10 @@ public class AvcodecLibrary {
 	 * Original signature : <code>AVChromaLocation avcodec_chroma_pos_to_enum(int, int)</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:1800</i>
 	 */
-	public static IntValuedEnum<AVChromaLocation > avcodec_chroma_pos_to_enum(int xpos, int ypos) {
-		return FlagSet.fromValue(avcodec_chroma_pos_to_enum$2(xpos, ypos), AVChromaLocation.class);
+	public static IntValuedEnum<AVChromaLocation > avcodec__chroma_pos_to_enum(int xpos, int ypos) {
+		return FlagSet.fromValue(avcodec_chroma_pos_to_enum(xpos, ypos), AVChromaLocation.class);
 	}
-	protected native static int avcodec_chroma_pos_to_enum$2(int xpos, int ypos);
+	protected native static int avcodec_chroma_pos_to_enum(int xpos, int ypos);
 	/**
 	 * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:1802</i>
@@ -3227,11 +3227,11 @@ public class AvcodecLibrary {
 	 * Original signature : <code>AVCodecParserContext* av_parser_init(int)</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:2196</i>
 	 */
-	public static Pointer<AVCodecParserContext > av_parser_init(int codec_id) {
-		return Pointer.pointerToAddress(av_parser_init$2(codec_id), AVCodecParserContext.class);
+	public static Pointer<AVCodecParserContext > av__parser_init(int codec_id) {
+		return Pointer.pointerToAddress(av_parser_init(codec_id), AVCodecParserContext.class);
 	}
 	@Ptr 
-	protected native static long av_parser_init$2(int codec_id);
+	protected native static long av_parser_init(int codec_id);
 	/**
 	 * Parse a packet.<br>
 	 * * @param s             parser context.<br>
diff -pruN generated/org/ffmpeg/avcodec/AVCodecParser.java src/org/ffmpeg/avcodec/AVCodecParser.java
--- generated/org/ffmpeg/avcodec/AVCodecParser.java	2021-06-15 09:23:37.651198869 +0200
+++ src/org/ffmpeg/avcodec/AVCodecParser.java	2021-06-15 09:24:07.399078678 +0200
@@ -111,11 +111,11 @@ public class AVCodecParser extends Struc
 	};
 	/** <i>native declaration : ./libavcodec/avcodec.h:2178</i> */
 	public static abstract class parser_parse_callback extends Callback<parser_parse_callback > {
-		public int apply(Pointer<AVCodecParserContext > s, Pointer<AVCodecContext > avctx, Pointer<Pointer<Byte > > poutbuf, Pointer<Integer > poutbuf_size, Pointer<Byte > buf, int buf_size) {
+		public int apply(Pointer<AVCodecParserContext > s, Pointer<AVCodecContext > avctx, Pointer<Pointer > poutbuf, Pointer<Integer > poutbuf_size, Pointer<Byte > buf, int buf_size) {
 			return apply(Pointer.getPeer(s), Pointer.getPeer(avctx), Pointer.getPeer(poutbuf), Pointer.getPeer(poutbuf_size), Pointer.getPeer(buf), buf_size);
 		}
 		public int apply(@Ptr long s, @Ptr long avctx, @Ptr long poutbuf, @Ptr long poutbuf_size, @Ptr long buf, int buf_size) {
-			return apply(Pointer.pointerToAddress(s, AVCodecParserContext.class), Pointer.pointerToAddress(avctx, AVCodecContext.class), Pointer.pointerToAddress(poutbuf, DefaultParameterizedType.paramType(Pointer.class, Byte.class)), Pointer.pointerToAddress(poutbuf_size, Integer.class), Pointer.pointerToAddress(buf, Byte.class), buf_size);
+			return apply(Pointer.pointerToAddress(s, AVCodecParserContext.class), Pointer.pointerToAddress(avctx, AVCodecContext.class), Pointer.pointerToAddress(poutbuf, Pointer.class), Pointer.pointerToAddress(poutbuf_size, Integer.class), Pointer.pointerToAddress(buf, Byte.class), buf_size);
 		}
 	};
 	/** <i>native declaration : ./libavcodec/avcodec.h:2179</i> */
diff -pruN generated/org/ffmpeg/avcodec/AVPacket.java src/org/ffmpeg/avcodec/AVPacket.java
--- generated/org/ffmpeg/avcodec/AVPacket.java	2021-06-15 09:23:37.215200634 +0200
+++ src/org/ffmpeg/avcodec/AVPacket.java	2021-06-15 09:24:07.399078678 +0200
@@ -1,10 +1,15 @@
 package org.ffmpeg.avcodec;
+import java.util.List;
 import org.bridj.BridJ;
 import org.bridj.Pointer;
+import org.bridj.StructFieldDescription;
 import org.bridj.StructObject;
+import org.bridj.ann.Alignment;
 import org.bridj.ann.Field;
 import org.bridj.ann.Library;
+import org.bridj.ann.Struct;
 import org.ffmpeg.avutil.AVBufferRef;
+import org.ffmpeg.util.AlignmentCustomizer;
 /**
  * <i>native declaration : ./libavcodec/packet.h:305</i><br>
  * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
@@ -46,6 +51,7 @@ public class AVPacket extends StructObje
 	 * the terms dts and pts/cts to mean something different. Such timestamps<br>
 	 * must be converted to true pts/dts before they are stored in AVPacket.
 	 */
+	@Alignment(4)
 	@Field(1) 
 	public long pts() {
 		return this.io.getLongField(this, 1);
@@ -69,6 +75,7 @@ public class AVPacket extends StructObje
 	 * the packet is decompressed.<br>
 	 * Can be AV_NOPTS_VALUE if it is not stored in the file.
 	 */
+	@Alignment(4)
 	@Field(2) 
 	public long dts() {
 		return this.io.getLongField(this, 2);
@@ -188,10 +195,15 @@ public class AVPacket extends StructObje
 		this.io.setLongField(this, 11, convergence_duration);
 		return this;
 	}
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVPacket() {
 		super();
 	}
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVPacket(Pointer pointer) {
 		super(pointer);
 	}
+	public List<StructFieldDescription> getDescriptions() {
+		return this.io.desc.getAggregatedFields();
+	}
 }
diff -pruN generated/org/ffmpeg/avcodec/AVPacketSideData.java src/org/ffmpeg/avcodec/AVPacketSideData.java
--- generated/org/ffmpeg/avcodec/AVPacketSideData.java	2021-06-15 09:23:37.211200650 +0200
+++ src/org/ffmpeg/avcodec/AVPacketSideData.java	2021-06-15 09:24:07.399078678 +0200
@@ -5,7 +5,9 @@ import org.bridj.Pointer;
 import org.bridj.StructObject;
 import org.bridj.ann.Field;
 import org.bridj.ann.Library;
+import org.bridj.ann.Struct;
 import org.ffmpeg.avcodec.AvcodecLibrary.AVPacketSideDataType;
+import org.ffmpeg.util.AlignmentCustomizer;
 /**
  * <i>native declaration : ./libavcodec/packet.h:238</i><br>
  * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
@@ -48,9 +50,11 @@ public class AVPacketSideData extends St
 		this.io.setEnumField(this, 2, type);
 		return this;
 	}
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVPacketSideData() {
 		super();
 	}
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVPacketSideData(Pointer pointer) {
 		super(pointer);
 	}
diff -pruN generated/org/ffmpeg/avdevice/AvdeviceLibrary.java src/org/ffmpeg/avdevice/AvdeviceLibrary.java
--- generated/org/ffmpeg/avdevice/AvdeviceLibrary.java	2021-06-15 09:23:35.567207305 +0200
+++ src/org/ffmpeg/avdevice/AvdeviceLibrary.java	2021-06-15 09:24:07.399078678 +0200
@@ -225,21 +225,21 @@ public class AvdeviceLibrary {
 	 * Original signature : <code>char* avdevice_configuration()</code><br>
 	 * <i>native declaration : libavdevice/avdevice.h:9</i>
 	 */
-	public static Pointer<Byte > avdevice_configuration() {
-		return Pointer.pointerToAddress(avdevice_configuration$2(), Byte.class);
+	public static Pointer<Byte > avdevice__configuration() {
+		return Pointer.pointerToAddress(avdevice_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avdevice_configuration$2();
+	protected native static long avdevice_configuration();
 	/**
 	 * Return the libavdevice license.<br>
 	 * Original signature : <code>char* avdevice_license()</code><br>
 	 * <i>native declaration : libavdevice/avdevice.h:14</i>
 	 */
-	public static Pointer<Byte > avdevice_license() {
-		return Pointer.pointerToAddress(avdevice_license$2(), Byte.class);
+	public static Pointer<Byte > avdevice__license() {
+		return Pointer.pointerToAddress(avdevice_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avdevice_license$2();
+	protected native static long avdevice_license();
 	/**
 	 * Initialize libavdevice and register all the input and output devices.<br>
 	 * Original signature : <code>void avdevice_register_all()</code><br>
diff -pruN generated/org/ffmpeg/avfilter/AVFilter.java src/org/ffmpeg/avfilter/AVFilter.java
--- generated/org/ffmpeg/avfilter/AVFilter.java	2021-06-15 09:23:35.607207143 +0200
+++ src/org/ffmpeg/avfilter/AVFilter.java	2021-06-15 09:24:07.399078678 +0200
@@ -459,11 +459,11 @@ public class AVFilter extends StructObje
 	};
 	/** <i>native declaration : libavfilter/avfilter.h:195</i> */
 	public static abstract class init_dict_callback extends Callback<init_dict_callback > {
-		public int apply(Pointer<AVFilterContext > ctx, Pointer<Pointer<AVDictionary > > options) {
+		public int apply(Pointer<AVFilterContext > ctx, Pointer<Pointer > options) {
 			return apply(Pointer.getPeer(ctx), Pointer.getPeer(options));
 		}
 		public int apply(@Ptr long ctx, @Ptr long options) {
-			return apply(Pointer.pointerToAddress(ctx, AVFilterContext.class), Pointer.pointerToAddress(options, DefaultParameterizedType.paramType(Pointer.class, AVDictionary.class)));
+			return apply(Pointer.pointerToAddress(ctx, AVFilterContext.class), Pointer.pointerToAddress(options, Pointer.class));
 		}
 	};
 	/** <i>native declaration : libavfilter/avfilter.h:196</i> */
diff -pruN generated/org/ffmpeg/avfilter/AvfilterLibrary.java src/org/ffmpeg/avfilter/AvfilterLibrary.java
--- generated/org/ffmpeg/avfilter/AvfilterLibrary.java	2021-06-15 09:23:35.731206641 +0200
+++ src/org/ffmpeg/avfilter/AvfilterLibrary.java	2021-06-15 13:24:38.856922381 +0200
@@ -148,21 +148,21 @@ public class AvfilterLibrary {
 	 * Original signature : <code>char* avfilter_configuration()</code><br>
 	 * <i>native declaration : libavfilter/avfilter.h:9</i>
 	 */
-	public static Pointer<Byte > avfilter_configuration() {
-		return Pointer.pointerToAddress(avfilter_configuration$2(), Byte.class);
+	public static Pointer<Byte > avfilter__configuration() {
+		return Pointer.pointerToAddress(avfilter_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avfilter_configuration$2();
+	protected native static long avfilter_configuration();
 	/**
 	 * Return the libavfilter license.<br>
 	 * Original signature : <code>char* avfilter_license()</code><br>
 	 * <i>native declaration : libavfilter/avfilter.h:14</i>
 	 */
-	public static Pointer<Byte > avfilter_license() {
-		return Pointer.pointerToAddress(avfilter_license$2(), Byte.class);
+	public static Pointer<Byte > avfilter__license() {
+		return Pointer.pointerToAddress(avfilter_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avfilter_license$2();
+	protected native static long avfilter_license();
 	/**
 	 * Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.<br>
 	 * AVFilter.inputs/outputs).<br>
@@ -379,22 +379,22 @@ public class AvfilterLibrary {
 	 * Original signature : <code>AVClass* avfilter_get_class()</code><br>
 	 * <i>native declaration : libavfilter/avfilter.h:537</i>
 	 */
-	public static Pointer<AVClass > avfilter_get_class() {
-		return Pointer.pointerToAddress(avfilter_get_class$2(), AVClass.class);
+	public static Pointer<AVClass > avfilter__get_class() {
+		return Pointer.pointerToAddress(avfilter_get_class(), AVClass.class);
 	}
 	@Ptr 
-	protected native static long avfilter_get_class$2();
+	protected native static long avfilter_get_class();
 	/**
 	 * Allocate a filter graph.<br>
 	 * * @return the allocated filter graph on success or NULL.<br>
 	 * Original signature : <code>AVFilterGraph* avfilter_graph_alloc()</code><br>
 	 * <i>native declaration : libavfilter/avfilter.h:618</i>
 	 */
-	public static Pointer<AVFilterGraph > avfilter_graph_alloc() {
-		return Pointer.pointerToAddress(avfilter_graph_alloc$2(), AVFilterGraph.class);
+	public static Pointer<AVFilterGraph > avfilter__graph_alloc() {
+		return Pointer.pointerToAddress(avfilter_graph_alloc(), AVFilterGraph.class);
 	}
 	@Ptr 
-	protected native static long avfilter_graph_alloc$2();
+	protected native static long avfilter_graph_alloc();
 	/**
 	 * Create a new filter instance in a filter graph.<br>
 	 * * @param graph graph in which the new filter will be used<br>
@@ -486,11 +486,11 @@ public class AvfilterLibrary {
 	 * Original signature : <code>AVFilterInOut* avfilter_inout_alloc()</code><br>
 	 * <i>native declaration : libavfilter/avfilter.h:705</i>
 	 */
-	public static Pointer<AVFilterInOut > avfilter_inout_alloc() {
-		return Pointer.pointerToAddress(avfilter_inout_alloc$2(), AVFilterInOut.class);
+	public static Pointer<AVFilterInOut > avfilter__inout_alloc() {
+		return Pointer.pointerToAddress(avfilter_inout_alloc(), AVFilterInOut.class);
 	}
 	@Ptr 
-	protected native static long avfilter_inout_alloc$2();
+	protected native static long avfilter_inout_alloc();
 	/**
 	 * Free the supplied list of AVFilterInOut and set *inout to NULL.<br>
 	 * If *inout is NULL, do nothing.<br>
@@ -659,20 +659,20 @@ public class AvfilterLibrary {
 	 * Original signature : <code>AVBufferSinkParams* av_buffersink_params_alloc()</code><br>
 	 * <i>native declaration : libavfilter/buffersink.h:18</i>
 	 */
-	public static Pointer<AVBufferSinkParams > av_buffersink_params_alloc() {
-		return Pointer.pointerToAddress(av_buffersink_params_alloc$2(), AVBufferSinkParams.class);
+	public static Pointer<AVBufferSinkParams > av_buffersink__params_alloc() {
+		return Pointer.pointerToAddress(av_buffersink_params_alloc(), AVBufferSinkParams.class);
 	}
 	@Ptr 
-	protected native static long av_buffersink_params_alloc$2();
+	protected native static long av_buffersink_params_alloc();
 	/**
 	 * Original signature : <code>AVABufferSinkParams* av_abuffersink_params_alloc()</code><br>
 	 * <i>native declaration : libavfilter/buffersink.h:35</i>
 	 */
-	public static Pointer<AVABufferSinkParams > av_abuffersink_params_alloc() {
-		return Pointer.pointerToAddress(av_abuffersink_params_alloc$2(), AVABufferSinkParams.class);
+	public static Pointer<AVABufferSinkParams > av_abuffersink__params_alloc() {
+		return Pointer.pointerToAddress(av_abuffersink_params_alloc(), AVABufferSinkParams.class);
 	}
 	@Ptr 
-	protected native static long av_abuffersink_params_alloc$2();
+	protected native static long av_abuffersink_params_alloc();
 	/**
 	 * Set the frame size for an audio buffer sink.<br>
 	 * * All calls to av_buffersink_get_buffer_ref will return a buffer with<br>
@@ -830,11 +830,11 @@ public class AvfilterLibrary {
 	 * Original signature : <code>AVBufferSrcParameters* av_buffersrc_parameters_alloc()</code><br>
 	 * <i>native declaration : libavfilter/buffersrc.h:62</i>
 	 */
-	public static Pointer<AVBufferSrcParameters > av_buffersrc_parameters_alloc() {
-		return Pointer.pointerToAddress(av_buffersrc_parameters_alloc$2(), AVBufferSrcParameters.class);
+	public static Pointer<AVBufferSrcParameters > av_buffersrc__parameters_alloc() {
+		return Pointer.pointerToAddress(av_buffersrc_parameters_alloc(), AVBufferSrcParameters.class);
 	}
 	@Ptr 
-	protected native static long av_buffersrc_parameters_alloc$2();
+	protected native static long av_buffersrc_parameters_alloc();
 	/**
 	 * Initialize the buffersrc or abuffersrc filter with the provided parameters.<br>
 	 * This function may be called multiple times, the later calls override the<br>
diff -pruN generated/org/ffmpeg/avformat/AVFormatContext.java src/org/ffmpeg/avformat/AVFormatContext.java
--- generated/org/ffmpeg/avformat/AVFormatContext.java	2021-06-15 09:23:36.607203095 +0200
+++ src/org/ffmpeg/avformat/AVFormatContext.java	2021-06-15 14:03:28.335943731 +0200
@@ -7,6 +7,7 @@ import org.bridj.StructObject;
 import org.bridj.ann.Array;
 import org.bridj.ann.Field;
 import org.bridj.ann.Library;
+import org.bridj.ann.Struct;
 import org.bridj.ann.Ptr;
 import org.bridj.util.DefaultParameterizedType;
 import org.ffmpeg.avcodec.AVCodec;
@@ -15,6 +16,8 @@ import org.ffmpeg.avformat.AvformatLibra
 import org.ffmpeg.avformat.AvformatLibrary.av_format_control_message;
 import org.ffmpeg.avutil.AVClass;
 import org.ffmpeg.avutil.AVDictionary;
+import org.ffmpeg.util.AlignmentCustomizer;
+
 /**
  * <i>native declaration : libavformat/avformat.h:1055</i><br>
  * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
@@ -1540,20 +1543,20 @@ public class AVFormatContext extends Str
 	}
 	/** <i>native declaration : libavformat/avformat.h:1052</i> */
 	public static abstract class open_cb_callback extends Callback<open_cb_callback > {
-		public int apply(Pointer<AVFormatContext > s, Pointer<Pointer<AVIOContext > > p, Pointer<Byte > url, int flags, Pointer<AVIOInterruptCB > int_cb, Pointer<Pointer<AVDictionary > > options) {
+		public int apply(Pointer<AVFormatContext > s, Pointer<Pointer > p, Pointer<Byte > url, int flags, Pointer<AVIOInterruptCB > int_cb, Pointer<Pointer > options) {
 			return apply(Pointer.getPeer(s), Pointer.getPeer(p), Pointer.getPeer(url), flags, Pointer.getPeer(int_cb), Pointer.getPeer(options));
 		}
 		public int apply(@Ptr long s, @Ptr long p, @Ptr long url, int flags, @Ptr long int_cb, @Ptr long options) {
-			return apply(Pointer.pointerToAddress(s, AVFormatContext.class), Pointer.pointerToAddress(p, DefaultParameterizedType.paramType(Pointer.class, AVIOContext.class)), Pointer.pointerToAddress(url, Byte.class), flags, Pointer.pointerToAddress(int_cb, AVIOInterruptCB.class), Pointer.pointerToAddress(options, DefaultParameterizedType.paramType(Pointer.class, AVDictionary.class)));
+			return apply(Pointer.pointerToAddress(s, AVFormatContext.class), Pointer.pointerToAddress(p, Pointer.class), Pointer.pointerToAddress(url, Byte.class), flags, Pointer.pointerToAddress(int_cb, AVIOInterruptCB.class), Pointer.pointerToAddress(options, Pointer.class));
 		}
 	};
 	/** <i>native declaration : libavformat/avformat.h:1053</i> */
 	public static abstract class io_open_callback extends Callback<io_open_callback > {
-		public int apply(Pointer<AVFormatContext > s, Pointer<Pointer<AVIOContext > > pb, Pointer<Byte > url, int flags, Pointer<Pointer<AVDictionary > > options) {
+		public int apply(Pointer<AVFormatContext > s, Pointer<Pointer > pb, Pointer<Byte > url, int flags, Pointer<Pointer > options) {
 			return apply(Pointer.getPeer(s), Pointer.getPeer(pb), Pointer.getPeer(url), flags, Pointer.getPeer(options));
 		}
 		public int apply(@Ptr long s, @Ptr long pb, @Ptr long url, int flags, @Ptr long options) {
-			return apply(Pointer.pointerToAddress(s, AVFormatContext.class), Pointer.pointerToAddress(pb, DefaultParameterizedType.paramType(Pointer.class, AVIOContext.class)), Pointer.pointerToAddress(url, Byte.class), flags, Pointer.pointerToAddress(options, DefaultParameterizedType.paramType(Pointer.class, AVDictionary.class)));
+			return apply(Pointer.pointerToAddress(s, AVFormatContext.class), Pointer.pointerToAddress(pb, Pointer.class), Pointer.pointerToAddress(url, Byte.class), flags, Pointer.pointerToAddress(options, Pointer.class));
 		}
 	};
 	/** <i>native declaration : libavformat/avformat.h:1054</i> */
@@ -1565,9 +1568,11 @@ public class AVFormatContext extends Str
 			apply(Pointer.pointerToAddress(s, AVFormatContext.class), Pointer.pointerToAddress(pb, AVIOContext.class));
 		}
 	};
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVFormatContext() {
 		super();
 	}
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVFormatContext(Pointer pointer) {
 		super(pointer);
 	}
diff -pruN generated/org/ffmpeg/avformat/AvformatLibrary.java src/org/ffmpeg/avformat/AvformatLibrary.java
--- generated/org/ffmpeg/avformat/AvformatLibrary.java	2021-06-15 09:23:37.175200796 +0200
+++ src/org/ffmpeg/avformat/AvformatLibrary.java	2021-06-15 14:05:20.355678880 +0200
@@ -486,11 +486,11 @@ public class AvformatLibrary {
 	};
 	/** <i>native declaration : libavformat/avformat.h:553</i> */
 	public static abstract class AVOpenCallback extends Callback<AVOpenCallback > {
-		public int apply(Pointer<AVFormatContext > s, Pointer<Pointer<AVIOContext > > pb, Pointer<Byte > url, int flags, Pointer<AVIOInterruptCB > int_cb, Pointer<Pointer<AVDictionary > > options) {
+		public int apply(Pointer<AVFormatContext > s, Pointer<Pointer> pb, Pointer<Byte > url, int flags, Pointer<AVIOInterruptCB > int_cb, Pointer<Pointer> options) {
 			return apply(Pointer.getPeer(s), Pointer.getPeer(pb), Pointer.getPeer(url), flags, Pointer.getPeer(int_cb), Pointer.getPeer(options));
 		}
 		public int apply(@Ptr long s, @Ptr long pb, @Ptr long url, int flags, @Ptr long int_cb, @Ptr long options) {
-			return apply(Pointer.pointerToAddress(s, AVFormatContext.class), Pointer.pointerToAddress(pb, DefaultParameterizedType.paramType(Pointer.class, AVIOContext.class)), Pointer.pointerToAddress(url, Byte.class), flags, Pointer.pointerToAddress(int_cb, AVIOInterruptCB.class), Pointer.pointerToAddress(options, DefaultParameterizedType.paramType(Pointer.class, AVDictionary.class)));
+			return apply(Pointer.pointerToAddress(s, AVFormatContext.class), Pointer.pointerToAddress(pb, Pointer.class), Pointer.pointerToAddress(url, Byte.class), flags, Pointer.pointerToAddress(int_cb, AVIOInterruptCB.class), Pointer.pointerToAddress(options, Pointer.class));
 		}
 	};
 	/**
@@ -1458,21 +1458,21 @@ public class AvformatLibrary {
 	 * Original signature : <code>char* avformat_configuration()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:1111</i>
 	 */
-	public static Pointer<Byte > avformat_configuration() {
-		return Pointer.pointerToAddress(avformat_configuration$2(), Byte.class);
+	public static Pointer<Byte > avformat__configuration() {
+		return Pointer.pointerToAddress(avformat_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avformat_configuration$2();
+	protected native static long avformat_configuration();
 	/**
 	 * Return the libavformat license.<br>
 	 * Original signature : <code>char* avformat_license()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:1116</i>
 	 */
-	public static Pointer<Byte > avformat_license() {
-		return Pointer.pointerToAddress(avformat_license$2(), Byte.class);
+	public static Pointer<Byte > avformat__license() {
+		return Pointer.pointerToAddress(avformat_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avformat_license$2();
+	protected native static long avformat_license();
 	/**
 	 * Original signature : <code>void av_register_all()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:1118</i>
@@ -1569,11 +1569,11 @@ public class AvformatLibrary {
 	 * Original signature : <code>AVFormatContext* avformat_alloc_context()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:1171</i>
 	 */
-	public static Pointer<AVFormatContext > avformat_alloc_context() {
-		return Pointer.pointerToAddress(avformat_alloc_context$2(), AVFormatContext.class);
+	public static Pointer<AVFormatContext > alloc_context() {
+		return Pointer.pointerToAddress(avformat_alloc_context(), AVFormatContext.class);
 	}
 	@Ptr 
-	protected native static long avformat_alloc_context$2();
+	protected native static long avformat_alloc_context();
 	/**
 	 * Free an AVFormatContext and all its streams.<br>
 	 * @param s context to free<br>
@@ -1591,11 +1591,11 @@ public class AvformatLibrary {
 	 * Original signature : <code>AVClass* avformat_get_class()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:1184</i>
 	 */
-	public static Pointer<AVClass > avformat_get_class() {
-		return Pointer.pointerToAddress(avformat_get_class$2(), AVClass.class);
+	public static Pointer<AVClass > avformat__get_class() {
+		return Pointer.pointerToAddress(avformat_get_class(), AVClass.class);
 	}
 	@Ptr 
-	protected native static long avformat_get_class$2();
+	protected native static long avformat_get_class();
 	/**
 	 * Add a new stream to a media file.<br>
 	 * * When demuxing, it is called by the demuxer in read_header(). If the<br>
@@ -2470,41 +2470,41 @@ public class AvformatLibrary {
 	 * Original signature : <code>AVCodecTag* avformat_get_riff_video_tags()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:1818</i>
 	 */
-	public static Pointer<AVCodecTag > avformat_get_riff_video_tags() {
-		return Pointer.pointerToAddress(avformat_get_riff_video_tags$2(), AVCodecTag.class);
+	public static Pointer<AVCodecTag > avformat__get_riff_video_tags() {
+		return Pointer.pointerToAddress(avformat_get_riff_video_tags(), AVCodecTag.class);
 	}
 	@Ptr 
-	protected native static long avformat_get_riff_video_tags$2();
+	protected native static long avformat_get_riff_video_tags();
 	/**
 	 * @return the table mapping RIFF FourCCs for audio to AVCodecID.<br>
 	 * Original signature : <code>AVCodecTag* avformat_get_riff_audio_tags()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:1823</i>
 	 */
-	public static Pointer<AVCodecTag > avformat_get_riff_audio_tags() {
-		return Pointer.pointerToAddress(avformat_get_riff_audio_tags$2(), AVCodecTag.class);
+	public static Pointer<AVCodecTag > avformat__get_riff_audio_tags() {
+		return Pointer.pointerToAddress(avformat_get_riff_audio_tags(), AVCodecTag.class);
 	}
 	@Ptr 
-	protected native static long avformat_get_riff_audio_tags$2();
+	protected native static long avformat_get_riff_audio_tags();
 	/**
 	 * @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.<br>
 	 * Original signature : <code>AVCodecTag* avformat_get_mov_video_tags()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:1828</i>
 	 */
-	public static Pointer<AVCodecTag > avformat_get_mov_video_tags() {
-		return Pointer.pointerToAddress(avformat_get_mov_video_tags$2(), AVCodecTag.class);
+	public static Pointer<AVCodecTag > avformat__get_mov_video_tags() {
+		return Pointer.pointerToAddress(avformat_get_mov_video_tags(), AVCodecTag.class);
 	}
 	@Ptr 
-	protected native static long avformat_get_mov_video_tags$2();
+	protected native static long avformat_get_mov_video_tags();
 	/**
 	 * @return the table mapping MOV FourCCs for audio to AVCodecID.<br>
 	 * Original signature : <code>AVCodecTag* avformat_get_mov_audio_tags()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:1833</i>
 	 */
-	public static Pointer<AVCodecTag > avformat_get_mov_audio_tags() {
-		return Pointer.pointerToAddress(avformat_get_mov_audio_tags$2(), AVCodecTag.class);
+	public static Pointer<AVCodecTag > avformat__get_mov_audio_tags() {
+		return Pointer.pointerToAddress(avformat_get_mov_audio_tags(), AVCodecTag.class);
 	}
 	@Ptr 
-	protected native static long avformat_get_mov_audio_tags$2();
+	protected native static long avformat_get_mov_audio_tags();
 	/**
 	 * Guess the sample aspect ratio of a frame, based on both the stream and the<br>
 	 * frame aspect ratio.<br>
diff -pruN generated/org/ffmpeg/avformat/AVOutputFormat.java src/org/ffmpeg/avformat/AVOutputFormat.java
--- generated/org/ffmpeg/avformat/AVOutputFormat.java	2021-06-15 09:23:36.399203937 +0200
+++ src/org/ffmpeg/avformat/AVOutputFormat.java	2021-06-15 09:24:07.403078662 +0200
@@ -566,11 +566,11 @@ public class AVOutputFormat extends Stru
 	};
 	/** <i>native declaration : libavformat/avformat.h:160</i> */
 	public static abstract class write_uncoded_frame_callback extends Callback<write_uncoded_frame_callback > {
-		public int apply(Pointer<AVFormatContext > AVFormatContextPtr1, int stream_index, Pointer<Pointer<AVFrame > > frame, int flags) {
+		public int apply(Pointer<AVFormatContext > AVFormatContextPtr1, int stream_index, Pointer<Pointer > frame, int flags) {
 			return apply(Pointer.getPeer(AVFormatContextPtr1), stream_index, Pointer.getPeer(frame), flags);
 		}
 		public int apply(@Ptr long AVFormatContextPtr1, int stream_index, @Ptr long frame, int flags) {
-			return apply(Pointer.pointerToAddress(AVFormatContextPtr1, AVFormatContext.class), stream_index, Pointer.pointerToAddress(frame, DefaultParameterizedType.paramType(Pointer.class, AVFrame.class)), flags);
+			return apply(Pointer.pointerToAddress(AVFormatContextPtr1, AVFormatContext.class), stream_index, Pointer.pointerToAddress(frame, Pointer.class), flags);
 		}
 	};
 	/** <i>native declaration : libavformat/avformat.h:161</i> */
diff -pruN generated/org/ffmpeg/avformat/AVStream.java src/org/ffmpeg/avformat/AVStream.java
--- generated/org/ffmpeg/avformat/AVStream.java	2021-06-15 09:23:36.523203435 +0200
+++ src/org/ffmpeg/avformat/AVStream.java	2021-06-15 09:24:07.403078662 +0200
@@ -6,6 +6,7 @@ import org.bridj.StructObject;
 import org.bridj.ann.Array;
 import org.bridj.ann.Field;
 import org.bridj.ann.Library;
+import org.bridj.ann.Struct;
 import org.ffmpeg.avcodec.AVCodecContext;
 import org.ffmpeg.avcodec.AVCodecParameters;
 import org.ffmpeg.avcodec.AVCodecParserContext;
@@ -15,6 +16,7 @@ import org.ffmpeg.avcodec.AvcodecLibrary
 import org.ffmpeg.avformat.AvformatLibrary.AVStreamParseType;
 import org.ffmpeg.avutil.AVDictionary;
 import org.ffmpeg.avutil.AVRational;
+import org.ffmpeg.util.AlignmentCustomizer;
 /**
  * <i>native declaration : libavformat/avformat.h:489</i><br>
  * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
diff -pruN generated/org/ffmpeg/avresample/AvresampleLibrary.java src/org/ffmpeg/avresample/AvresampleLibrary.java
--- generated/org/ffmpeg/avresample/AvresampleLibrary.java	2021-06-15 09:23:35.351208179 +0200
+++ src/org/ffmpeg/avresample/AvresampleLibrary.java	2021-06-15 09:24:07.403078662 +0200
@@ -148,38 +148,38 @@ public class AvresampleLibrary {
 	 * Original signature : <code>char* avresample_configuration()</code><br>
 	 * <i>native declaration : libavresample/avresample.h:34</i>
 	 */
-	public static Pointer<Byte > avresample_configuration() {
-		return Pointer.pointerToAddress(avresample_configuration$2(), Byte.class);
+	public static Pointer<Byte > avresample__configuration() {
+		return Pointer.pointerToAddress(avresample_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avresample_configuration$2();
+	protected native static long avresample_configuration();
 	/**
 	 * Original signature : <code>char* avresample_license()</code><br>
 	 * <i>native declaration : libavresample/avresample.h:36</i>
 	 */
-	public static Pointer<Byte > avresample_license() {
-		return Pointer.pointerToAddress(avresample_license$2(), Byte.class);
+	public static Pointer<Byte > avresample__license() {
+		return Pointer.pointerToAddress(avresample_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avresample_license$2();
+	protected native static long avresample_license();
 	/**
 	 * Original signature : <code>AVClass* avresample_get_class()</code><br>
 	 * <i>native declaration : libavresample/avresample.h:38</i>
 	 */
-	public static Pointer<AVClass > avresample_get_class() {
-		return Pointer.pointerToAddress(avresample_get_class$2(), AVClass.class);
+	public static Pointer<AVClass > avresample__get_class() {
+		return Pointer.pointerToAddress(avresample_get_class(), AVClass.class);
 	}
 	@Ptr 
-	protected native static long avresample_get_class$2();
+	protected native static long avresample_get_class();
 	/**
 	 * Original signature : <code>AVAudioResampleContext* avresample_alloc_context()</code><br>
 	 * <i>native declaration : libavresample/avresample.h:40</i>
 	 */
-	public static Pointer<AVAudioResampleContext > avresample_alloc_context() {
-		return Pointer.pointerToAddress(avresample_alloc_context$2(), AVAudioResampleContext.class);
+	public static Pointer<AVAudioResampleContext > avresample__alloc_context() {
+		return Pointer.pointerToAddress(avresample_alloc_context(), AVAudioResampleContext.class);
 	}
 	@Ptr 
-	protected native static long avresample_alloc_context$2();
+	protected native static long avresample_alloc_context();
 	/**
 	 * Original signature : <code>int avresample_open(AVAudioResampleContext*)</code><br>
 	 * <i>native declaration : libavresample/avresample.h:42</i>
diff -pruN generated/org/ffmpeg/avutil/AVClass.java src/org/ffmpeg/avutil/AVClass.java
--- generated/org/ffmpeg/avutil/AVClass.java	2021-06-15 09:23:35.783206430 +0200
+++ src/org/ffmpeg/avutil/AVClass.java	2021-06-15 14:16:33.070104476 +0200
@@ -288,21 +288,21 @@ public class AVClass extends StructObjec
 	};
 	/** <i>native declaration : libavutil/log.h:92</i> */
 	public static abstract class query_ranges_callback extends Callback<query_ranges_callback > {
-		public int apply(Pointer<Pointer<AVOptionRanges > > AVOptionRangesPtrPtr1, Pointer<? > obj, Pointer<Byte > key, int flags) {
+		public int apply(Pointer<Pointer > AVOptionRangesPtrPtr1, Pointer<? > obj, Pointer<Byte > key, int flags) {
 			return apply(Pointer.getPeer(AVOptionRangesPtrPtr1), Pointer.getPeer(obj), Pointer.getPeer(key), flags);
 		}
 		public int apply(@Ptr long AVOptionRangesPtrPtr1, @Ptr long obj, @Ptr long key, int flags) {
-			return apply(Pointer.pointerToAddress(AVOptionRangesPtrPtr1, DefaultParameterizedType.paramType(Pointer.class, AVOptionRanges.class)), Pointer.pointerToAddress(obj), Pointer.pointerToAddress(key, Byte.class), flags);
+			return apply(Pointer.pointerToAddress(AVOptionRangesPtrPtr1, Pointer.class), Pointer.pointerToAddress(obj), Pointer.pointerToAddress(key, Byte.class), flags);
 		}
 	};
 	/** <i>native declaration : libavutil/log.h:93</i> */
 	public static abstract class child_class_iterate_callback extends Callback<child_class_iterate_callback > {
-		public Pointer<AVClass > apply(Pointer<Pointer<? > > iter) {
+		public Pointer<AVClass > apply(Pointer<Pointer > iter) {
 			return Pointer.pointerToAddress(apply(Pointer.getPeer(iter)), AVClass.class);
 		}
 		@Ptr 
 		public long apply(@Ptr long iter) {
-			return Pointer.getPeer(apply(Pointer.pointerToAddress(iter, DefaultParameterizedType.paramType(Pointer.class, null))));
+			return Pointer.getPeer(apply(Pointer.pointerToAddress(iter, Pointer.class)));
 		}
 	};
 	public AVClass() {
diff -pruN generated/org/ffmpeg/avutil/AVFrame.java src/org/ffmpeg/avutil/AVFrame.java
--- generated/org/ffmpeg/avutil/AVFrame.java	2021-06-15 09:23:35.819206285 +0200
+++ src/org/ffmpeg/avutil/AVFrame.java	2021-06-15 14:07:17.455402874 +0200
@@ -1,4 +1,9 @@
 package org.ffmpeg.avutil;
+import java.util.List;
+import org.bridj.StructFieldDescription;
+import org.bridj.ann.Alignment;
+import org.bridj.ann.Struct;
+import org.ffmpeg.util.AlignmentCustomizer;
 import org.bridj.BridJ;
 import org.bridj.IntValuedEnum;
 import org.bridj.Pointer;
@@ -217,20 +222,24 @@ public class AVFrame extends StructObjec
 		return this;
 	}
 	/** Presentation timestamp in time_base units (time when frame should be shown to user). */
+	@Alignment(4)
 	@Field(10) 
 	public long pts() {
 		return this.io.getLongField(this, 10);
 	}
 	/** Presentation timestamp in time_base units (time when frame should be shown to user). */
+	@Alignment(4)
 	@Field(10) 
 	public AVFrame pts(long pts) {
 		this.io.setLongField(this, 10, pts);
 		return this;
 	}
+	@Alignment(4)
 	@Field(11) 
 	public long pkt_pts() {
 		return this.io.getLongField(this, 11);
 	}
+	@Alignment(4)
 	@Field(11) 
 	public AVFrame pkt_pts(long pkt_pts) {
 		this.io.setLongField(this, 11, pkt_pts);
@@ -241,7 +250,8 @@ public class AVFrame extends StructObjec
 	 * This is also the Presentation time of this AVFrame calculated from<br>
 	 * only AVPacket.dts values without pts values.
 	 */
-	@Field(12) 
+	@Alignment(4)
+ 	@Field(12) 
 	public long pkt_dts() {
 		return this.io.getLongField(this, 12);
 	}
@@ -250,7 +260,8 @@ public class AVFrame extends StructObjec
 	 * This is also the Presentation time of this AVFrame calculated from<br>
 	 * only AVPacket.dts values without pts values.
 	 */
-	@Field(12) 
+	@Alignment(4)
+ 	@Field(12) 
 	public AVFrame pkt_dts(long pkt_dts) {
 		this.io.setLongField(this, 12, pkt_dts);
 		return this;
@@ -369,7 +380,8 @@ public class AVFrame extends StructObjec
 	 * the decoder reorders values as needed and sets AVFrame.reordered_opaque<br>
 	 * to exactly one of the values provided by the user through AVCodecContext.reordered_opaque
 	 */
-	@Field(22) 
+	@Alignment(4)
+ 	@Field(22) 
 	public long reordered_opaque() {
 		return this.io.getLongField(this, 22);
 	}
@@ -381,7 +393,8 @@ public class AVFrame extends StructObjec
 	 * the decoder reorders values as needed and sets AVFrame.reordered_opaque<br>
 	 * to exactly one of the values provided by the user through AVCodecContext.reordered_opaque
 	 */
-	@Field(22) 
+	@Alignment(4)
+ 	@Field(22) 
 	public AVFrame reordered_opaque(long reordered_opaque) {
 		this.io.setLongField(this, 22, reordered_opaque);
 		return this;
@@ -893,10 +906,16 @@ public class AVFrame extends StructObjec
 		this.io.setPointerField(this, 53, private_ref);
 		return this;
 	}
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVFrame() {
 		super();
 	}
+	@Struct(customizer=AlignmentCustomizer.class)
 	public AVFrame(Pointer pointer) {
 		super(pointer);
 	}
+	
+	public List<StructFieldDescription> getDescriptions() {
+		return this.io.desc.getAggregatedFields();
+	}
 }
diff -pruN generated/org/ffmpeg/avutil/AVUtil.java src/org/ffmpeg/avutil/AVUtil.java
--- generated/org/ffmpeg/avutil/AVUtil.java	1970-01-01 01:00:00.000000000 +0100
+++ src/org/ffmpeg/avutil/AVUtil.java	2021-06-15 09:24:07.403078662 +0200
@@ -0,0 +1,44 @@
+package org.ffmpeg.avutil;
+
+public class AVUtil {
+	public static final long AV_NOPTS_VALUE = Long.MIN_VALUE;
+
+	/** Inline-Funktion rational.h */
+	public static double av_q2d(AVRational a) {
+               return a.num() / (double) a.den();
+       }
+
+	public static String av_ts_make_string(long ts) {
+               if (ts == AV_NOPTS_VALUE)
+                       return "NOPTS";
+               else
+                       return Long.toHexString(ts);
+       }
+
+	/**
+	 * Original signaturre : #define av_ts2str(ts)
+	 * av_ts_make_string((char[AV_TS_MAX_STRING_SIZE]){0}, ts)
+	 */
+	public static String av_ts2str(long ts) {
+               return av_ts_make_string(ts);
+       }
+
+	public static String av_ts_make_time_string(long ts,
+                       AVRational tb) {
+               if (ts == AV_NOPTS_VALUE)
+                       return "NOPTS";
+               else {
+                       String s = String.format("%.6g", av_q2d(tb) * ts);
+                       return s;
+               }
+       }
+
+	/**
+	 * Original signature : #define av_ts2timestr(ts, tb)
+	 * av_ts_make_time_string((char[AV_TS_MAX_STRING_SIZE]){0}, ts, tb)
+	 */
+	public static String av_ts2timestr(long ts, AVRational tb) {
+               return av_ts_make_time_string(ts, tb);
+       }
+
+}
diff -pruN generated/org/ffmpeg/avutil/AvutilLibrary.java src/org/ffmpeg/avutil/AvutilLibrary.java
--- generated/org/ffmpeg/avutil/AvutilLibrary.java	2021-06-15 09:23:36.279204423 +0200
+++ src/org/ffmpeg/avutil/AvutilLibrary.java	2021-06-15 14:09:09.267140125 +0200
@@ -1875,12 +1875,12 @@ public class AvutilLibrary {
 	};
 	/** <i>native declaration : libavutil/buffer.h:130</i> */
 	public static abstract class av_buffer_pool_init_alloc_callback extends Callback<av_buffer_pool_init_alloc_callback > {
-		public Pointer<AVBufferRef > apply(int size) {
-			return Pointer.pointerToAddress(apply$2(size), AVBufferRef.class);
+		public Pointer<AVBufferRef > _apply(int size) {
+			return Pointer.pointerToAddress(apply(size), AVBufferRef.class);
 		}
 		@Ptr 
-		public long apply$2(int size) {
-			return Pointer.getPeer(apply(size));
+		public long apply(int size) {
+			return Pointer.getPeer(_apply(size));
 		}
 	};
 	/** <i>native declaration : libavutil/buffer.h:131</i> */
@@ -1915,31 +1915,31 @@ public class AvutilLibrary {
 	 * Original signature : <code>char* av_version_info()</code><br>
 	 * <i>native declaration : libavutil/avutil.h:11</i>
 	 */
-	public static Pointer<Byte > av_version_info() {
-		return Pointer.pointerToAddress(av_version_info$2(), Byte.class);
+	public static Pointer<Byte > av__version_info() {
+		return Pointer.pointerToAddress(av_version_info(), Byte.class);
 	}
 	@Ptr 
-	protected native static long av_version_info$2();
+	protected native static long av_version_info();
 	/**
 	 * Return the libavutil build-time configuration.<br>
 	 * Original signature : <code>char* avutil_configuration()</code><br>
 	 * <i>native declaration : libavutil/avutil.h:16</i>
 	 */
-	public static Pointer<Byte > avutil_configuration() {
-		return Pointer.pointerToAddress(avutil_configuration$2(), Byte.class);
+	public static Pointer<Byte > avutil__configuration() {
+		return Pointer.pointerToAddress(avutil_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avutil_configuration$2();
+	protected native static long avutil_configuration();
 	/**
 	 * Return the libavutil license.<br>
 	 * Original signature : <code>char* avutil_license()</code><br>
 	 * <i>native declaration : libavutil/avutil.h:21</i>
 	 */
-	public static Pointer<Byte > avutil_license() {
-		return Pointer.pointerToAddress(avutil_license$2(), Byte.class);
+	public static Pointer<Byte > avutil__license() {
+		return Pointer.pointerToAddress(avutil_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long avutil_license$2();
+	protected native static long avutil_license();
 	/**
 	 * Return a string describing the media_type enum, NULL if media_type<br>
 	 * is unknown.<br>
@@ -2000,11 +2000,11 @@ public class AvutilLibrary {
 	 * Original signature : <code>void* av_malloc(size_t)</code><br>
 	 * <i>native declaration : libavutil/mem.h:9</i>
 	 */
-	public static Pointer<? > av_malloc(@Ptr long size) {
-		return Pointer.pointerToAddress(av_malloc$2(size));
+	public static Pointer<? > malloc(@Ptr long size) {
+		return Pointer.pointerToAddress(av_malloc(size));
 	}
 	@Ptr 
-	protected native static long av_malloc$2(@Ptr long size);
+	protected native static long av_malloc(@Ptr long size);
 	/**
 	 * Allocate a memory block with alignment suitable for all memory accesses<br>
 	 * (including vectors if available on the CPU) and zero all the bytes of the<br>
@@ -2015,11 +2015,11 @@ public class AvutilLibrary {
 	 * Original signature : <code>void* av_mallocz(size_t)</code><br>
 	 * <i>native declaration : libavutil/mem.h:19</i>
 	 */
-	public static Pointer<? > av_mallocz(@Ptr long size) {
-		return Pointer.pointerToAddress(av_mallocz$2(size));
+	public static Pointer<? > av__mallocz(@Ptr long size) {
+		return Pointer.pointerToAddress(av_mallocz(size));
 	}
 	@Ptr 
-	protected native static long av_mallocz$2(@Ptr long size);
+	protected native static long av_mallocz(@Ptr long size);
 	/**
 	 * Allocate a memory block for an array with av_malloc().<br>
 	 * * The allocated memory will have size `size * nmemb` bytes.<br>
@@ -2031,11 +2031,11 @@ public class AvutilLibrary {
 	 * Original signature : <code>void* av_malloc_array(size_t, size_t)</code><br>
 	 * <i>native declaration : libavutil/mem.h:30</i>
 	 */
-	public static Pointer<? > av_malloc_array(@Ptr long nmemb, @Ptr long size) {
-		return Pointer.pointerToAddress(av_malloc_array$2(nmemb, size));
+	public static Pointer<? > av__malloc_array(@Ptr long nmemb, @Ptr long size) {
+		return Pointer.pointerToAddress(av_malloc_array(nmemb, size));
 	}
 	@Ptr 
-	protected native static long av_malloc_array$2(@Ptr long nmemb, @Ptr long size);
+	protected native static long av_malloc_array(@Ptr long nmemb, @Ptr long size);
 	/**
 	 * Allocate a memory block for an array with av_mallocz().<br>
 	 * * The allocated memory will have size `size * nmemb` bytes.<br>
@@ -2048,22 +2048,22 @@ public class AvutilLibrary {
 	 * Original signature : <code>void* av_mallocz_array(size_t, size_t)</code><br>
 	 * <i>native declaration : libavutil/mem.h:42</i>
 	 */
-	public static Pointer<? > av_mallocz_array(@Ptr long nmemb, @Ptr long size) {
-		return Pointer.pointerToAddress(av_mallocz_array$2(nmemb, size));
+	public static Pointer<? > av__mallocz_array(@Ptr long nmemb, @Ptr long size) {
+		return Pointer.pointerToAddress(av_mallocz_array(nmemb, size));
 	}
 	@Ptr 
-	protected native static long av_mallocz_array$2(@Ptr long nmemb, @Ptr long size);
+	protected native static long av_mallocz_array(@Ptr long nmemb, @Ptr long size);
 	/**
 	 * Non-inlined equivalent of av_mallocz_array().<br>
 	 * * Created for symmetry with the calloc() C function.<br>
 	 * Original signature : <code>void* av_calloc(size_t, size_t)</code><br>
 	 * <i>native declaration : libavutil/mem.h:48</i>
 	 */
-	public static Pointer<? > av_calloc(@Ptr long nmemb, @Ptr long size) {
-		return Pointer.pointerToAddress(av_calloc$2(nmemb, size));
+	public static Pointer<? > av__calloc(@Ptr long nmemb, @Ptr long size) {
+		return Pointer.pointerToAddress(av_calloc(nmemb, size));
 	}
 	@Ptr 
-	protected native static long av_calloc$2(@Ptr long nmemb, @Ptr long size);
+	protected native static long av_calloc(@Ptr long nmemb, @Ptr long size);
 	/**
 	 * Allocate, reallocate, or free a block of memory.<br>
 	 * * If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is<br>
@@ -2773,10 +2773,10 @@ public class AvutilLibrary {
 	 * Original signature : <code>void av_log_format_line(void*, int, const char*, va_list, char*, int, int*)</code><br>
 	 * <i>native declaration : libavutil/log.h:199</i>
 	 */
-	public static void av_log_format_line(Pointer<? > ptr, int level, Pointer<Byte > fmt, Pointer<Byte > vl, int line, Pointer<Integer > line_size, Object... vl) {
-		av_log_format_line(Pointer.getPeer(ptr), level, Pointer.getPeer(fmt), Pointer.getPeer(vl), line, Pointer.getPeer(line_size), vl);
+	public static void av_log_format_line(Pointer<? > ptr, int level, Pointer<Byte > fmt, Pointer<Byte > vl, int line, Pointer<Integer > line_size, Pointer<Integer > print_prefix) {
+		av_log_format_line(Pointer.getPeer(ptr), level, Pointer.getPeer(fmt), Pointer.getPeer(vl), line, Pointer.getPeer(line_size), Pointer.getPeer(print_prefix));
 	}
-	protected native static void av_log_format_line(@Ptr long ptr, int level, @Ptr long fmt, @Ptr long vl, int line, @Ptr long line_size, Object... vl);
+	protected native static void av_log_format_line(@Ptr long ptr, int level, @Ptr long fmt, @Ptr long vl, int line, @Ptr long line_size, @Ptr long print_prefix);
 	/**
 	 * Format a line of log the same way as the default callback.<br>
 	 * @param line          buffer to receive the formatted line;<br>
@@ -2793,10 +2793,10 @@ public class AvutilLibrary {
 	 * Original signature : <code>int av_log_format_line2(void*, int, const char*, va_list, char*, int, int*)</code><br>
 	 * <i>native declaration : libavutil/log.h:215</i>
 	 */
-	public static int av_log_format_line2(Pointer<? > ptr, int level, Pointer<Byte > fmt, Pointer<Byte > vl, int line, Pointer<Integer > line_size, Object... vl) {
-		return av_log_format_line2(Pointer.getPeer(ptr), level, Pointer.getPeer(fmt), Pointer.getPeer(vl), line, Pointer.getPeer(line_size), vl);
+	public static int av_log_format_line2(Pointer<? > ptr, int level, Pointer<Byte > fmt, Pointer<Byte > vl, int line, Pointer<Integer > line_size, Pointer<Integer > print_prefix) {
+		return av_log_format_line2(Pointer.getPeer(ptr), level, Pointer.getPeer(fmt), Pointer.getPeer(vl), line, Pointer.getPeer(line_size), Pointer.getPeer(print_prefix));
 	}
-	protected native static int av_log_format_line2(@Ptr long ptr, int level, @Ptr long fmt, @Ptr long vl, int line, @Ptr long line_size, Object... vl);
+	protected native static int av_log_format_line2(@Ptr long ptr, int level, @Ptr long fmt, @Ptr long vl, int line, @Ptr long line_size, @Ptr long print_prefix);
 	/**
 	 * Original signature : <code>void av_log_set_flags(int)</code><br>
 	 * <i>native declaration : libavutil/log.h:217</i>
@@ -2981,20 +2981,20 @@ public class AvutilLibrary {
 	 * Original signature : <code>AVBufferRef* av_buffer_alloc(int)</code><br>
 	 * <i>native declaration : libavutil/buffer.h:23</i>
 	 */
-	public static Pointer<AVBufferRef > av_buffer_alloc(int size) {
-		return Pointer.pointerToAddress(av_buffer_alloc$2(size), AVBufferRef.class);
+	public static Pointer<AVBufferRef > av__buffer_alloc(int size) {
+		return Pointer.pointerToAddress(av_buffer_alloc(size), AVBufferRef.class);
 	}
 	@Ptr 
-	protected native static long av_buffer_alloc$2(int size);
+	protected native static long av_buffer_alloc(int size);
 	/**
 	 * Original signature : <code>AVBufferRef* av_buffer_allocz(int)</code><br>
 	 * <i>native declaration : libavutil/buffer.h:25</i>
 	 */
-	public static Pointer<AVBufferRef > av_buffer_allocz(int size) {
-		return Pointer.pointerToAddress(av_buffer_allocz$2(size), AVBufferRef.class);
+	public static Pointer<AVBufferRef > av__buffer_allocz(int size) {
+		return Pointer.pointerToAddress(av_buffer_allocz(size), AVBufferRef.class);
 	}
 	@Ptr 
-	protected native static long av_buffer_allocz$2(int size);
+	protected native static long av_buffer_allocz(int size);
 	/**
 	 * Original signature : <code>AVBufferRef* av_buffer_create(uint8_t*, int, av_buffer_create_free_callback*, void*, int)</code><br>
 	 * <i>native declaration : libavutil/buffer.h:27</i>
@@ -3594,11 +3594,11 @@ public class AvutilLibrary {
 	 * Original signature : <code>AVFrame* av_frame_alloc()</code><br>
 	 * <i>native declaration : libavutil/frame.h:547</i>
 	 */
-	public static Pointer<AVFrame > av_frame_alloc() {
-		return Pointer.pointerToAddress(av_frame_alloc$2(), AVFrame.class);
+	public static Pointer<AVFrame > av__frame_alloc() {
+		return Pointer.pointerToAddress(av_frame_alloc(), AVFrame.class);
 	}
 	@Ptr 
-	protected native static long av_frame_alloc$2();
+	protected native static long av_frame_alloc();
 	/**
 	 * Free the frame and any dynamically allocated objects in it,<br>
 	 * e.g. extended_data. If the frame is reference counted, it will be<br>
@@ -5286,11 +5286,11 @@ public class AvutilLibrary {
 	 * Original signature : <code>char* av_d2str(double)</code><br>
 	 * <i>native declaration : libavutil/avstring.h:110</i>
 	 */
-	public static Pointer<Byte > av_d2str(double d) {
-		return Pointer.pointerToAddress(av_d2str$2(d), Byte.class);
+	public static Pointer<Byte > av__d2str(double d) {
+		return Pointer.pointerToAddress(av_d2str(d), Byte.class);
 	}
 	@Ptr 
-	protected native static long av_d2str$2(double d);
+	protected native static long av_d2str(double d);
 	/**
 	 * Unescape the given string until a non escaped terminating char,<br>
 	 * and return the token corresponding to the unescaped string.<br>
@@ -5756,11 +5756,11 @@ public class AvutilLibrary {
 	 * Original signature : <code>char* av_get_channel_name(uint64_t)</code><br>
 	 * <i>native declaration : ./libavutil/channel_layout.h:81</i>
 	 */
-	public static Pointer<Byte > av_get_channel_name(long channel) {
-		return Pointer.pointerToAddress(av_get_channel_name$2(channel), Byte.class);
+	public static Pointer<Byte > av__get_channel_name(long channel) {
+		return Pointer.pointerToAddress(av_get_channel_name(channel), Byte.class);
 	}
 	@Ptr 
-	protected native static long av_get_channel_name$2(long channel);
+	protected native static long av_get_channel_name(long channel);
 	/**
 	 * Get the description of a given channel.<br>
 	 * * @param channel  a channel layout with a single channel<br>
@@ -5768,11 +5768,11 @@ public class AvutilLibrary {
 	 * Original signature : <code>char* av_get_channel_description(uint64_t)</code><br>
 	 * <i>native declaration : ./libavutil/channel_layout.h:88</i>
 	 */
-	public static Pointer<Byte > av_get_channel_description(long channel) {
-		return Pointer.pointerToAddress(av_get_channel_description$2(channel), Byte.class);
+	public static Pointer<Byte > av__get_channel_description(long channel) {
+		return Pointer.pointerToAddress(av_get_channel_description(channel), Byte.class);
 	}
 	@Ptr 
-	protected native static long av_get_channel_description$2(long channel);
+	protected native static long av_get_channel_description(long channel);
 	/**
 	 * Get the value and name of a standard channel layout.<br>
 	 * * @param[in]  index   index in an internal list, starting at 0<br>
diff -pruN generated/org/ffmpeg/FFMPeg.java src/org/ffmpeg/FFMPeg.java
--- generated/org/ffmpeg/FFMPeg.java	1970-01-01 01:00:00.000000000 +0100
+++ src/org/ffmpeg/FFMPeg.java	2021-06-15 09:24:07.407078646 +0200
@@ -0,0 +1,37 @@
+package org.ffmpeg;
+
+import org.ffmpeg.avcodec.AvcodecLibrary;
+import org.ffmpeg.avdevice.AvdeviceLibrary;
+import org.ffmpeg.avfilter.AvfilterLibrary;
+import org.ffmpeg.avformat.AvformatLibrary;
+import org.ffmpeg.avresample.AvresampleLibrary;
+import org.ffmpeg.avutil.AvutilLibrary;
+import org.ffmpeg.postproc.PostprocLibrary;
+import org.ffmpeg.swresample.SwresampleLibrary;
+import org.ffmpeg.swscale.SwscaleLibrary;
+
+public class FFMPeg {
+
+	public static void main(String[] args) {
+		System.out.println("Java-Bibliothek ffmpeg.jar");
+		System.out.println("==========================");
+		System.out.println("Die Bibliothek ffmpeg ist nur in den Bruchteilen implementiert, die für\n"
+				+ "Open Source Physics tracker benötigt werden.");
+		System.out.println("ffmpeg in Version "+AvutilLibrary.FFMPEG_VERSION);
+		System.out.println("Bestandteile:");
+		System.out.println("avcodec in Version "+AvcodecLibrary.avcodec_version());
+		System.out.println("avdevice in Version "+AvdeviceLibrary.avdevice_version());
+		System.out.println("avfilter in Version "+AvfilterLibrary.avfilter_version());
+		System.out.println("avformat in Version "+AvformatLibrary.avformat_version());
+		System.out.println("avresample in Version "+AvresampleLibrary.avresample_version());
+		System.out.println("avutil in Version "+AvutilLibrary.avutil_version());
+		System.out.println("avpostproc in Version "+PostprocLibrary.postproc_version());
+		System.out.println("swresample in Version "+SwresampleLibrary.swresample_version());
+		System.out.println("swscale in Version "+SwscaleLibrary.swscale_version());
+	}
+	
+	public static String getVersion() {
+		return AvutilLibrary.FFMPEG_VERSION;
+	}
+	
+}
diff -pruN generated/org/ffmpeg/postproc/PostprocLibrary.java src/org/ffmpeg/postproc/PostprocLibrary.java
--- generated/org/ffmpeg/postproc/PostprocLibrary.java	2021-06-15 09:23:37.187200747 +0200
+++ src/org/ffmpeg/postproc/PostprocLibrary.java	2021-06-15 09:24:07.407078646 +0200
@@ -80,21 +80,21 @@ public class PostprocLibrary {
 	 * Original signature : <code>char* postproc_configuration()</code><br>
 	 * <i>native declaration : libpostproc/postprocess.h:9</i>
 	 */
-	public static Pointer<Byte > postproc_configuration() {
-		return Pointer.pointerToAddress(postproc_configuration$2(), Byte.class);
+	public static Pointer<Byte > postproc__configuration() {
+		return Pointer.pointerToAddress(postproc_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long postproc_configuration$2();
+	protected native static long postproc_configuration();
 	/**
 	 * Return the libpostproc license.<br>
 	 * Original signature : <code>char* postproc_license()</code><br>
 	 * <i>native declaration : libpostproc/postprocess.h:14</i>
 	 */
-	public static Pointer<Byte > postproc_license() {
-		return Pointer.pointerToAddress(postproc_license$2(), Byte.class);
+	public static Pointer<Byte > postproc__license() {
+		return Pointer.pointerToAddress(postproc_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long postproc_license$2();
+	protected native static long postproc_license();
 	/**
 	 * Original signature : <code>void pp_postprocess(const uint8_t*[3], const int[3], uint8_t*[3], const int[3], int, int, const int8_t*, int, pp_mode*, pp_context*, int)</code><br>
 	 * <i>native declaration : libpostproc/postprocess.h:5</i>
@@ -127,11 +127,11 @@ public class PostprocLibrary {
 	 * Original signature : <code>pp_context* pp_get_context(int, int, int)</code><br>
 	 * <i>native declaration : libpostproc/postprocess.h:16</i>
 	 */
-	public static Pointer<? > pp_get_context(int width, int height, int flags) {
-		return Pointer.pointerToAddress(pp_get_context$2(width, height, flags));
+	public static Pointer<? > pp__get_context(int width, int height, int flags) {
+		return Pointer.pointerToAddress(pp_get_context(width, height, flags));
 	}
 	@Ptr 
-	protected native static long pp_get_context$2(int width, int height, int flags);
+	protected native static long pp_get_context(int width, int height, int flags);
 	/**
 	 * Original signature : <code>void pp_free_context(pp_context*)</code><br>
 	 * <i>native declaration : libpostproc/postprocess.h:18</i>
diff -pruN generated/org/ffmpeg/swresample/SwresampleLibrary.java src/org/ffmpeg/swresample/SwresampleLibrary.java
--- generated/org/ffmpeg/swresample/SwresampleLibrary.java	2021-06-15 09:23:35.299208390 +0200
+++ src/org/ffmpeg/swresample/SwresampleLibrary.java	2021-06-15 09:24:07.411078629 +0200
@@ -147,11 +147,11 @@ public class SwresampleLibrary {
 	 * Original signature : <code>AVClass* swr_get_class()</code><br>
 	 * <i>native declaration : libswresample/swresample.h:47</i>
 	 */
-	public static Pointer<AVClass > swr_get_class() {
-		return Pointer.pointerToAddress(swr_get_class$2(), AVClass.class);
+	public static Pointer<AVClass > swr__get_class() {
+		return Pointer.pointerToAddress(swr_get_class(), AVClass.class);
 	}
 	@Ptr 
-	protected native static long swr_get_class$2();
+	protected native static long swr_get_class();
 	/**
 	 * Allocate SwrContext.<br>
 	 * * If you use this function you will need to set the parameters (manually or<br>
@@ -161,11 +161,11 @@ public class SwresampleLibrary {
 	 * Original signature : <code>SwrContext* swr_alloc()</code><br>
 	 * <i>native declaration : libswresample/swresample.h:56</i>
 	 */
-	public static Pointer<SwrContext > swr_alloc() {
-		return Pointer.pointerToAddress(swr_alloc$2(), SwrContext.class);
+	public static Pointer<SwrContext > swr__alloc() {
+		return Pointer.pointerToAddress(swr_alloc(), SwrContext.class);
 	}
 	@Ptr 
-	protected native static long swr_alloc$2();
+	protected native static long swr_alloc();
 	/**
 	 * Initialize context after user parameters have been set.<br>
 	 * @note The context must be configured using the AVOption API.<br>
@@ -449,22 +449,22 @@ public class SwresampleLibrary {
 	 * Original signature : <code>char* swresample_configuration()</code><br>
 	 * <i>native declaration : libswresample/swresample.h:277</i>
 	 */
-	public static Pointer<Byte > swresample_configuration() {
-		return Pointer.pointerToAddress(swresample_configuration$2(), Byte.class);
+	public static Pointer<Byte > swresample__configuration() {
+		return Pointer.pointerToAddress(swresample_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long swresample_configuration$2();
+	protected native static long swresample_configuration();
 	/**
 	 * Return the swr license.<br>
 	 * * @returns     the license of libswresample, determined at build-time<br>
 	 * Original signature : <code>char* swresample_license()</code><br>
 	 * <i>native declaration : libswresample/swresample.h:283</i>
 	 */
-	public static Pointer<Byte > swresample_license() {
-		return Pointer.pointerToAddress(swresample_license$2(), Byte.class);
+	public static Pointer<Byte > swresample__license() {
+		return Pointer.pointerToAddress(swresample_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long swresample_license$2();
+	protected native static long swresample_license();
 	/**
 	 * Convert the samples in the input AVFrame and write them to the output AVFrame.<br>
 	 * * Input and output AVFrames must have channel_layout, sample_rate and format set.<br>
diff -pruN generated/org/ffmpeg/swscale/SwscaleLibrary.java src/org/ffmpeg/swscale/SwscaleLibrary.java
--- generated/org/ffmpeg/swscale/SwscaleLibrary.java	2021-06-15 09:23:35.407207953 +0200
+++ src/org/ffmpeg/swscale/SwscaleLibrary.java	2021-06-15 09:24:07.411078629 +0200
@@ -121,21 +121,21 @@ public class SwscaleLibrary {
 	 * Original signature : <code>char* swscale_configuration()</code><br>
 	 * <i>native declaration : libswscale/swscale.h:12</i>
 	 */
-	public static Pointer<Byte > swscale_configuration() {
-		return Pointer.pointerToAddress(swscale_configuration$2(), Byte.class);
+	public static Pointer<Byte > swscale__configuration() {
+		return Pointer.pointerToAddress(swscale_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long swscale_configuration$2();
+	protected native static long swscale_configuration();
 	/**
 	 * Return the libswscale license.<br>
 	 * Original signature : <code>char* swscale_license()</code><br>
 	 * <i>native declaration : libswscale/swscale.h:17</i>
 	 */
-	public static Pointer<Byte > swscale_license() {
-		return Pointer.pointerToAddress(swscale_license$2(), Byte.class);
+	public static Pointer<Byte > swscale__license() {
+		return Pointer.pointerToAddress(swscale_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long swscale_license$2();
+	protected native static long swscale_license();
 	/**
 	 * Return a pointer to yuv<->rgb coefficients for the given colorspace<br>
 	 * suitable for sws_setColorspaceDetails().<br>
@@ -144,11 +144,11 @@ public class SwscaleLibrary {
 	 * Original signature : <code>int* sws_getCoefficients(int)</code><br>
 	 * <i>native declaration : libswscale/swscale.h:25</i>
 	 */
-	public static Pointer<Integer > sws_getCoefficients(int colorspace) {
-		return Pointer.pointerToAddress(sws_getCoefficients$2(colorspace), Integer.class);
+	public static Pointer<Integer > sws__getCoefficients(int colorspace) {
+		return Pointer.pointerToAddress(sws_getCoefficients(colorspace), Integer.class);
 	}
 	@Ptr 
-	protected native static long sws_getCoefficients$2(int colorspace);
+	protected native static long sws_getCoefficients(int colorspace);
 	/**
 	 * Return a positive value if pix_fmt is a supported input format, 0<br>
 	 * otherwise.<br>
@@ -187,11 +187,11 @@ public class SwscaleLibrary {
 	 * Original signature : <code>SwsContext* sws_alloc_context()</code><br>
 	 * <i>native declaration : libswscale/swscale.h:66</i>
 	 */
-	public static Pointer<SwscaleLibrary.SwsContext > sws_alloc_context() {
-		return Pointer.pointerToAddress(sws_alloc_context$2(), SwscaleLibrary.SwsContext.class);
+	public static Pointer<SwscaleLibrary.SwsContext > sws__alloc_context() {
+		return Pointer.pointerToAddress(sws_alloc_context(), SwscaleLibrary.SwsContext.class);
 	}
 	@Ptr 
-	protected native static long sws_alloc_context$2();
+	protected native static long sws_alloc_context();
 	/**
 	 * Original signature : <code>int sws_init_context(SwsContext*, SwsFilter*, SwsFilter*)</code><br>
 	 * <i>native declaration : libswscale/swscale.h:68</i>
@@ -297,22 +297,22 @@ public class SwscaleLibrary {
 	 * Original signature : <code>SwsVector* sws_allocVec(int)</code><br>
 	 * <i>native declaration : libswscale/swscale.h:144</i>
 	 */
-	public static Pointer<SwsVector > sws_allocVec(int length) {
-		return Pointer.pointerToAddress(sws_allocVec$2(length), SwsVector.class);
+	public static Pointer<SwsVector > sws__allocVec(int length) {
+		return Pointer.pointerToAddress(sws_allocVec(length), SwsVector.class);
 	}
 	@Ptr 
-	protected native static long sws_allocVec$2(int length);
+	protected native static long sws_allocVec(int length);
 	/**
 	 * Return a normalized Gaussian curve used to filter stuff<br>
 	 * quality = 3 is high quality, lower is lower quality.<br>
 	 * Original signature : <code>SwsVector* sws_getGaussianVec(double, double)</code><br>
 	 * <i>native declaration : libswscale/swscale.h:150</i>
 	 */
-	public static Pointer<SwsVector > sws_getGaussianVec(double variance, double quality) {
-		return Pointer.pointerToAddress(sws_getGaussianVec$2(variance, quality), SwsVector.class);
+	public static Pointer<SwsVector > sws__getGaussianVec(double variance, double quality) {
+		return Pointer.pointerToAddress(sws_getGaussianVec(variance, quality), SwsVector.class);
 	}
 	@Ptr 
-	protected native static long sws_getGaussianVec$2(double variance, double quality);
+	protected native static long sws_getGaussianVec(double variance, double quality);
 	/**
 	 * Scale all the coefficients of a by the scalar value.<br>
 	 * Original signature : <code>void sws_scaleVec(SwsVector*, double)</code><br>
@@ -335,20 +335,20 @@ public class SwscaleLibrary {
 	 * Original signature : <code>SwsVector* sws_getConstVec(double, int)</code><br>
 	 * <i>native declaration : libswscale/swscale.h:162</i>
 	 */
-	public static Pointer<SwsVector > sws_getConstVec(double c, int length) {
-		return Pointer.pointerToAddress(sws_getConstVec$2(c, length), SwsVector.class);
+	public static Pointer<SwsVector > sws__getConstVec(double c, int length) {
+		return Pointer.pointerToAddress(sws_getConstVec(c, length), SwsVector.class);
 	}
 	@Ptr 
-	protected native static long sws_getConstVec$2(double c, int length);
+	protected native static long sws_getConstVec(double c, int length);
 	/**
 	 * Original signature : <code>SwsVector* sws_getIdentityVec()</code><br>
 	 * <i>native declaration : libswscale/swscale.h:164</i>
 	 */
-	public static Pointer<SwsVector > sws_getIdentityVec() {
-		return Pointer.pointerToAddress(sws_getIdentityVec$2(), SwsVector.class);
+	public static Pointer<SwsVector > sws__getIdentityVec() {
+		return Pointer.pointerToAddress(sws_getIdentityVec(), SwsVector.class);
 	}
 	@Ptr 
-	protected native static long sws_getIdentityVec$2();
+	protected native static long sws_getIdentityVec();
 	/**
 	 * Original signature : <code>void sws_convVec(SwsVector*, SwsVector*)</code><br>
 	 * <i>native declaration : libswscale/swscale.h:166</i>
@@ -410,11 +410,11 @@ public class SwscaleLibrary {
 	 * Original signature : <code>SwsFilter* sws_getDefaultFilter(float, float, float, float, float, float, int)</code><br>
 	 * <i>native declaration : libswscale/swscale.h:180</i>
 	 */
-	public static Pointer<SwsFilter > sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose) {
-		return Pointer.pointerToAddress(sws_getDefaultFilter$2(lumaGBlur, chromaGBlur, lumaSharpen, chromaSharpen, chromaHShift, chromaVShift, verbose), SwsFilter.class);
+	public static Pointer<SwsFilter > sws__getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose) {
+		return Pointer.pointerToAddress(sws_getDefaultFilter(lumaGBlur, chromaGBlur, lumaSharpen, chromaSharpen, chromaHShift, chromaVShift, verbose), SwsFilter.class);
 	}
 	@Ptr 
-	protected native static long sws_getDefaultFilter$2(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose);
+	protected native static long sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose);
 	/**
 	 * Original signature : <code>void sws_freeFilter(SwsFilter*)</code><br>
 	 * <i>native declaration : libswscale/swscale.h:182</i>
@@ -475,11 +475,11 @@ public class SwscaleLibrary {
 	 * Original signature : <code>AVClass* sws_get_class()</code><br>
 	 * <i>native declaration : libswscale/swscale.h:221</i>
 	 */
-	public static Pointer<AVClass > sws_get_class() {
-		return Pointer.pointerToAddress(sws_get_class$2(), AVClass.class);
+	public static Pointer<AVClass > sws__get_class() {
+		return Pointer.pointerToAddress(sws_get_class(), AVClass.class);
 	}
 	@Ptr 
-	protected native static long sws_get_class$2();
+	protected native static long sws_get_class();
 	/** Undefined type */
 	public static interface SwsContext {
 		
diff -pruN generated/org/ffmpeg/util/AlignmentCustomizer.java src/org/ffmpeg/util/AlignmentCustomizer.java
--- generated/org/ffmpeg/util/AlignmentCustomizer.java	1970-01-01 01:00:00.000000000 +0100
+++ src/org/ffmpeg/util/AlignmentCustomizer.java	2021-06-15 09:24:07.411078629 +0200
@@ -0,0 +1,26 @@
+package org.ffmpeg.util;
+
+import java.util.List;
+
+import org.bridj.Platform;
+import org.bridj.StructCustomizer;
+import org.bridj.StructDescription;
+import org.bridj.StructFieldDescription;
+import org.bridj.ann.Alignment;
+
+@SuppressWarnings("deprecation")
+public class AlignmentCustomizer extends StructCustomizer {
+	@Override
+	public void beforeLayout(StructDescription desc,
+			List<StructFieldDescription> aggregatedFields) {
+		for (StructFieldDescription field : aggregatedFields) {
+			if(field.field.isAnnotationPresent(Alignment.class))
+				continue;
+			if (Platform.isLinux() && !Platform.is64Bits()) {
+				field.alignment = 4;
+			} else {
+				field.alignment = 8;
+			}
+		}
+	}
+}
diff -pruN generated/test/AVInfo.java src/test/AVInfo.java
--- generated/test/AVInfo.java	1970-01-01 01:00:00.000000000 +0100
+++ src/test/AVInfo.java	2021-06-15 09:24:07.411078629 +0200
@@ -0,0 +1,64 @@
+package test;
+
+import static org.ffmpeg.avformat.AvformatLibrary.av_dump_format;
+import static org.ffmpeg.avformat.AvformatLibrary.av_register_all;
+import static org.ffmpeg.avformat.AvformatLibrary.avformat_close_input;
+import static org.ffmpeg.avformat.AvformatLibrary.avformat_open_input;
+
+import java.io.IOException;
+
+import org.bridj.Pointer;
+import org.ffmpeg.avformat.AVFormatContext;
+import org.ffmpeg.avformat.AVStream;
+
+public class AVInfo {
+	public static String src_filename;
+	public static Pointer<AVFormatContext> fmt_ctx;
+	public static Pointer<AVStream> stream;
+	
+	public static void main(String[] args) {
+		int ret = 0;
+
+		if (args.length != 1) {
+			System.err.printf("usage: AVInfo input_file \n"
+					+ "API example program to show input file infos.\n" + "\n");
+			System.exit(1);
+		}
+		src_filename = args[0];
+		try {
+			/* register all formats and codecs */
+			av_register_all();
+
+			/* open input file, and allocate format context */
+			Pointer<Pointer<AVFormatContext>> pfmt_ctx = Pointer
+					.allocatePointer(AVFormatContext.class);
+			if (avformat_open_input(pfmt_ctx,
+					Pointer.pointerToCString(src_filename), null, null) < 0) {
+				System.err.printf("Could not open source file %s\n",
+						src_filename);
+				System.exit(1);
+			}
+
+			fmt_ctx = pfmt_ctx.get();
+			/* dump input information to stderr */
+			av_dump_format(fmt_ctx, 0, Pointer.pointerToCString(src_filename), 0);
+
+			int streams = fmt_ctx.get().nb_streams();
+			for(int index = 0;index<streams;index++){
+				stream = fmt_ctx.get().streams().get(index);
+				
+			}
+			// } catch (IOException e) {
+			// e.printStackTrace();
+			// System.exit(1);
+		} finally {
+			System.err.print("freeing fmt_ctx...");
+			if (fmt_ctx != null) {
+				avformat_close_input(fmt_ctx.getReference());
+			}
+			System.err.println("freed");
+			System.exit(ret);
+		}
+	}
+
+}
diff -pruN generated/test/Demuxing.java src/test/Demuxing.java
--- generated/test/Demuxing.java	1970-01-01 01:00:00.000000000 +0100
+++ src/test/Demuxing.java	2021-06-15 09:24:07.411078629 +0200
@@ -0,0 +1,390 @@
+package test;
+
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+
+import org.bridj.IntValuedEnum;
+import org.bridj.Pointer;
+import org.ffmpeg.avcodec.AVCodec;
+import org.ffmpeg.avcodec.AVCodecContext;
+import org.ffmpeg.avcodec.AvcodecLibrary;
+import org.ffmpeg.avcodec.AVPacket;
+import org.ffmpeg.avformat.AVFormatContext;
+import org.ffmpeg.avformat.AVStream;
+import org.ffmpeg.avformat.AvformatLibrary;
+import org.ffmpeg.avutil.AVFrame;
+import org.ffmpeg.avutil.AvutilLibrary;
+import org.ffmpeg.avutil.AvutilLibrary.AVMediaType;
+import org.ffmpeg.avutil.AvutilLibrary.AVSampleFormat;
+
+import static org.ffmpeg.avcodec.AvcodecLibrary.*;
+import static org.ffmpeg.avutil.AvutilLibrary.*;
+import static org.ffmpeg.avformat.AvformatLibrary.*;
+import static org.ffmpeg.avutil.AVUtil.*;
+import static org.ffmpeg.avutil.AvutilLibrary.AVSampleFormat.*;
+
+/**
+ * @file libavformat demuxing API use example.
+ * 
+ *       Show how to use the libavformat and libavcodec API to demux and decode
+ *       audio and video data.
+ * @example doc/examples/demuxing.c
+ */
+
+public class Demuxing {
+	static Pointer<AVFormatContext> fmt_ctx = null;
+	static Pointer<AVCodecContext> video_dec_ctx = null, audio_dec_ctx;
+	static Pointer<AVStream> video_stream = null, audio_stream = null;
+	static Pointer<Byte> streamptr = null; 
+	static String src_filename = null;
+	static String video_dst_filename = null;
+	static String audio_dst_filename = null;
+	static FileOutputStream video_dst_file = null;
+	static FileOutputStream audio_dst_file = null;
+
+	static Pointer<Pointer<Byte>> video_dst_data = Pointer.allocatePointers(Byte.class, 4);
+	static Pointer<Integer> video_dst_linesize = Pointer.allocateInts(4);
+	static int video_dst_bufsize;
+
+	static Pointer<Integer> video_stream_idx = Pointer.allocateInt(), 
+			audio_stream_idx = Pointer.allocateInt();
+	static Pointer<AVFrame> frame = null;
+	static Pointer<AVPacket> pkt = null;
+	static int video_frame_count = 0;
+	static int audio_frame_count = 0;
+	static AvformatLibrary lavf = new AvformatLibrary();
+	static AvcodecLibrary lavc = new AvcodecLibrary();
+	static AvutilLibrary lavu = new AvutilLibrary();
+	
+	static boolean first_frame = true;
+
+	static int decode_packet(Pointer<Integer> got_frame, int cached)
+			throws IOException {
+		int ret = 0;
+		int decoded = pkt.get().size();
+		got_frame.setInt(0);
+
+		if (pkt.get().stream_index() == video_stream_idx.get()) {
+			/* decode video frame */
+			ret = avcodec_decode_video2(video_dec_ctx, frame, got_frame,
+					pkt);
+			if (ret < 0) {
+				System.err.printf("Error decoding video frame\n");
+				return ret;
+			}
+
+			if (got_frame.get() != 0) {
+				if(first_frame) {
+					first_frame = false;
+					StructInfo.printAVFrame(frame.get());
+				}
+				System.out.printf("video_frame%s n:%d coded_n:%d pts:%s\n",
+						cached != 0 ? "(cached)" : "", video_frame_count++,
+						frame.get().coded_picture_number(), av_ts2timestr(
+								frame.get().pts(), video_dec_ctx.get().time_base()));
+
+				/*
+				 * copy decoded frame to destination buffer: this is required
+				 * since rawvideo expects non aligned data
+				 */
+				av_image_copy(video_dst_data, video_dst_linesize,
+						frame.get().data(), frame.get().linesize(), video_dec_ctx.get().pix_fmt(),
+						video_dec_ctx.get().width(), video_dec_ctx.get().height());
+
+				/* write to rawvideo file */
+				streamptr = video_dst_data.get();
+				video_dst_file.write(streamptr.getBytes(video_dst_bufsize));
+			}
+		} else if (pkt.get().stream_index() == audio_stream_idx.get()) {
+			/* decode audio frame */
+			ret = avcodec_decode_audio4(audio_dec_ctx, frame, got_frame,
+					pkt);
+			if (ret < 0) {
+				System.err.printf("Error decoding audio frame\n");
+				return ret;
+			}
+			/*
+			 * Some audio decoders decode only part of the packet, and have to
+			 * be called again with the remainder of the packet data. Sample:
+			 * fate-suite/lossless-audio/luckynight-partial.shn Also, some
+			 * decoders might over-read the packet.
+			 */
+			decoded = Math.min(ret, pkt.get().size());
+
+			if (got_frame.get() != 0) {
+				int unpadded_linesize = frame.get().nb_samples()
+						* av_get_bytes_per_sample(AVSampleFormat.fromValue(frame.get().format()));
+				System.out.printf("audio_frame%s n:%d nb_samples:%d pts:%s\n",
+						cached != 0 ? "(cached)" : "", audio_frame_count++,
+						frame.get().nb_samples(), av_ts2timestr(frame.get().pts(),
+								audio_dec_ctx.get().time_base()));
+
+				/*
+				 * Write the raw audio data samples of the first plane. This
+				 * works fine for packed formats (e.g. AV_SAMPLE_FMT_S16).
+				 * However, most audio decoders output planar audio, which uses
+				 * a separate plane of audio samples for each channel (e.g.
+				 * AV_SAMPLE_FMT_S16P). In other words, this code will write
+				 * only the first audio channel in these cases. You should use
+				 * libswresample or libavfilter to convert the frame to packed
+				 * data.
+				 */
+				streamptr = frame.get().extended_data().get();
+				audio_dst_file.write(streamptr.getBytes(unpadded_linesize));
+			}
+		}
+
+		return decoded;
+	}
+
+	static int open_codec_context(Pointer<Integer> stream_idx,
+			Pointer<AVFormatContext> fmt_ctx, AVMediaType type) {
+		int ret;
+		Pointer<AVStream> st;
+		Pointer<AVCodecContext> dec_ctx = null;
+		Pointer<AVCodec> dec = null;
+
+		ret = av_find_best_stream(fmt_ctx, type, -1, -1, null, 0);
+		if (ret < 0) {
+			System.err.printf("Could not find %s stream in input file '%s'\n",
+					av_get_media_type_string(type).getCString(), src_filename);
+			return ret;
+		} else {
+			stream_idx.set(ret);
+			st = fmt_ctx.get().streams().get(stream_idx.get());
+
+			/* find decoder for the stream */
+			dec_ctx = st.get().codec();
+			dec = avcodec_find_decoder(dec_ctx.get().codec_id());
+			if (dec == null) {
+				System.err.printf("Failed to find %s codec\n",
+						av_get_media_type_string(type));
+				return ret;
+			}
+
+			if ((ret = avcodec_open2(dec_ctx, dec, null)) < 0) {
+				System.err.printf("Failed to open %s codec\n",
+						av_get_media_type_string(type));
+				return ret;
+			}
+		}
+
+		return 0;
+	}
+
+	static String get_format_from_sample_fmt(IntValuedEnum<AVSampleFormat> sample_fmt) {
+		if(sample_fmt.value() == AV_SAMPLE_FMT_U8.value())
+			return "u8";
+		else if(sample_fmt.value() == AV_SAMPLE_FMT_S16.value())
+			return "s16le";
+		else if(sample_fmt.value() == AV_SAMPLE_FMT_S32.value())
+			return "s32le";
+		else if(sample_fmt.value() == AV_SAMPLE_FMT_FLT.value())
+			return "f32le";
+		else if(sample_fmt.value() == AV_SAMPLE_FMT_DBL.value())
+			return "f64le";
+		System.err.printf(
+				"sample format %s is not supported as output format\n",
+				av_get_sample_fmt_name(sample_fmt));
+		return null;
+	}
+
+	public static void main(String[] args) throws IOException {
+		int ret = 0;
+		Pointer<Integer> got_frame = Pointer.allocateInt();
+		got_frame.set(0);
+		video_stream_idx.set(-1);
+		audio_stream_idx.set(-1);
+		if (args.length != 3) {
+			System.err
+					.printf("usage: Demuxing input_file video_output_file audio_output_file\n"
+							+ "API example program to show how to read frames from an input file.\n"
+							+ "This program reads frames from a file, decodes them, and writes decoded\n"
+							+ "video frames to a rawvideo file named video_output_file, and decoded\n"
+							+ "audio frames to a rawaudio file named audio_output_file.\n"
+							+ "\n");
+			System.exit(1);
+		}
+		src_filename = args[0];
+		video_dst_filename = args[1];
+		audio_dst_filename = args[2];
+
+		try {
+			/* register all formats and codecs */
+			av_register_all();
+
+			/* open input file, and allocate format context */
+			Pointer<Pointer<AVFormatContext>> pfmt_ctx = Pointer.allocatePointer(AVFormatContext.class);
+			if (avformat_open_input(pfmt_ctx, Pointer.pointerToCString(src_filename), null, null) < 0) {
+				System.err.printf("Could not open source file %s\n",
+						src_filename);
+				System.exit(1);
+			}
+
+			fmt_ctx = pfmt_ctx.get();
+			/* retrieve stream information */
+			if (avformat_find_stream_info(fmt_ctx, null) < 0) {
+				System.err.printf("Could not find stream information\n");
+				System.exit(1);
+			}
+			
+			if (open_codec_context(video_stream_idx, fmt_ctx,
+					AVMediaType.AVMEDIA_TYPE_VIDEO) >= 0) {
+				video_stream = fmt_ctx.get().streams().get(video_stream_idx.get());
+				video_dec_ctx = video_stream.get().codec();
+
+				try {
+					video_dst_file = new FileOutputStream(video_dst_filename);
+				} catch (IOException e) {
+					System.err.printf("Could not open destination file %s\n",
+							video_dst_filename);
+					ret = 1;
+					System.exit(1);
+				}
+
+				/* allocate image where the decoded image will be put */
+				ret = av_image_alloc(video_dst_data, video_dst_linesize,
+						video_dec_ctx.get().width(), video_dec_ctx.get().height(),
+						video_dec_ctx.get().pix_fmt(), 1);
+				if (ret < 0) {
+					System.err.printf("Could not allocate raw video buffer\n");
+					System.exit(ret);
+				}
+				video_dst_bufsize = ret;
+			}
+
+			if (open_codec_context(audio_stream_idx, fmt_ctx,
+					AVMediaType.AVMEDIA_TYPE_AUDIO) >= 0) {
+				audio_stream = fmt_ctx.get().streams().get(audio_stream_idx.get());
+				audio_dec_ctx = audio_stream.get().codec();
+				try {
+					audio_dst_file = new FileOutputStream(audio_dst_filename);
+				} catch (IOException e) {
+					System.err.printf("Could not open destination file %s\n",
+							video_dst_filename);
+					System.exit(1);
+				}
+			}
+
+			/* dump input information to stderr */
+			av_dump_format(fmt_ctx, 0, Pointer.pointerToCString(src_filename), 0);
+
+			if (audio_stream == null && video_stream == null) {
+				System.err
+						.printf("Could not find audio or video stream in the input, aborting\n");
+				System.exit(1);
+			}
+
+			// FIXME: frame = alloc_frame(); 3.0.2
+			if (frame == null) {
+				System.err.printf("Could not allocate frame\n");
+				System.exit(1);
+			}
+
+			/* initialize packet, set data to null, let the demuxer fill it */
+			pkt = Pointer.allocate(AVPacket.class);
+			av_init_packet(pkt);
+			pkt.get().data(null);
+			pkt.get().size(0);
+
+			if (video_stream != null)
+				System.out.printf("Demuxing video from file '%s' into '%s'\n",
+						src_filename, video_dst_filename);
+			if (audio_stream != null)
+				System.out.printf("Demuxing audio from file '%s' into '%s'\n",
+						src_filename, audio_dst_filename);
+
+			/* read frames from the file */
+			while (av_read_frame(fmt_ctx, pkt) >= 0) {
+				Pointer<AVPacket> orig_pkt = pkt;
+				do {
+					ret = decode_packet(got_frame, 0);
+					if (ret < 0)
+						break;
+					long ptr = pkt.get().data().getPeer();
+					ptr+=ret;
+					pkt.get().data((Pointer<Byte>)Pointer.pointerToAddress(ptr));
+					pkt.get().size(pkt.get().size()-ret);
+				} while (pkt.get().size() > 0);
+				av_free_packet(orig_pkt);
+			}
+
+			/* flush cached frames */
+			pkt.get().data(null);
+			pkt.get().size(0);
+			do {
+				got_frame.set(0);
+				decode_packet(got_frame, 1);
+			} while (got_frame.get() != 0);
+
+			System.out.printf("Demuxing succeeded.\n");
+
+			if (video_stream != null) {
+				System.out
+						.printf("Play the output video file with the command:\n"
+								+ "ffplay -f rawvideo -pix_fmt %s -video_size %dx%d %s\n",
+								av_get_pix_fmt_name(video_dec_ctx.get().pix_fmt()).getCString(),
+								video_dec_ctx.get().width(), video_dec_ctx.get().height(),
+								video_dst_filename);
+			}
+
+			if (audio_stream != null) {
+				IntValuedEnum<AVSampleFormat> sfmt = audio_dec_ctx.get().sample_fmt();
+				int n_channels = audio_dec_ctx.get().channels();
+				String fmt;
+
+				if (av_sample_fmt_is_planar(sfmt) != 0) {
+					String packed = av_get_sample_fmt_name(sfmt).getCString();
+					System.out
+							.printf("Warning: the sample format the decoder produced is planar "
+									+ "(%s). This example will output the first channel only.\n",
+									packed != null ? packed : "?");
+					sfmt = av_get_packed_sample_fmt(sfmt);
+					n_channels = 1;
+				}
+
+				if ((fmt = get_format_from_sample_fmt(sfmt)) == null)
+					System.exit(-1);
+				ret = 0;
+				System.out.printf(
+						"Play the output audio file with the command:\n"
+								+ "ffplay -f %s -ac %d -ar %d %s\n", fmt,
+						n_channels, audio_dec_ctx.get().sample_rate(),
+						audio_dst_filename);
+			}
+
+		} catch (IOException e) {
+			e.printStackTrace();
+			System.exit(1);
+		} finally {
+			System.err.print("freeing video_dec_ctx..");
+			if (video_dec_ctx != null)
+				avcodec_close(video_dec_ctx);
+			System.err.println("freed");
+			System.err.print("freeing audio_dec_ctx...");
+			if (audio_dec_ctx != null)
+				avcodec_close(audio_dec_ctx);
+			System.err.println("freed");
+			System.err.print("freeing fmt_ctx...");
+			if(fmt_ctx != null) {
+				avformat_close_input(fmt_ctx.getReference());
+			}
+			System.err.println("freed");
+			if (video_dst_file != null)
+				video_dst_file.close();
+			if (audio_dst_file != null)
+				audio_dst_file.close();
+			System.err.print("freeing frame...");
+			if(frame != null)
+				av_free(frame);
+			System.err.println("freed");
+			System.err.print("freeing video_dst_data...");
+			if(video_dst_data != null && video_dst_data.getValidElements() > 0)
+				av_freep(video_dst_data);
+			System.err.println("freed");
+		}
+		System.exit(ret);
+	}
+}
diff -pruN generated/test/StructInfo.java src/test/StructInfo.java
--- generated/test/StructInfo.java	1970-01-01 01:00:00.000000000 +0100
+++ src/test/StructInfo.java	2021-06-15 09:24:07.411078629 +0200
@@ -0,0 +1,55 @@
+package test;
+
+import java.lang.reflect.Field;
+import java.util.List;
+
+import org.bridj.StructFieldDescription;
+import org.bridj.StructObject;
+import org.ffmpeg.avcodec.AVPacket;
+import org.ffmpeg.avutil.AVFrame;
+
+public class StructInfo {
+	
+	public static void printAVFrame(AVFrame f) {
+		System.out.println(f);
+		List<StructFieldDescription> fields = f.getDescriptions();
+		for(int index=0;index<fields.size();index++)
+			try {
+				System.out.println("\t["+index+"]: "+fields.get(index)+ printField(f,index));
+			} catch (IllegalArgumentException e){
+				System.out.println("Illegal Argument Exception");
+			} catch (SecurityException e) {
+				System.out.println("Security Exception");
+			}
+	}
+
+	public static void printAVPacket(AVPacket f) {
+		System.out.println(f);
+		List<StructFieldDescription> fields = f.getDescriptions();
+		for(int index=0;index<fields.size();index++)
+			try {
+				System.out.println("\t["+index+"]: "+fields.get(index)+ printField(f,index));
+			} catch (IllegalArgumentException e){
+				System.out.println("Illegal Argument Exception");
+			} catch (SecurityException e) {
+				System.out.println("Security Exception");
+			}
+	}
+
+	public static String printField(StructObject f, int index) {
+		String ret = "";
+		Field[] fields = f.getClass().getFields();
+		if(fields.length < index+1)
+			return ret;
+		Field fi = fields[index];
+		ret = "("+fi.getName()+"|";
+		try {
+			ret = ret + fi.get(f)+")";
+		} catch (IllegalArgumentException e) {
+			ret = ret + " - )";
+		} catch (IllegalAccessException e) {
+			ret = ret + " - )";
+		}
+		return ret;
+	}
+}
