diff -pruN generated/org/ffmpeg/avcodec/AvcodecLibrary.java src/org/ffmpeg/avcodec/AvcodecLibrary.java
--- generated/org/ffmpeg/avcodec/AvcodecLibrary.java	2014-11-29 21:26:01.525483586 +0100
+++ src/org/ffmpeg/avcodec/AvcodecLibrary.java	2014-11-29 21:26:10.178464078 +0100
@@ -1695,11 +1695,11 @@ public class AvcodecLibrary {
 	 * Original signature : <code>AVFrame* avcodec_alloc_frame()</code><br>
 	 * <i>native declaration : ./libavcodec/avcodec.h:393</i>
 	 */
-	public static Pointer<AVFrame > avcodec_alloc_frame() {
-		return Pointer.pointerToAddress(avcodec_alloc_frame$2(), AVFrame.class);
+	public static Pointer<AVFrame > alloc_frame() {
+		return Pointer.pointerToAddress(avcodec_alloc_frame(), AVFrame.class);
 	}
 	@Ptr 
-	protected native static long avcodec_alloc_frame$2();
+	protected native static long avcodec_alloc_frame();
 	/**
 	 * Initialize the AVCodecContext to use the given AVCodec. Prior to using this<br>
 	 * function the context has to be allocated with avcodec_alloc_context3().<br>
diff -pruN generated/org/ffmpeg/avcodec/AvcodecLibrary.java.orig src/org/ffmpeg/avcodec/AvcodecLibrary.java.orig
--- generated/org/ffmpeg/avcodec/AvcodecLibrary.java.orig	1970-01-01 01:00:00.000000000 +0100
+++ src/org/ffmpeg/avcodec/AvcodecLibrary.java.orig	2014-11-29 21:26:10.181464071 +0100
@@ -0,0 +1,1970 @@
+package org.ffmpeg.avcodec;
+import java.util.Collections;
+import java.util.Iterator;
+import org.bridj.BridJ;
+import org.bridj.CRuntime;
+import org.bridj.FlagSet;
+import org.bridj.IntValuedEnum;
+import org.bridj.Pointer;
+import org.bridj.ann.Library;
+import org.bridj.ann.Ptr;
+import org.bridj.ann.Runtime;
+import org.ffmpeg.avutil.AVDictionary;
+import org.ffmpeg.avutil.AVFrame;
+import org.ffmpeg.avutil.AvutilLibrary.AVPixelFormat;
+/**
+ * Wrapper for library <b>avcodec</b><br>
+ * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
+ * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
+ * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
+ */
+@Library("avcodec") 
+@Runtime(CRuntime.class) 
+public class AvcodecLibrary {
+	static {
+		BridJ.register();
+	}
+	/**
+	 * enum values<br>
+	 * <i>native declaration : ./libavcodec/avcodecid.h:791</i>
+	 */
+	public enum AVCodecID implements IntValuedEnum<AVCodecID > {
+		AV_CODEC_ID_NONE(0),
+		/** video codecs */
+		AV_CODEC_ID_MPEG1VIDEO(1),
+		/** < preferred ID for MPEG-1/2 video decoding */
+		AV_CODEC_ID_MPEG2VIDEO(2),
+		AV_CODEC_ID_MPEG2VIDEO_XVMC(3),
+		AV_CODEC_ID_H261(4),
+		AV_CODEC_ID_H263(5),
+		AV_CODEC_ID_RV10(6),
+		AV_CODEC_ID_RV20(7),
+		AV_CODEC_ID_MJPEG(8),
+		AV_CODEC_ID_MJPEGB(9),
+		AV_CODEC_ID_LJPEG(10),
+		AV_CODEC_ID_SP5X(11),
+		AV_CODEC_ID_JPEGLS(12),
+		AV_CODEC_ID_MPEG4(13),
+		AV_CODEC_ID_RAWVIDEO(14),
+		AV_CODEC_ID_MSMPEG4V1(15),
+		AV_CODEC_ID_MSMPEG4V2(16),
+		AV_CODEC_ID_MSMPEG4V3(17),
+		AV_CODEC_ID_WMV1(18),
+		AV_CODEC_ID_WMV2(19),
+		AV_CODEC_ID_H263P(20),
+		AV_CODEC_ID_H263I(21),
+		AV_CODEC_ID_FLV1(22),
+		AV_CODEC_ID_SVQ1(23),
+		AV_CODEC_ID_SVQ3(24),
+		AV_CODEC_ID_DVVIDEO(25),
+		AV_CODEC_ID_HUFFYUV(26),
+		AV_CODEC_ID_CYUV(27),
+		AV_CODEC_ID_H264(28),
+		AV_CODEC_ID_INDEO3(29),
+		AV_CODEC_ID_VP3(30),
+		AV_CODEC_ID_THEORA(31),
+		AV_CODEC_ID_ASV1(32),
+		AV_CODEC_ID_ASV2(33),
+		AV_CODEC_ID_FFV1(34),
+		AV_CODEC_ID_4XM(35),
+		AV_CODEC_ID_VCR1(36),
+		AV_CODEC_ID_CLJR(37),
+		AV_CODEC_ID_MDEC(38),
+		AV_CODEC_ID_ROQ(39),
+		AV_CODEC_ID_INTERPLAY_VIDEO(40),
+		AV_CODEC_ID_XAN_WC3(41),
+		AV_CODEC_ID_XAN_WC4(42),
+		AV_CODEC_ID_RPZA(43),
+		AV_CODEC_ID_CINEPAK(44),
+		AV_CODEC_ID_WS_VQA(45),
+		AV_CODEC_ID_MSRLE(46),
+		AV_CODEC_ID_MSVIDEO1(47),
+		AV_CODEC_ID_IDCIN(48),
+		AV_CODEC_ID_8BPS(49),
+		AV_CODEC_ID_SMC(50),
+		AV_CODEC_ID_FLIC(51),
+		AV_CODEC_ID_TRUEMOTION1(52),
+		AV_CODEC_ID_VMDVIDEO(53),
+		AV_CODEC_ID_MSZH(54),
+		AV_CODEC_ID_ZLIB(55),
+		AV_CODEC_ID_QTRLE(56),
+		AV_CODEC_ID_TSCC(57),
+		AV_CODEC_ID_ULTI(58),
+		AV_CODEC_ID_QDRAW(59),
+		AV_CODEC_ID_VIXL(60),
+		AV_CODEC_ID_QPEG(61),
+		AV_CODEC_ID_PNG(62),
+		AV_CODEC_ID_PPM(63),
+		AV_CODEC_ID_PBM(64),
+		AV_CODEC_ID_PGM(65),
+		AV_CODEC_ID_PGMYUV(66),
+		AV_CODEC_ID_PAM(67),
+		AV_CODEC_ID_FFVHUFF(68),
+		AV_CODEC_ID_RV30(69),
+		AV_CODEC_ID_RV40(70),
+		AV_CODEC_ID_VC1(71),
+		AV_CODEC_ID_WMV3(72),
+		AV_CODEC_ID_LOCO(73),
+		AV_CODEC_ID_WNV1(74),
+		AV_CODEC_ID_AASC(75),
+		AV_CODEC_ID_INDEO2(76),
+		AV_CODEC_ID_FRAPS(77),
+		AV_CODEC_ID_TRUEMOTION2(78),
+		AV_CODEC_ID_BMP(79),
+		AV_CODEC_ID_CSCD(80),
+		AV_CODEC_ID_MMVIDEO(81),
+		AV_CODEC_ID_ZMBV(82),
+		AV_CODEC_ID_AVS(83),
+		AV_CODEC_ID_SMACKVIDEO(84),
+		AV_CODEC_ID_NUV(85),
+		AV_CODEC_ID_KMVC(86),
+		AV_CODEC_ID_FLASHSV(87),
+		AV_CODEC_ID_CAVS(88),
+		AV_CODEC_ID_JPEG2000(89),
+		AV_CODEC_ID_VMNC(90),
+		AV_CODEC_ID_VP5(91),
+		AV_CODEC_ID_VP6(92),
+		AV_CODEC_ID_VP6F(93),
+		AV_CODEC_ID_TARGA(94),
+		AV_CODEC_ID_DSICINVIDEO(95),
+		AV_CODEC_ID_TIERTEXSEQVIDEO(96),
+		AV_CODEC_ID_TIFF(97),
+		AV_CODEC_ID_GIF(98),
+		AV_CODEC_ID_DXA(99),
+		AV_CODEC_ID_DNXHD(100),
+		AV_CODEC_ID_THP(101),
+		AV_CODEC_ID_SGI(102),
+		AV_CODEC_ID_C93(103),
+		AV_CODEC_ID_BETHSOFTVID(104),
+		AV_CODEC_ID_PTX(105),
+		AV_CODEC_ID_TXD(106),
+		AV_CODEC_ID_VP6A(107),
+		AV_CODEC_ID_AMV(108),
+		AV_CODEC_ID_VB(109),
+		AV_CODEC_ID_PCX(110),
+		AV_CODEC_ID_SUNRAST(111),
+		AV_CODEC_ID_INDEO4(112),
+		AV_CODEC_ID_INDEO5(113),
+		AV_CODEC_ID_MIMIC(114),
+		AV_CODEC_ID_RL2(115),
+		AV_CODEC_ID_ESCAPE124(116),
+		AV_CODEC_ID_DIRAC(117),
+		AV_CODEC_ID_BFI(118),
+		AV_CODEC_ID_CMV(119),
+		AV_CODEC_ID_MOTIONPIXELS(120),
+		AV_CODEC_ID_TGV(121),
+		AV_CODEC_ID_TGQ(122),
+		AV_CODEC_ID_TQI(123),
+		AV_CODEC_ID_AURA(124),
+		AV_CODEC_ID_AURA2(125),
+		AV_CODEC_ID_V210X(126),
+		AV_CODEC_ID_TMV(127),
+		AV_CODEC_ID_V210(128),
+		AV_CODEC_ID_DPX(129),
+		AV_CODEC_ID_MAD(130),
+		AV_CODEC_ID_FRWU(131),
+		AV_CODEC_ID_FLASHSV2(132),
+		AV_CODEC_ID_CDGRAPHICS(133),
+		AV_CODEC_ID_R210(134),
+		AV_CODEC_ID_ANM(135),
+		AV_CODEC_ID_BINKVIDEO(136),
+		AV_CODEC_ID_IFF_ILBM(137),
+		AV_CODEC_ID_IFF_BYTERUN1(138),
+		AV_CODEC_ID_KGV1(139),
+		AV_CODEC_ID_YOP(140),
+		AV_CODEC_ID_VP8(141),
+		AV_CODEC_ID_PICTOR(142),
+		AV_CODEC_ID_ANSI(143),
+		AV_CODEC_ID_A64_MULTI(144),
+		AV_CODEC_ID_A64_MULTI5(145),
+		AV_CODEC_ID_R10K(146),
+		AV_CODEC_ID_MXPEG(147),
+		AV_CODEC_ID_LAGARITH(148),
+		AV_CODEC_ID_PRORES(149),
+		AV_CODEC_ID_JV(150),
+		AV_CODEC_ID_DFA(151),
+		AV_CODEC_ID_WMV3IMAGE(152),
+		AV_CODEC_ID_VC1IMAGE(153),
+		AV_CODEC_ID_UTVIDEO(154),
+		AV_CODEC_ID_BMV_VIDEO(155),
+		AV_CODEC_ID_VBLE(156),
+		AV_CODEC_ID_DXTORY(157),
+		AV_CODEC_ID_V410(158),
+		AV_CODEC_ID_XWD(159),
+		AV_CODEC_ID_CDXL(160),
+		AV_CODEC_ID_XBM(161),
+		AV_CODEC_ID_ZEROCODEC(162),
+		AV_CODEC_ID_MSS1(163),
+		AV_CODEC_ID_MSA1(164),
+		AV_CODEC_ID_TSCC2(165),
+		AV_CODEC_ID_MTS2(166),
+		AV_CODEC_ID_CLLC(167),
+		AV_CODEC_ID_MSS2(168),
+		AV_CODEC_ID_VP9(169),
+		AV_CODEC_ID_AIC(170),
+		AV_CODEC_ID_ESCAPE130_DEPRECATED(171),
+		AV_CODEC_ID_G2M_DEPRECATED(172),
+		AV_CODEC_ID_WEBP_DEPRECATED(173),
+		AV_CODEC_ID_HNM4_VIDEO(174),
+		AV_CODEC_ID_HEVC_DEPRECATED(175),
+		AV_CODEC_ID_FIC(176),
+		AV_CODEC_ID_ALIAS_PIX(177),
+		AV_CODEC_ID_BRENDER_PIX_DEPRECATED(178),
+		AV_CODEC_ID_PAF_VIDEO_DEPRECATED(179),
+		AV_CODEC_ID_EXR_DEPRECATED(180),
+		AV_CODEC_ID_VP7_DEPRECATED(181),
+		AV_CODEC_ID_SANM_DEPRECATED(182),
+		AV_CODEC_ID_SGIRLE_DEPRECATED(183),
+		AV_CODEC_ID_MVC1_DEPRECATED(184),
+		AV_CODEC_ID_MVC2_DEPRECATED(185),
+		AV_CODEC_ID_BRENDER_PIX((('X') | (('I') << 8) | (('P') << 16) | ('B' << 24))),
+		AV_CODEC_ID_Y41P((('P') | (('1') << 8) | (('4') << 16) | ('Y' << 24))),
+		AV_CODEC_ID_ESCAPE130((('0') | (('3') << 8) | (('1') << 16) | ('E' << 24))),
+		AV_CODEC_ID_EXR((('R') | (('X') << 8) | (('E') << 16) | ('0' << 24))),
+		AV_CODEC_ID_AVRP((('P') | (('R') << 8) | (('V') << 16) | ('A' << 24))),
+		AV_CODEC_ID_012V((('V') | (('2') << 8) | (('1') << 16) | ('0' << 24))),
+		AV_CODEC_ID_G2M((('M') | (('2') << 8) | (('G') << 16) | (0 << 24))),
+		AV_CODEC_ID_AVUI((('I') | (('U') << 8) | (('V') << 16) | ('A' << 24))),
+		AV_CODEC_ID_AYUV((('V') | (('U') << 8) | (('Y') << 16) | ('A' << 24))),
+		AV_CODEC_ID_TARGA_Y216((('6') | (('1') << 8) | (('2') << 16) | ('T' << 24))),
+		AV_CODEC_ID_V308((('8') | (('0') << 8) | (('3') << 16) | ('V' << 24))),
+		AV_CODEC_ID_V408((('8') | (('0') << 8) | (('4') << 16) | ('V' << 24))),
+		AV_CODEC_ID_YUV4((('4') | (('V') << 8) | (('U') << 16) | ('Y' << 24))),
+		AV_CODEC_ID_SANM((('M') | (('N') << 8) | (('A') << 16) | ('S' << 24))),
+		AV_CODEC_ID_PAF_VIDEO((('V') | (('F') << 8) | (('A') << 16) | ('P' << 24))),
+		AV_CODEC_ID_AVRN((('n') | (('R') << 8) | (('V') << 16) | ('A' << 24))),
+		AV_CODEC_ID_CPIA((('A') | (('I') << 8) | (('P') << 16) | ('C' << 24))),
+		AV_CODEC_ID_XFACE((('C') | (('A') << 8) | (('F') << 16) | ('X' << 24))),
+		AV_CODEC_ID_SGIRLE((('R') | (('I') << 8) | (('G') << 16) | ('S' << 24))),
+		AV_CODEC_ID_MVC1((('1') | (('C') << 8) | (('V') << 16) | ('M' << 24))),
+		AV_CODEC_ID_MVC2((('2') | (('C') << 8) | (('V') << 16) | ('M' << 24))),
+		AV_CODEC_ID_SNOW((('W') | (('O') << 8) | (('N') << 16) | ('S' << 24))),
+		AV_CODEC_ID_WEBP((('P') | (('B') << 8) | (('E') << 16) | ('W' << 24))),
+		AV_CODEC_ID_SMVJPEG((('J') | (('V') << 8) | (('M') << 16) | ('S' << 24))),
+		AV_CODEC_ID_HEVC((('5') | (('6') << 8) | (('2') << 16) | ('H' << 24))),
+		AV_CODEC_ID_VP7((('0') | (('7') << 8) | (('P') << 16) | ('V' << 24))),
+		/**
+		 * various PCM "codecs"<br>
+		 * < A dummy id pointing at the start of audio codecs
+		 */
+		AV_CODEC_ID_FIRST_AUDIO(0x10000),
+		AV_CODEC_ID_PCM_S16LE(0x10000),
+		AV_CODEC_ID_PCM_S16BE((0x10000 + 1)),
+		AV_CODEC_ID_PCM_U16LE((0x10000 + 2)),
+		AV_CODEC_ID_PCM_U16BE((0x10000 + 3)),
+		AV_CODEC_ID_PCM_S8((0x10000 + 4)),
+		AV_CODEC_ID_PCM_U8((0x10000 + 5)),
+		AV_CODEC_ID_PCM_MULAW((0x10000 + 6)),
+		AV_CODEC_ID_PCM_ALAW((0x10000 + 7)),
+		AV_CODEC_ID_PCM_S32LE((0x10000 + 8)),
+		AV_CODEC_ID_PCM_S32BE((0x10000 + 9)),
+		AV_CODEC_ID_PCM_U32LE((0x10000 + 10)),
+		AV_CODEC_ID_PCM_U32BE((0x10000 + 11)),
+		AV_CODEC_ID_PCM_S24LE((0x10000 + 12)),
+		AV_CODEC_ID_PCM_S24BE((0x10000 + 13)),
+		AV_CODEC_ID_PCM_U24LE((0x10000 + 14)),
+		AV_CODEC_ID_PCM_U24BE((0x10000 + 15)),
+		AV_CODEC_ID_PCM_S24DAUD((0x10000 + 16)),
+		AV_CODEC_ID_PCM_ZORK((0x10000 + 17)),
+		AV_CODEC_ID_PCM_S16LE_PLANAR((0x10000 + 18)),
+		AV_CODEC_ID_PCM_DVD((0x10000 + 19)),
+		AV_CODEC_ID_PCM_F32BE((0x10000 + 20)),
+		AV_CODEC_ID_PCM_F32LE((0x10000 + 21)),
+		AV_CODEC_ID_PCM_F64BE((0x10000 + 22)),
+		AV_CODEC_ID_PCM_F64LE((0x10000 + 23)),
+		AV_CODEC_ID_PCM_BLURAY((0x10000 + 24)),
+		AV_CODEC_ID_PCM_LXF((0x10000 + 25)),
+		AV_CODEC_ID_S302M((0x10000 + 26)),
+		AV_CODEC_ID_PCM_S8_PLANAR((0x10000 + 27)),
+		AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED((0x10000 + 28)),
+		AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED((0x10000 + 29)),
+		AV_CODEC_ID_PCM_S24LE_PLANAR((('P') | (('S') << 8) | (('P') << 16) | (24 << 24))),
+		AV_CODEC_ID_PCM_S32LE_PLANAR((('P') | (('S') << 8) | (('P') << 16) | (32 << 24))),
+		AV_CODEC_ID_PCM_S16BE_PLANAR(((16) | (('P') << 8) | (('S') << 16) | ('P' << 24))),
+		/** various ADPCM codecs */
+		AV_CODEC_ID_ADPCM_IMA_QT(0x11000),
+		AV_CODEC_ID_ADPCM_IMA_WAV((0x11000 + 1)),
+		AV_CODEC_ID_ADPCM_IMA_DK3((0x11000 + 2)),
+		AV_CODEC_ID_ADPCM_IMA_DK4((0x11000 + 3)),
+		AV_CODEC_ID_ADPCM_IMA_WS((0x11000 + 4)),
+		AV_CODEC_ID_ADPCM_IMA_SMJPEG((0x11000 + 5)),
+		AV_CODEC_ID_ADPCM_MS((0x11000 + 6)),
+		AV_CODEC_ID_ADPCM_4XM((0x11000 + 7)),
+		AV_CODEC_ID_ADPCM_XA((0x11000 + 8)),
+		AV_CODEC_ID_ADPCM_ADX((0x11000 + 9)),
+		AV_CODEC_ID_ADPCM_EA((0x11000 + 10)),
+		AV_CODEC_ID_ADPCM_G726((0x11000 + 11)),
+		AV_CODEC_ID_ADPCM_CT((0x11000 + 12)),
+		AV_CODEC_ID_ADPCM_SWF((0x11000 + 13)),
+		AV_CODEC_ID_ADPCM_YAMAHA((0x11000 + 14)),
+		AV_CODEC_ID_ADPCM_SBPRO_4((0x11000 + 15)),
+		AV_CODEC_ID_ADPCM_SBPRO_3((0x11000 + 16)),
+		AV_CODEC_ID_ADPCM_SBPRO_2((0x11000 + 17)),
+		AV_CODEC_ID_ADPCM_THP((0x11000 + 18)),
+		AV_CODEC_ID_ADPCM_IMA_AMV((0x11000 + 19)),
+		AV_CODEC_ID_ADPCM_EA_R1((0x11000 + 20)),
+		AV_CODEC_ID_ADPCM_EA_R3((0x11000 + 21)),
+		AV_CODEC_ID_ADPCM_EA_R2((0x11000 + 22)),
+		AV_CODEC_ID_ADPCM_IMA_EA_SEAD((0x11000 + 23)),
+		AV_CODEC_ID_ADPCM_IMA_EA_EACS((0x11000 + 24)),
+		AV_CODEC_ID_ADPCM_EA_XAS((0x11000 + 25)),
+		AV_CODEC_ID_ADPCM_EA_MAXIS_XA((0x11000 + 26)),
+		AV_CODEC_ID_ADPCM_IMA_ISS((0x11000 + 27)),
+		AV_CODEC_ID_ADPCM_G722((0x11000 + 28)),
+		AV_CODEC_ID_ADPCM_IMA_APC((0x11000 + 29)),
+		AV_CODEC_ID_ADPCM_VIMA_DEPRECATED((0x11000 + 30)),
+		AV_CODEC_ID_ADPCM_VIMA((('A') | (('M') << 8) | (('I') << 16) | ('V' << 24))),
+		AV_CODEC_ID_VIMA((('A') | (('M') << 8) | (('I') << 16) | ('V' << 24))),
+		AV_CODEC_ID_ADPCM_AFC(((' ') | (('C') << 8) | (('F') << 16) | ('A' << 24))),
+		AV_CODEC_ID_ADPCM_IMA_OKI(((' ') | (('I') << 8) | (('K') << 16) | ('O' << 24))),
+		AV_CODEC_ID_ADPCM_DTK(((' ') | (('K') << 8) | (('T') << 16) | ('D' << 24))),
+		AV_CODEC_ID_ADPCM_IMA_RAD(((' ') | (('D') << 8) | (('A') << 16) | ('R' << 24))),
+		AV_CODEC_ID_ADPCM_G726LE((('G') | (('7') << 8) | (('2') << 16) | ('6' << 24))),
+		/** AMR */
+		AV_CODEC_ID_AMR_NB(0x12000),
+		AV_CODEC_ID_AMR_WB((0x12000 + 1)),
+		/** RealAudio codecs */
+		AV_CODEC_ID_RA_144(0x13000),
+		AV_CODEC_ID_RA_288((0x13000 + 1)),
+		/** various DPCM codecs */
+		AV_CODEC_ID_ROQ_DPCM(0x14000),
+		AV_CODEC_ID_INTERPLAY_DPCM((0x14000 + 1)),
+		AV_CODEC_ID_XAN_DPCM((0x14000 + 2)),
+		AV_CODEC_ID_SOL_DPCM((0x14000 + 3)),
+		/** audio codecs */
+		AV_CODEC_ID_MP2(0x15000),
+		/** < preferred ID for decoding MPEG audio layer 1, 2 or 3 */
+		AV_CODEC_ID_MP3((0x15000 + 1)),
+		AV_CODEC_ID_AAC((0x15000 + 2)),
+		AV_CODEC_ID_AC3((0x15000 + 3)),
+		AV_CODEC_ID_DTS((0x15000 + 4)),
+		AV_CODEC_ID_VORBIS((0x15000 + 5)),
+		AV_CODEC_ID_DVAUDIO((0x15000 + 6)),
+		AV_CODEC_ID_WMAV1((0x15000 + 7)),
+		AV_CODEC_ID_WMAV2((0x15000 + 8)),
+		AV_CODEC_ID_MACE3((0x15000 + 9)),
+		AV_CODEC_ID_MACE6((0x15000 + 10)),
+		AV_CODEC_ID_VMDAUDIO((0x15000 + 11)),
+		AV_CODEC_ID_FLAC((0x15000 + 12)),
+		AV_CODEC_ID_MP3ADU((0x15000 + 13)),
+		AV_CODEC_ID_MP3ON4((0x15000 + 14)),
+		AV_CODEC_ID_SHORTEN((0x15000 + 15)),
+		AV_CODEC_ID_ALAC((0x15000 + 16)),
+		AV_CODEC_ID_WESTWOOD_SND1((0x15000 + 17)),
+		/** < as in Berlin toast format */
+		AV_CODEC_ID_GSM((0x15000 + 18)),
+		AV_CODEC_ID_QDM2((0x15000 + 19)),
+		AV_CODEC_ID_COOK((0x15000 + 20)),
+		AV_CODEC_ID_TRUESPEECH((0x15000 + 21)),
+		AV_CODEC_ID_TTA((0x15000 + 22)),
+		AV_CODEC_ID_SMACKAUDIO((0x15000 + 23)),
+		AV_CODEC_ID_QCELP((0x15000 + 24)),
+		AV_CODEC_ID_WAVPACK((0x15000 + 25)),
+		AV_CODEC_ID_DSICINAUDIO((0x15000 + 26)),
+		AV_CODEC_ID_IMC((0x15000 + 27)),
+		AV_CODEC_ID_MUSEPACK7((0x15000 + 28)),
+		AV_CODEC_ID_MLP((0x15000 + 29)),
+		/** as found in WAV */
+		AV_CODEC_ID_GSM_MS((0x15000 + 30)),
+		AV_CODEC_ID_ATRAC3((0x15000 + 31)),
+		AV_CODEC_ID_VOXWARE((0x15000 + 32)),
+		AV_CODEC_ID_APE((0x15000 + 33)),
+		AV_CODEC_ID_NELLYMOSER((0x15000 + 34)),
+		AV_CODEC_ID_MUSEPACK8((0x15000 + 35)),
+		AV_CODEC_ID_SPEEX((0x15000 + 36)),
+		AV_CODEC_ID_WMAVOICE((0x15000 + 37)),
+		AV_CODEC_ID_WMAPRO((0x15000 + 38)),
+		AV_CODEC_ID_WMALOSSLESS((0x15000 + 39)),
+		AV_CODEC_ID_ATRAC3P((0x15000 + 40)),
+		AV_CODEC_ID_EAC3((0x15000 + 41)),
+		AV_CODEC_ID_SIPR((0x15000 + 42)),
+		AV_CODEC_ID_MP1((0x15000 + 43)),
+		AV_CODEC_ID_TWINVQ((0x15000 + 44)),
+		AV_CODEC_ID_TRUEHD((0x15000 + 45)),
+		AV_CODEC_ID_MP4ALS((0x15000 + 46)),
+		AV_CODEC_ID_ATRAC1((0x15000 + 47)),
+		AV_CODEC_ID_BINKAUDIO_RDFT((0x15000 + 48)),
+		AV_CODEC_ID_BINKAUDIO_DCT((0x15000 + 49)),
+		AV_CODEC_ID_AAC_LATM((0x15000 + 50)),
+		AV_CODEC_ID_QDMC((0x15000 + 51)),
+		AV_CODEC_ID_CELT((0x15000 + 52)),
+		AV_CODEC_ID_G723_1((0x15000 + 53)),
+		AV_CODEC_ID_G729((0x15000 + 54)),
+		AV_CODEC_ID_8SVX_EXP((0x15000 + 55)),
+		AV_CODEC_ID_8SVX_FIB((0x15000 + 56)),
+		AV_CODEC_ID_BMV_AUDIO((0x15000 + 57)),
+		AV_CODEC_ID_RALF((0x15000 + 58)),
+		AV_CODEC_ID_IAC((0x15000 + 59)),
+		AV_CODEC_ID_ILBC((0x15000 + 60)),
+		AV_CODEC_ID_OPUS_DEPRECATED((0x15000 + 61)),
+		AV_CODEC_ID_COMFORT_NOISE((0x15000 + 62)),
+		AV_CODEC_ID_TAK_DEPRECATED((0x15000 + 63)),
+		AV_CODEC_ID_METASOUND((0x15000 + 64)),
+		AV_CODEC_ID_PAF_AUDIO_DEPRECATED((0x15000 + 65)),
+		AV_CODEC_ID_ON2AVC((0x15000 + 66)),
+		AV_CODEC_ID_FFWAVESYNTH((('S') | (('W') << 8) | (('F') << 16) | ('F' << 24))),
+		AV_CODEC_ID_SONIC((('C') | (('N') << 8) | (('O') << 16) | ('S' << 24))),
+		AV_CODEC_ID_SONIC_LS((('L') | (('N') << 8) | (('O') << 16) | ('S' << 24))),
+		AV_CODEC_ID_PAF_AUDIO((('A') | (('F') << 8) | (('A') << 16) | ('P' << 24))),
+		AV_CODEC_ID_OPUS((('S') | (('U') << 8) | (('P') << 16) | ('O' << 24))),
+		AV_CODEC_ID_TAK((('K') | (('a') << 8) | (('B') << 16) | ('t' << 24))),
+		AV_CODEC_ID_EVRC((('c') | (('v') << 8) | (('e') << 16) | ('s' << 24))),
+		AV_CODEC_ID_SMV((('v') | (('m') << 8) | (('s') << 16) | ('s' << 24))),
+		AV_CODEC_ID_DSD_LSBF((('L') | (('D') << 8) | (('S') << 16) | ('D' << 24))),
+		AV_CODEC_ID_DSD_MSBF((('M') | (('D') << 8) | (('S') << 16) | ('D' << 24))),
+		AV_CODEC_ID_DSD_LSBF_PLANAR((('1') | (('D') << 8) | (('S') << 16) | ('D' << 24))),
+		AV_CODEC_ID_DSD_MSBF_PLANAR((('8') | (('D') << 8) | (('S') << 16) | ('D' << 24))),
+		/**
+		 * subtitle codecs<br>
+		 * < A dummy ID pointing at the start of subtitle codecs.
+		 */
+		AV_CODEC_ID_FIRST_SUBTITLE(0x17000),
+		AV_CODEC_ID_DVD_SUBTITLE(0x17000),
+		AV_CODEC_ID_DVB_SUBTITLE((0x17000 + 1)),
+		/** < raw UTF-8 text */
+		AV_CODEC_ID_TEXT((0x17000 + 2)),
+		AV_CODEC_ID_XSUB((0x17000 + 3)),
+		AV_CODEC_ID_SSA((0x17000 + 4)),
+		AV_CODEC_ID_MOV_TEXT((0x17000 + 5)),
+		AV_CODEC_ID_HDMV_PGS_SUBTITLE((0x17000 + 6)),
+		AV_CODEC_ID_DVB_TELETEXT((0x17000 + 7)),
+		AV_CODEC_ID_SRT((0x17000 + 8)),
+		AV_CODEC_ID_MICRODVD((('D') | (('V') << 8) | (('D') << 16) | ('m' << 24))),
+		AV_CODEC_ID_EIA_608((('8') | (('0') << 8) | (('6') << 16) | ('c' << 24))),
+		AV_CODEC_ID_JACOSUB((('B') | (('U') << 8) | (('S') << 16) | ('J' << 24))),
+		AV_CODEC_ID_SAMI((('I') | (('M') << 8) | (('A') << 16) | ('S' << 24))),
+		AV_CODEC_ID_REALTEXT((('T') | (('X') << 8) | (('T') << 16) | ('R' << 24))),
+		AV_CODEC_ID_SUBVIEWER1((('1') | (('V') << 8) | (('b') << 16) | ('S' << 24))),
+		AV_CODEC_ID_SUBVIEWER((('V') | (('b') << 8) | (('u') << 16) | ('S' << 24))),
+		AV_CODEC_ID_SUBRIP((('p') | (('i') << 8) | (('R') << 16) | ('S' << 24))),
+		AV_CODEC_ID_WEBVTT((('T') | (('T') << 8) | (('V') << 16) | ('W' << 24))),
+		AV_CODEC_ID_MPL2((('2') | (('L') << 8) | (('P') << 16) | ('M' << 24))),
+		AV_CODEC_ID_VPLAYER((('r') | (('l') << 8) | (('P') << 16) | ('V' << 24))),
+		AV_CODEC_ID_PJS((('S') | (('J') << 8) | (('h') << 16) | ('P' << 24))),
+		/** < ASS as defined in Matroska */
+		AV_CODEC_ID_ASS(((' ') | (('S') << 8) | (('S') << 16) | ('A' << 24))),
+		/**
+		 * other specific kind of codecs (generally used for attachments)<br>
+		 * < A dummy ID pointing at the start of various fake codecs.
+		 */
+		AV_CODEC_ID_FIRST_UNKNOWN(0x18000),
+		AV_CODEC_ID_TTF(0x18000),
+		AV_CODEC_ID_BINTEXT((('T') | (('X') << 8) | (('T') << 16) | ('B' << 24))),
+		AV_CODEC_ID_XBIN((('N') | (('I') << 8) | (('B') << 16) | ('X' << 24))),
+		AV_CODEC_ID_IDF((('F') | (('D') << 8) | (('I') << 16) | (0 << 24))),
+		AV_CODEC_ID_OTF((('F') | (('T') << 8) | (('O') << 16) | (0 << 24))),
+		AV_CODEC_ID_SMPTE_KLV((('A') | (('V') << 8) | (('L') << 16) | ('K' << 24))),
+		AV_CODEC_ID_DVD_NAV((('V') | (('A') << 8) | (('N') << 16) | ('D' << 24))),
+		AV_CODEC_ID_TIMED_ID3((('3') | (('D') << 8) | (('I') << 16) | ('T' << 24))),
+		AV_CODEC_ID_BIN_DATA((('A') | (('T') << 8) | (('A') << 16) | ('D' << 24))),
+		/** < codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it */
+		AV_CODEC_ID_PROBE(0x19000),
+		/**
+		 * < _FAKE_ codec to indicate a raw MPEG-2 TS<br>
+		 * stream (only used by libavformat)
+		 */
+		AV_CODEC_ID_MPEG2TS(0x20000),
+		/**
+		 * < _FAKE_ codec to indicate a MPEG-4 Systems<br>
+		 * stream (only used by libavformat)
+		 */
+		AV_CODEC_ID_MPEG4SYSTEMS(0x20001),
+		/** < Dummy codec for streams containing only metadata information. */
+		AV_CODEC_ID_FFMETADATA(0x21000),
+		CODEC_ID_NONE(0),
+		/** video codecs */
+		CODEC_ID_MPEG1VIDEO((0 + 1)),
+		/** < preferred ID for MPEG-1/2 video decoding */
+		CODEC_ID_MPEG2VIDEO((0 + 2)),
+		CODEC_ID_MPEG2VIDEO_XVMC((0 + 3)),
+		CODEC_ID_H261((0 + 4)),
+		CODEC_ID_H263((0 + 5)),
+		CODEC_ID_RV10((0 + 6)),
+		CODEC_ID_RV20((0 + 7)),
+		CODEC_ID_MJPEG((0 + 8)),
+		CODEC_ID_MJPEGB((0 + 9)),
+		CODEC_ID_LJPEG((0 + 10)),
+		CODEC_ID_SP5X((0 + 11)),
+		CODEC_ID_JPEGLS((0 + 12)),
+		CODEC_ID_MPEG4((0 + 13)),
+		CODEC_ID_RAWVIDEO((0 + 14)),
+		CODEC_ID_MSMPEG4V1((0 + 15)),
+		CODEC_ID_MSMPEG4V2((0 + 16)),
+		CODEC_ID_MSMPEG4V3((0 + 17)),
+		CODEC_ID_WMV1((0 + 18)),
+		CODEC_ID_WMV2((0 + 19)),
+		CODEC_ID_H263P((0 + 20)),
+		CODEC_ID_H263I((0 + 21)),
+		CODEC_ID_FLV1((0 + 22)),
+		CODEC_ID_SVQ1((0 + 23)),
+		CODEC_ID_SVQ3((0 + 24)),
+		CODEC_ID_DVVIDEO((0 + 25)),
+		CODEC_ID_HUFFYUV((0 + 26)),
+		CODEC_ID_CYUV((0 + 27)),
+		CODEC_ID_H264((0 + 28)),
+		CODEC_ID_INDEO3((0 + 29)),
+		CODEC_ID_VP3((0 + 30)),
+		CODEC_ID_THEORA((0 + 31)),
+		CODEC_ID_ASV1((0 + 32)),
+		CODEC_ID_ASV2((0 + 33)),
+		CODEC_ID_FFV1((0 + 34)),
+		CODEC_ID_4XM((0 + 35)),
+		CODEC_ID_VCR1((0 + 36)),
+		CODEC_ID_CLJR((0 + 37)),
+		CODEC_ID_MDEC((0 + 38)),
+		CODEC_ID_ROQ((0 + 39)),
+		CODEC_ID_INTERPLAY_VIDEO((0 + 40)),
+		CODEC_ID_XAN_WC3((0 + 41)),
+		CODEC_ID_XAN_WC4((0 + 42)),
+		CODEC_ID_RPZA((0 + 43)),
+		CODEC_ID_CINEPAK((0 + 44)),
+		CODEC_ID_WS_VQA((0 + 45)),
+		CODEC_ID_MSRLE((0 + 46)),
+		CODEC_ID_MSVIDEO1((0 + 47)),
+		CODEC_ID_IDCIN((0 + 48)),
+		CODEC_ID_8BPS((0 + 49)),
+		CODEC_ID_SMC((0 + 50)),
+		CODEC_ID_FLIC((0 + 51)),
+		CODEC_ID_TRUEMOTION1((0 + 52)),
+		CODEC_ID_VMDVIDEO((0 + 53)),
+		CODEC_ID_MSZH((0 + 54)),
+		CODEC_ID_ZLIB((0 + 55)),
+		CODEC_ID_QTRLE((0 + 56)),
+		CODEC_ID_TSCC((0 + 57)),
+		CODEC_ID_ULTI((0 + 58)),
+		CODEC_ID_QDRAW((0 + 59)),
+		CODEC_ID_VIXL((0 + 60)),
+		CODEC_ID_QPEG((0 + 61)),
+		CODEC_ID_PNG((0 + 62)),
+		CODEC_ID_PPM((0 + 63)),
+		CODEC_ID_PBM((0 + 64)),
+		CODEC_ID_PGM((0 + 65)),
+		CODEC_ID_PGMYUV((0 + 66)),
+		CODEC_ID_PAM((0 + 67)),
+		CODEC_ID_FFVHUFF((0 + 68)),
+		CODEC_ID_RV30((0 + 69)),
+		CODEC_ID_RV40((0 + 70)),
+		CODEC_ID_VC1((0 + 71)),
+		CODEC_ID_WMV3((0 + 72)),
+		CODEC_ID_LOCO((0 + 73)),
+		CODEC_ID_WNV1((0 + 74)),
+		CODEC_ID_AASC((0 + 75)),
+		CODEC_ID_INDEO2((0 + 76)),
+		CODEC_ID_FRAPS((0 + 77)),
+		CODEC_ID_TRUEMOTION2((0 + 78)),
+		CODEC_ID_BMP((0 + 79)),
+		CODEC_ID_CSCD((0 + 80)),
+		CODEC_ID_MMVIDEO((0 + 81)),
+		CODEC_ID_ZMBV((0 + 82)),
+		CODEC_ID_AVS((0 + 83)),
+		CODEC_ID_SMACKVIDEO((0 + 84)),
+		CODEC_ID_NUV((0 + 85)),
+		CODEC_ID_KMVC((0 + 86)),
+		CODEC_ID_FLASHSV((0 + 87)),
+		CODEC_ID_CAVS((0 + 88)),
+		CODEC_ID_JPEG2000((0 + 89)),
+		CODEC_ID_VMNC((0 + 90)),
+		CODEC_ID_VP5((0 + 91)),
+		CODEC_ID_VP6((0 + 92)),
+		CODEC_ID_VP6F((0 + 93)),
+		CODEC_ID_TARGA((0 + 94)),
+		CODEC_ID_DSICINVIDEO((0 + 95)),
+		CODEC_ID_TIERTEXSEQVIDEO((0 + 96)),
+		CODEC_ID_TIFF((0 + 97)),
+		CODEC_ID_GIF((0 + 98)),
+		CODEC_ID_DXA((0 + 99)),
+		CODEC_ID_DNXHD((0 + 100)),
+		CODEC_ID_THP((0 + 101)),
+		CODEC_ID_SGI((0 + 102)),
+		CODEC_ID_C93((0 + 103)),
+		CODEC_ID_BETHSOFTVID((0 + 104)),
+		CODEC_ID_PTX((0 + 105)),
+		CODEC_ID_TXD((0 + 106)),
+		CODEC_ID_VP6A((0 + 107)),
+		CODEC_ID_AMV((0 + 108)),
+		CODEC_ID_VB((0 + 109)),
+		CODEC_ID_PCX((0 + 110)),
+		CODEC_ID_SUNRAST((0 + 111)),
+		CODEC_ID_INDEO4((0 + 112)),
+		CODEC_ID_INDEO5((0 + 113)),
+		CODEC_ID_MIMIC((0 + 114)),
+		CODEC_ID_RL2((0 + 115)),
+		CODEC_ID_ESCAPE124((0 + 116)),
+		CODEC_ID_DIRAC((0 + 117)),
+		CODEC_ID_BFI((0 + 118)),
+		CODEC_ID_CMV((0 + 119)),
+		CODEC_ID_MOTIONPIXELS((0 + 120)),
+		CODEC_ID_TGV((0 + 121)),
+		CODEC_ID_TGQ((0 + 122)),
+		CODEC_ID_TQI((0 + 123)),
+		CODEC_ID_AURA((0 + 124)),
+		CODEC_ID_AURA2((0 + 125)),
+		CODEC_ID_V210X((0 + 126)),
+		CODEC_ID_TMV((0 + 127)),
+		CODEC_ID_V210((0 + 128)),
+		CODEC_ID_DPX((0 + 129)),
+		CODEC_ID_MAD((0 + 130)),
+		CODEC_ID_FRWU((0 + 131)),
+		CODEC_ID_FLASHSV2((0 + 132)),
+		CODEC_ID_CDGRAPHICS((0 + 133)),
+		CODEC_ID_R210((0 + 134)),
+		CODEC_ID_ANM((0 + 135)),
+		CODEC_ID_BINKVIDEO((0 + 136)),
+		CODEC_ID_IFF_ILBM((0 + 137)),
+		CODEC_ID_IFF_BYTERUN1((0 + 138)),
+		CODEC_ID_KGV1((0 + 139)),
+		CODEC_ID_YOP((0 + 140)),
+		CODEC_ID_VP8((0 + 141)),
+		CODEC_ID_PICTOR((0 + 142)),
+		CODEC_ID_ANSI((0 + 143)),
+		CODEC_ID_A64_MULTI((0 + 144)),
+		CODEC_ID_A64_MULTI5((0 + 145)),
+		CODEC_ID_R10K((0 + 146)),
+		CODEC_ID_MXPEG((0 + 147)),
+		CODEC_ID_LAGARITH((0 + 148)),
+		CODEC_ID_PRORES((0 + 149)),
+		CODEC_ID_JV((0 + 150)),
+		CODEC_ID_DFA((0 + 151)),
+		CODEC_ID_WMV3IMAGE((0 + 152)),
+		CODEC_ID_VC1IMAGE((0 + 153)),
+		CODEC_ID_UTVIDEO((0 + 154)),
+		CODEC_ID_BMV_VIDEO((0 + 155)),
+		CODEC_ID_VBLE((0 + 156)),
+		CODEC_ID_DXTORY((0 + 157)),
+		CODEC_ID_V410((0 + 158)),
+		CODEC_ID_XWD((0 + 159)),
+		CODEC_ID_CDXL((0 + 160)),
+		CODEC_ID_XBM((0 + 161)),
+		CODEC_ID_ZEROCODEC((0 + 162)),
+		CODEC_ID_MSS1((0 + 163)),
+		CODEC_ID_MSA1((0 + 164)),
+		CODEC_ID_TSCC2((0 + 165)),
+		CODEC_ID_MTS2((0 + 166)),
+		CODEC_ID_CLLC((0 + 167)),
+		CODEC_ID_Y41P((('P') | (('1') << 8) | (('4') << 16) | ('Y' << 24))),
+		CODEC_ID_ESCAPE130((('0') | (('3') << 8) | (('1') << 16) | ('E' << 24))),
+		CODEC_ID_EXR((('R') | (('X') << 8) | (('E') << 16) | ('0' << 24))),
+		CODEC_ID_AVRP((('P') | (('R') << 8) | (('V') << 16) | ('A' << 24))),
+		CODEC_ID_G2M((('M') | (('2') << 8) | (('G') << 16) | (0 << 24))),
+		CODEC_ID_AVUI((('I') | (('U') << 8) | (('V') << 16) | ('A' << 24))),
+		CODEC_ID_AYUV((('V') | (('U') << 8) | (('Y') << 16) | ('A' << 24))),
+		CODEC_ID_V308((('8') | (('0') << 8) | (('3') << 16) | ('V' << 24))),
+		CODEC_ID_V408((('8') | (('0') << 8) | (('4') << 16) | ('V' << 24))),
+		CODEC_ID_YUV4((('4') | (('V') << 8) | (('U') << 16) | ('Y' << 24))),
+		CODEC_ID_SANM((('M') | (('N') << 8) | (('A') << 16) | ('S' << 24))),
+		CODEC_ID_PAF_VIDEO((('V') | (('F') << 8) | (('A') << 16) | ('P' << 24))),
+		CODEC_ID_SNOW(('W') | (('O') << 8) | (('N') << 16) | ('S' << 24)),
+		/**
+		 * various PCM "codecs"<br>
+		 * < A dummy id pointing at the start of audio codecs
+		 */
+		CODEC_ID_FIRST_AUDIO(0x10000),
+		CODEC_ID_PCM_S16LE(0x10000),
+		CODEC_ID_PCM_S16BE((0x10000 + 1)),
+		CODEC_ID_PCM_U16LE((0x10000 + 2)),
+		CODEC_ID_PCM_U16BE((0x10000 + 3)),
+		CODEC_ID_PCM_S8((0x10000 + 4)),
+		CODEC_ID_PCM_U8((0x10000 + 5)),
+		CODEC_ID_PCM_MULAW((0x10000 + 6)),
+		CODEC_ID_PCM_ALAW((0x10000 + 7)),
+		CODEC_ID_PCM_S32LE((0x10000 + 8)),
+		CODEC_ID_PCM_S32BE((0x10000 + 9)),
+		CODEC_ID_PCM_U32LE((0x10000 + 10)),
+		CODEC_ID_PCM_U32BE((0x10000 + 11)),
+		CODEC_ID_PCM_S24LE((0x10000 + 12)),
+		CODEC_ID_PCM_S24BE((0x10000 + 13)),
+		CODEC_ID_PCM_U24LE((0x10000 + 14)),
+		CODEC_ID_PCM_U24BE((0x10000 + 15)),
+		CODEC_ID_PCM_S24DAUD((0x10000 + 16)),
+		CODEC_ID_PCM_ZORK((0x10000 + 17)),
+		CODEC_ID_PCM_S16LE_PLANAR((0x10000 + 18)),
+		CODEC_ID_PCM_DVD((0x10000 + 19)),
+		CODEC_ID_PCM_F32BE((0x10000 + 20)),
+		CODEC_ID_PCM_F32LE((0x10000 + 21)),
+		CODEC_ID_PCM_F64BE((0x10000 + 22)),
+		CODEC_ID_PCM_F64LE((0x10000 + 23)),
+		CODEC_ID_PCM_BLURAY((0x10000 + 24)),
+		CODEC_ID_PCM_LXF((0x10000 + 25)),
+		CODEC_ID_S302M((0x10000 + 26)),
+		CODEC_ID_PCM_S8_PLANAR((0x10000 + 27)),
+		/** various ADPCM codecs */
+		CODEC_ID_ADPCM_IMA_QT(0x11000),
+		CODEC_ID_ADPCM_IMA_WAV((0x11000 + 1)),
+		CODEC_ID_ADPCM_IMA_DK3((0x11000 + 2)),
+		CODEC_ID_ADPCM_IMA_DK4((0x11000 + 3)),
+		CODEC_ID_ADPCM_IMA_WS((0x11000 + 4)),
+		CODEC_ID_ADPCM_IMA_SMJPEG((0x11000 + 5)),
+		CODEC_ID_ADPCM_MS((0x11000 + 6)),
+		CODEC_ID_ADPCM_4XM((0x11000 + 7)),
+		CODEC_ID_ADPCM_XA((0x11000 + 8)),
+		CODEC_ID_ADPCM_ADX((0x11000 + 9)),
+		CODEC_ID_ADPCM_EA((0x11000 + 10)),
+		CODEC_ID_ADPCM_G726((0x11000 + 11)),
+		CODEC_ID_ADPCM_CT((0x11000 + 12)),
+		CODEC_ID_ADPCM_SWF((0x11000 + 13)),
+		CODEC_ID_ADPCM_YAMAHA((0x11000 + 14)),
+		CODEC_ID_ADPCM_SBPRO_4((0x11000 + 15)),
+		CODEC_ID_ADPCM_SBPRO_3((0x11000 + 16)),
+		CODEC_ID_ADPCM_SBPRO_2((0x11000 + 17)),
+		CODEC_ID_ADPCM_THP((0x11000 + 18)),
+		CODEC_ID_ADPCM_IMA_AMV((0x11000 + 19)),
+		CODEC_ID_ADPCM_EA_R1((0x11000 + 20)),
+		CODEC_ID_ADPCM_EA_R3((0x11000 + 21)),
+		CODEC_ID_ADPCM_EA_R2((0x11000 + 22)),
+		CODEC_ID_ADPCM_IMA_EA_SEAD((0x11000 + 23)),
+		CODEC_ID_ADPCM_IMA_EA_EACS((0x11000 + 24)),
+		CODEC_ID_ADPCM_EA_XAS((0x11000 + 25)),
+		CODEC_ID_ADPCM_EA_MAXIS_XA((0x11000 + 26)),
+		CODEC_ID_ADPCM_IMA_ISS((0x11000 + 27)),
+		CODEC_ID_ADPCM_G722((0x11000 + 28)),
+		CODEC_ID_ADPCM_IMA_APC((0x11000 + 29)),
+		CODEC_ID_VIMA((('A') | (('M') << 8) | (('I') << 16) | ('V' << 24))),
+		/** AMR */
+		CODEC_ID_AMR_NB(0x12000),
+		CODEC_ID_AMR_WB((0x12000 + 1)),
+		/** RealAudio codecs */
+		CODEC_ID_RA_144(0x13000),
+		CODEC_ID_RA_288((0x13000 + 1)),
+		/** various DPCM codecs */
+		CODEC_ID_ROQ_DPCM(0x14000),
+		CODEC_ID_INTERPLAY_DPCM((0x14000 + 1)),
+		CODEC_ID_XAN_DPCM((0x14000 + 2)),
+		CODEC_ID_SOL_DPCM((0x14000 + 3)),
+		/** audio codecs */
+		CODEC_ID_MP2(0x15000),
+		/** < preferred ID for decoding MPEG audio layer 1, 2 or 3 */
+		CODEC_ID_MP3((0x15000 + 1)),
+		CODEC_ID_AAC((0x15000 + 2)),
+		CODEC_ID_AC3((0x15000 + 3)),
+		CODEC_ID_DTS((0x15000 + 4)),
+		CODEC_ID_VORBIS((0x15000 + 5)),
+		CODEC_ID_DVAUDIO((0x15000 + 6)),
+		CODEC_ID_WMAV1((0x15000 + 7)),
+		CODEC_ID_WMAV2((0x15000 + 8)),
+		CODEC_ID_MACE3((0x15000 + 9)),
+		CODEC_ID_MACE6((0x15000 + 10)),
+		CODEC_ID_VMDAUDIO((0x15000 + 11)),
+		CODEC_ID_FLAC((0x15000 + 12)),
+		CODEC_ID_MP3ADU((0x15000 + 13)),
+		CODEC_ID_MP3ON4((0x15000 + 14)),
+		CODEC_ID_SHORTEN((0x15000 + 15)),
+		CODEC_ID_ALAC((0x15000 + 16)),
+		CODEC_ID_WESTWOOD_SND1((0x15000 + 17)),
+		/** < as in Berlin toast format */
+		CODEC_ID_GSM((0x15000 + 18)),
+		CODEC_ID_QDM2((0x15000 + 19)),
+		CODEC_ID_COOK((0x15000 + 20)),
+		CODEC_ID_TRUESPEECH((0x15000 + 21)),
+		CODEC_ID_TTA((0x15000 + 22)),
+		CODEC_ID_SMACKAUDIO((0x15000 + 23)),
+		CODEC_ID_QCELP((0x15000 + 24)),
+		CODEC_ID_WAVPACK((0x15000 + 25)),
+		CODEC_ID_DSICINAUDIO((0x15000 + 26)),
+		CODEC_ID_IMC((0x15000 + 27)),
+		CODEC_ID_MUSEPACK7((0x15000 + 28)),
+		CODEC_ID_MLP((0x15000 + 29)),
+		/** as found in WAV */
+		CODEC_ID_GSM_MS((0x15000 + 30)),
+		CODEC_ID_ATRAC3((0x15000 + 31)),
+		CODEC_ID_VOXWARE((0x15000 + 32)),
+		CODEC_ID_APE((0x15000 + 33)),
+		CODEC_ID_NELLYMOSER((0x15000 + 34)),
+		CODEC_ID_MUSEPACK8((0x15000 + 35)),
+		CODEC_ID_SPEEX((0x15000 + 36)),
+		CODEC_ID_WMAVOICE((0x15000 + 37)),
+		CODEC_ID_WMAPRO((0x15000 + 38)),
+		CODEC_ID_WMALOSSLESS((0x15000 + 39)),
+		CODEC_ID_ATRAC3P((0x15000 + 40)),
+		CODEC_ID_EAC3((0x15000 + 41)),
+		CODEC_ID_SIPR((0x15000 + 42)),
+		CODEC_ID_MP1((0x15000 + 43)),
+		CODEC_ID_TWINVQ((0x15000 + 44)),
+		CODEC_ID_TRUEHD((0x15000 + 45)),
+		CODEC_ID_MP4ALS((0x15000 + 46)),
+		CODEC_ID_ATRAC1((0x15000 + 47)),
+		CODEC_ID_BINKAUDIO_RDFT((0x15000 + 48)),
+		CODEC_ID_BINKAUDIO_DCT((0x15000 + 49)),
+		CODEC_ID_AAC_LATM((0x15000 + 50)),
+		CODEC_ID_QDMC((0x15000 + 51)),
+		CODEC_ID_CELT((0x15000 + 52)),
+		CODEC_ID_G723_1((0x15000 + 53)),
+		CODEC_ID_G729((0x15000 + 54)),
+		CODEC_ID_8SVX_EXP((0x15000 + 55)),
+		CODEC_ID_8SVX_FIB((0x15000 + 56)),
+		CODEC_ID_BMV_AUDIO((0x15000 + 57)),
+		CODEC_ID_RALF((0x15000 + 58)),
+		CODEC_ID_IAC((0x15000 + 59)),
+		CODEC_ID_ILBC((0x15000 + 60)),
+		CODEC_ID_FFWAVESYNTH((('S') | (('W') << 8) | (('F') << 16) | ('F' << 24))),
+		CODEC_ID_SONIC((('C') | (('N') << 8) | (('O') << 16) | ('S' << 24))),
+		CODEC_ID_SONIC_LS((('L') | (('N') << 8) | (('O') << 16) | ('S' << 24))),
+		CODEC_ID_PAF_AUDIO((('A') | (('F') << 8) | (('A') << 16) | ('P' << 24))),
+		CODEC_ID_OPUS((('S') | (('U') << 8) | (('P') << 16) | ('O' << 24))),
+		/**
+		 * subtitle codecs<br>
+		 * < A dummy ID pointing at the start of subtitle codecs.
+		 */
+		CODEC_ID_FIRST_SUBTITLE(0x17000),
+		CODEC_ID_DVD_SUBTITLE(0x17000),
+		CODEC_ID_DVB_SUBTITLE((0x17000 + 1)),
+		/** < raw UTF-8 text */
+		CODEC_ID_TEXT((0x17000 + 2)),
+		CODEC_ID_XSUB((0x17000 + 3)),
+		CODEC_ID_SSA((0x17000 + 4)),
+		CODEC_ID_MOV_TEXT((0x17000 + 5)),
+		CODEC_ID_HDMV_PGS_SUBTITLE((0x17000 + 6)),
+		CODEC_ID_DVB_TELETEXT((0x17000 + 7)),
+		CODEC_ID_SRT((0x17000 + 8)),
+		CODEC_ID_MICRODVD((('D') | (('V') << 8) | (('D') << 16) | ('m' << 24))),
+		CODEC_ID_EIA_608((('8') | (('0') << 8) | (('6') << 16) | ('c' << 24))),
+		CODEC_ID_JACOSUB((('B') | (('U') << 8) | (('S') << 16) | ('J' << 24))),
+		CODEC_ID_SAMI((('I') | (('M') << 8) | (('A') << 16) | ('S' << 24))),
+		CODEC_ID_REALTEXT((('T') | (('X') << 8) | (('T') << 16) | ('R' << 24))),
+		CODEC_ID_SUBVIEWER((('V') | (('b') << 8) | (('u') << 16) | ('S' << 24))),
+		/**
+		 * other specific kind of codecs (generally used for attachments)<br>
+		 * < A dummy ID pointing at the start of various fake codecs.
+		 */
+		CODEC_ID_FIRST_UNKNOWN(0x18000),
+		CODEC_ID_TTF(0x18000),
+		CODEC_ID_BINTEXT((('T') | (('X') << 8) | (('T') << 16) | ('B' << 24))),
+		CODEC_ID_XBIN((('N') | (('I') << 8) | (('B') << 16) | ('X' << 24))),
+		CODEC_ID_IDF((('F') | (('D') << 8) | (('I') << 16) | (0 << 24))),
+		CODEC_ID_OTF((('F') | (('T') << 8) | (('O') << 16) | (0 << 24))),
+		/** < codec_id is not known (like CODEC_ID_NONE) but lavf should attempt to identify it */
+		CODEC_ID_PROBE(0x19000),
+		/**
+		 * < _FAKE_ codec to indicate a raw MPEG-2 TS<br>
+		 * stream (only used by libavformat)
+		 */
+		CODEC_ID_MPEG2TS(0x20000),
+		/**
+		 * < _FAKE_ codec to indicate a MPEG-4 Systems<br>
+		 * stream (only used by libavformat)
+		 */
+		CODEC_ID_MPEG4SYSTEMS(0x20001),
+		/** < Dummy codec for streams containing only metadata information. */
+		CODEC_ID_FFMETADATA(0x21000);
+		AVCodecID(long value) {
+			this.value = value;
+		}
+		public final long value;
+		public long value() {
+			return this.value;
+		}
+		public Iterator<AVCodecID > iterator() {
+			return Collections.singleton(this).iterator();
+		}
+		public static IntValuedEnum<AVCodecID > fromValue(int value) {
+			return FlagSet.fromValue(value, values());
+		}
+	};
+	/**
+	 * enum values<br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:18</i>
+	 */
+	public enum AVDiscard implements IntValuedEnum<AVDiscard > {
+		/** < discard nothing */
+		AVDISCARD_NONE(-16),
+		/** < discard useless packets like 0 size packets in avi */
+		AVDISCARD_DEFAULT(0),
+		/** < discard all non reference */
+		AVDISCARD_NONREF(8),
+		/** < discard all bidirectional frames */
+		AVDISCARD_BIDIR(16),
+		/** < discard all non intra frames */
+		AVDISCARD_NONINTRA(24),
+		/** < discard all frames except keyframes */
+		AVDISCARD_NONKEY(32),
+		/** < discard all */
+		AVDISCARD_ALL(48);
+		AVDiscard(long value) {
+			this.value = value;
+		}
+		public final long value;
+		public long value() {
+			return this.value;
+		}
+		public Iterator<AVDiscard > iterator() {
+			return Collections.singleton(this).iterator();
+		}
+		public static IntValuedEnum<AVDiscard > fromValue(int value) {
+			return FlagSet.fromValue(value, values());
+		}
+	};
+	/**
+	 * enum values<br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:31</i>
+	 */
+	public enum AVAudioServiceType implements IntValuedEnum<AVAudioServiceType > {
+		AV_AUDIO_SERVICE_TYPE_MAIN(0),
+		AV_AUDIO_SERVICE_TYPE_EFFECTS(1),
+		AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED(2),
+		AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED(3),
+		AV_AUDIO_SERVICE_TYPE_DIALOGUE(4),
+		AV_AUDIO_SERVICE_TYPE_COMMENTARY(5),
+		AV_AUDIO_SERVICE_TYPE_EMERGENCY(6),
+		AV_AUDIO_SERVICE_TYPE_VOICE_OVER(7),
+		AV_AUDIO_SERVICE_TYPE_KARAOKE(8),
+		/** < Not part of ABI */
+		AV_AUDIO_SERVICE_TYPE_NB(9);
+		AVAudioServiceType(long value) {
+			this.value = value;
+		}
+		public final long value;
+		public long value() {
+			return this.value;
+		}
+		public Iterator<AVAudioServiceType > iterator() {
+			return Collections.singleton(this).iterator();
+		}
+		public static IntValuedEnum<AVAudioServiceType > fromValue(int value) {
+			return FlagSet.fromValue(value, values());
+		}
+	};
+	/**
+	 * enum values<br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:53</i>
+	 */
+	public enum AVPacketSideDataType implements IntValuedEnum<AVPacketSideDataType > {
+		AV_PKT_DATA_PALETTE(0),
+		AV_PKT_DATA_NEW_EXTRADATA(1),
+		AV_PKT_DATA_PARAM_CHANGE(2),
+		AV_PKT_DATA_H263_MB_INFO(3),
+		AV_PKT_DATA_REPLAYGAIN(4),
+		AV_PKT_DATA_DISPLAYMATRIX(5),
+		AV_PKT_DATA_SKIP_SAMPLES(70),
+		AV_PKT_DATA_JP_DUALMONO(71),
+		AV_PKT_DATA_STRINGS_METADATA(72),
+		AV_PKT_DATA_SUBTITLE_POSITION(73),
+		AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL(74),
+		AV_PKT_DATA_WEBVTT_IDENTIFIER(75),
+		AV_PKT_DATA_WEBVTT_SETTINGS(76),
+		AV_PKT_DATA_METADATA_UPDATE(77);
+		AVPacketSideDataType(long value) {
+			this.value = value;
+		}
+		public final long value;
+		public long value() {
+			return this.value;
+		}
+		public Iterator<AVPacketSideDataType > iterator() {
+			return Collections.singleton(this).iterator();
+		}
+		public static IntValuedEnum<AVPacketSideDataType > fromValue(int value) {
+			return FlagSet.fromValue(value, values());
+		}
+	};
+	/**
+	 * enum values<br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:92</i>
+	 */
+	public enum AVFieldOrder implements IntValuedEnum<AVFieldOrder > {
+		AV_FIELD_UNKNOWN(0),
+		AV_FIELD_PROGRESSIVE(1),
+		/** < Top coded_first, top displayed first */
+		AV_FIELD_TT(2),
+		/** < Bottom coded first, bottom displayed first */
+		AV_FIELD_BB(3),
+		/** < Top coded first, bottom displayed first */
+		AV_FIELD_TB(4),
+		/** < Bottom coded first, top displayed first */
+		AV_FIELD_BT(5);
+		AVFieldOrder(long value) {
+			this.value = value;
+		}
+		public final long value;
+		public long value() {
+			return this.value;
+		}
+		public Iterator<AVFieldOrder > iterator() {
+			return Collections.singleton(this).iterator();
+		}
+		public static IntValuedEnum<AVFieldOrder > fromValue(int value) {
+			return FlagSet.fromValue(value, values());
+		}
+	};
+	/**
+	 * enum values<br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:548</i>
+	 */
+	public enum AVPictureStructure implements IntValuedEnum<AVPictureStructure > {
+		/** < unknown */
+		AV_PICTURE_STRUCTURE_UNKNOWN(0),
+		/** < coded as top field */
+		AV_PICTURE_STRUCTURE_TOP_FIELD(1),
+		/** < coded as bottom field */
+		AV_PICTURE_STRUCTURE_BOTTOM_FIELD(2),
+		/** < coded as frame */
+		AV_PICTURE_STRUCTURE_FRAME(3);
+		AVPictureStructure(long value) {
+			this.value = value;
+		}
+		public final long value;
+		public long value() {
+			return this.value;
+		}
+		public Iterator<AVPictureStructure > iterator() {
+			return Collections.singleton(this).iterator();
+		}
+		public static IntValuedEnum<AVPictureStructure > fromValue(int value) {
+			return FlagSet.fromValue(value, values());
+		}
+	};
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_AUDIO_CONVERT = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_CLOSED_GOP = (int)0x80000000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_ALTIVEC = (int)8;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_ERROR_RATE = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_CHROMA = (int)256;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_VC1_MAIN = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG2_SS = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = (int)9;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_BUFFERS = (int)0x00008000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_BUGS = (int)0x00001000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_AMV = (int)32;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_EF_EXPLODE = (int)(1 << 3);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_ER = (int)0x00000400;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_SUB_CHARENC_MODE_PRE_DECODER = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_GRAY = (int)0x2000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_16x8 = (int)0x0010;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CODER_TYPE_RLE = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_MB_DECISION_BITS = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CODER_TYPE_VLC = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_QPEL_CHROMA2 = (int)256;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_EMU_EDGE = (int)0x4000;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_ARCH_ALPHA = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_MB_DECISION_SIMPLE = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_CORE_SCALABLE = (int)10;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_GMC = (boolean)(55 < 57);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_UNALIGNED = (int)0x0001;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG2_IGNORE_CROP = (int)0x00010000;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final int LIBAVCODEC_VERSION_INT = (int)(55 << 16 | 69 << 8 | 100);
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_LOWRES = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_COMPLIANCE_VERY_STRICT = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUFFER_TYPE_INTERNAL = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DTG_AFD_16_9_SP_14_9 = (int)14;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_P0L1 = (int)0x4000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_8x16 = (int)0x0020;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_HIGH_444 = (int)144;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_HIGH = (int)100;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_NORMALIZE_AQP = (boolean)(55 < 57);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_HEVC_MAIN_10 = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG2_SHOW_ALL = (int)0x00400000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int SLICE_FLAG_ALLOW_PLANE = (int)0x0004;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_DTS_HD_HRA = (int)50;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_TRUNCATED = (int)0x00010000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_SSE = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_STARTCODE = (int)0x00000100;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUFFER_HINTS_PRESERVE = (int)0x04;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_PSNR = (int)4;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_DTS = (int)20;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_HIGH_444_INTRA = (int)(244 | (1 << 11));
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_HIGH_422 = (int)122;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_SIMPLE_STUDIO = (int)14;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_INTRA_ONLY = (int)0x40000000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_LEVEL_UNKNOWN = (int)-99;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_FRAME_THREADS = (int)0x1000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DTG_AFD_14_9 = (int)11;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG2_NO_OUTPUT = (int)0x00000004;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_BITEXACT = (int)0x00800000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_SH4 = (int)9;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_DTS_ES = (int)30;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_INT = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_THREAD_FRAME = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DTG_AFD_16_9 = (int)10;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_VARIABLE_FRAME_SIZE = (int)0x10000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_AUTO = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_INTERLACED_DCT = (int)0x00040000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_CHANNEL_CONF = (int)0x0400;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_LOW_DELAY = (int)0x00080000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_MV = (int)32;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_EF_AGGRESSIVE = (int)(1 << 18);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_P0L0 = (int)0x1000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_DTS_96_24 = (int)40;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_INTERLACED_ME = (int)0x20000000;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_OLD_DECODE_AUDIO = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_PASS2 = (int)0x0400;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_PASS1 = (int)0x0200;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_EF_CAREFUL = (int)(1 << 16);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_DTS_HD_MA = (int)60;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_THREAD_SLICE = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_SIMPLEMMX = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = (int)13;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_MV0 = (boolean)(55 < 57);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PRED_PLANE = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_VIS_MB_TYPE = (int)0x00004000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_VSSE = (int)9;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_SIMPLEARMV5TE = (int)16;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_NSSE = (int)10;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_MB_TYPE = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_QP = (int)16;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_QSCALE_TYPE_MPEG1 = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_QSCALE_TYPE_MPEG2 = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_ARM = (int)7;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_SET_DIMENSIONS = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_RC = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_IPP = (int)13;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DCT_MMX = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG2_422 = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_XVIDMMX = (int)14;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_QUANT = (int)0x00010000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG2_AAC_HE = (int)131;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_EF_BITSTREAM = (int)(1 << 1);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_SATD = (int)2;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_OLD_ENCODE_VIDEO = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_RD = (int)6;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG2_SNR_SCALABLE = (int)3;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_CODEC_NAME = (boolean)(55 < 57);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_DRAW_HORIZ_BAND = (int)0x0001;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_DCT_COEFF = (int)0x00000040;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_AC_VLC = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_DEBUG_MV = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_DEINTERLACE = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_SAD = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_TRUNCATED = (int)16384;
+	/**
+	 * define<br>
+	 * Conversion Error : 55.69.<br>
+	 * SKIPPED:<br>
+	 * <i>native declaration : ./libavcodec/version.h:0</i><br>
+	 * 55.69.
+	 */
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_JPEG2000_DCINEMA_4K = (int)4;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_XVID_ILACE = (int)4;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CODER_TYPE_RAW = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int SLICE_FLAG_ALLOW_FIELD = (int)0x0002;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_THREADS = (int)0x00010000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUFFER_HINTS_REUSABLE = (int)0x08;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_JPEG2000_DCINEMA_2K = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_HIGH_444_PREDICTIVE = (int)244;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_MB_TYPE = (int)8;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DCT_AUTO = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_HYBRID = (int)8;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_RC_STRATEGY_XVID = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_INTRA4x4 = (int)0x0001;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CODER_TYPE_DEFLATE = (int)4;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_AAC_LTP = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_CBP = (int)0x00020000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_SIMPLEVIS = (int)18;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_LOSSLESS = (int)0x80000000;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_CODEC_ID = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_NEG_LINESIZES = (int)0x0800;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_EF_BUFFER = (int)(1 << 2);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_TRUNCATED = (int)0x0008;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_ADVANCED_SIMPLE = (int)15;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_AVCODEC_RESAMPLE = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_FAST_MALLOC = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_QSCALE_TYPE_VP56 = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_N_BIT = (int)4;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_MAX_BFRAMES = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEFAULT_QUANT_BIAS = (int)999999;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG2_MAIN = (int)4;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = (int)0;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_CAP_VDPAU = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_AAC_LOW = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_HEVC_MAIN_STILL_PICTURE = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_BASELINE = (int)66;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_GET_BUFFER_FLAG_REF = (int)(1 << 0);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_GMC = (int)0x0400;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_AUTO_THREADS = (int)0x8000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_SUBFRAMES = (int)0x0100;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_4MV = (int)0x0004;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_QSCALE_TYPE = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG2_LOCAL_HEADER = (int)0x00000008;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_EXPERIMENTAL = (int)0x0200;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_OLD_MSMPEG4 = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_PICT_INFO = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DCT_INT = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_SIMPLENEON = (int)22;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_VIS_MV_B_BACK = (int)0x00000004;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_NORMALIZE_AQP = (int)0x00020000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG2_SIMPLE = (int)5;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_BUFS_VDPAU = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_INPUT_PRESERVED = (boolean)(55 < 57);
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_CODEC_PKT = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_ASPECT_EXTENDED = (int)15;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = (int)6;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final int LIBAVCODEC_VERSION_MINOR = (int)69;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_MB_DECISION_RD = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_DC_CLIP = (int)4096;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_W97 = (int)12;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_AAC_LD = (int)22;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_SIMPLEARMV6 = (int)17;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_8x8 = (int)0x0040;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_ARCH_SPARC = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CODER_TYPE_AC = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_CAVLC_444 = (int)44;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_CORE = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int SLICE_FLAG_CODED_ORDER = (int)0x0001;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_P1L1 = (int)0x8000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_EF_COMPLIANT = (int)(1 << 17);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_P1L0 = (int)0x2000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_VC1_SIMPLE = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_VC1_ADVANCED = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_DR1 = (int)0x0002;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_HIGH_10 = (int)110;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final String LIBAVCODEC_IDENT = (String)"Lavc55.69.100";
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_MV0 = (int)0x0040;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_INTERLACED = (int)0x0080;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_ADVANCED_CODING = (int)11;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_QPEL_CHROMA = (int)64;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_COMPLIANCE_UNOFFICIAL = (int)-1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_VIS_MV_B_FOR = (int)0x00000002;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_W53 = (int)11;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_AAC_HE = (int)4;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_SUB_CHARENC_MODE_AUTOMATIC = (int)0;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_VOXWARE = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_HIGH_422_INTRA = (int)(122 | (1 << 11));
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_PKT_FLAG_KEY = (int)0x0001;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG2_AAC_LOW = (int)128;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_STD_QPEL = (int)128;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DTG_AFD_SP_4_3 = (int)15;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_MMCO = (int)0x00000800;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = (int)7;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_COMPLIANCE_STRICT = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_L0L1 = (int)((0x1000 | 0x2000) | (0x4000 | 0x8000));
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_HPEL_CHROMA = (int)2048;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_INTRA16x16 = (int)0x0002;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_VIS_QP = (int)0x00002000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_BITSTREAM = (int)4;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_DCT264 = (int)14;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_EC_DEBLOCK = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_RESERVED = (int)-100;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_16x16 = (int)0x0008;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_AAC_MAIN = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_EDGE = (int)1024;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_HWACCEL_VDPAU = (int)0x0080;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DTG_AFD_SAME = (int)8;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG2_FAST = (int)0x00000001;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUFFER_TYPE_USER = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG2_CHUNKS = (int)0x00008000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_PKT_FLAG_CORRUPT = (int)0x0002;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_SIMPLEALPHA = (int)23;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_MS = (int)8192;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_AAC_HE_V2 = (int)28;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_QSCALE = (int)0x0002;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_SIMPLE_SCALABLE = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_ACPRED = (int)0x0200;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_FAAN = (int)20;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_INTRA = (int)(1 << 11);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUFFER_TYPE_COPY = (int)8;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUFFER_HINTS_VALID = (int)0x01;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_DIRECT2 = (int)0x0100;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PRED_LEFT = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_INPUT_PRESERVED = (int)0x0100;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_COMPRESSION_DEFAULT = (int)-1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG2_HIGH = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUFFER_HINTS_READABLE = (int)0x02;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = (int)2;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_OLD_ENCODE_AUDIO = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_OLD_MSMPEG4 = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_EXTENDED = (int)88;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_QPEL = (int)0x0010;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_COMPLIANCE_NORMAL = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_L0 = (int)(0x1000 | 0x2000);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_HWACCEL = (int)0x0010;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_L1 = (int)(0x4000 | 0x8000);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_MAIN = (int)77;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_NEG_LINESIZES = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUFFER_TYPE_SHARED = (int)4;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_DELAY = (int)0x0020;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_SCALABLE_TEXTURE = (int)5;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_MISSING_SAMPLE = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_AUTODETECT = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_VC1_COMPLEX = (int)2;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_ASPECT_EXTENDED = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_COMPLIANCE_EXPERIMENTAL = (int)-2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_VIS_MV_P_FOR = (int)0x00000001;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_DCT = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_HEVC_MAIN = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_SIMPLEARM = (int)10;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_SIMPLE = (int)0;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final int LIBAVCODEC_BUILD = (int)(55 << 16 | 69 << 8 | 100);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_SUB_CHARENC_MODE_DO_NOTHING = (int)-1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_MAIN = (int)3;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_AAC_SSR = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_GLOBAL_HEADER = (int)0x00400000;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_DESTRUCT_PACKET = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final int LIBAVCODEC_VERSION_MAJOR = (int)55;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_PSNR = (int)0x8000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_SMALL_LAST_FRAME = (int)0x0040;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_SKIP = (int)0x0800;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_THREAD_OPAQUE = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_HIGH_10_INTRA = (int)(110 | (1 << 11));
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int AV_EF_CRCCHECK = (int)(1 << 0);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DCT_FAAN = (int)6;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_ARCH_SH4 = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_QSCALE_TYPE_H264 = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_SKIP = (int)0x00000080;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_CONSTRAINED_BASELINE = (int)(66 | (1 << 9));
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_GET_BUFFER = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DTG_AFD_4_3_SP_14_9 = (int)13;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DCT_ALTIVEC = (int)5;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_BIT = (int)5;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_AC_VLC = (int)0;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DEBUG_PTS = (int)0x00000200;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DTG_AFD_4_3 = (int)9;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_NO_PADDING = (int)16;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_LOOP_FILTER = (int)0x00000800;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_DCTMAX = (int)13;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_IDCT_SIMPLE = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_UNKNOWN = (int)-99;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_VSAD = (int)8;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_SLICE_THREADS = (int)0x2000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_CAP_PARAM_CHANGE = (int)0x4000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_MPEG4_ADVANCED_CORE = (int)12;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int MB_TYPE_INTRA_PCM = (int)0x0004;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_EMU_EDGE = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG2_DROP_FRAME_TIMECODE = (int)0x00002000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_DCT_FASTINT = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_AC_PRED = (int)0x01000000;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_UMP4 = (int)8;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_CMP_ZERO = (int)7;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PRED_MEDIAN = (int)2;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_H264_CONSTRAINED = (int)(1 << 9);
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_GMC = (int)0x0020;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_BUG_DIRECT_BLOCKSIZE = (int)512;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_EC_GUESS_MVS = (int)1;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int FF_PROFILE_AAC_ELD = (int)38;
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final boolean FF_API_REQUEST_CHANNELS = (boolean)(55 < 56);
+	/** <i>native declaration : ./libavcodec/version.h</i> */
+	public static final int LIBAVCODEC_VERSION_MICRO = (int)100;
+	/** <i>native declaration : ./libavcodec/avcodec.h</i> */
+	public static final int CODEC_FLAG_OUTPUT_CORRUPT = (int)0x0008;
+	/**
+	 * Return the LIBAVCODEC_VERSION_INT constant.<br>
+	 * Original signature : <code>int avcodec_version()</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:361</i>
+	 */
+	public static native int avcodec_version();
+	/**
+	 * Allocate an AVCodecContext and set its fields to default values. The<br>
+	 * resulting struct should be freed with avcodec_free_context().<br>
+	 * * @param codec if non-NULL, allocate private data and initialize defaults<br>
+	 *              for the given codec. It is illegal to then call avcodec_open2()<br>
+	 *              with a different codec.<br>
+	 *              If NULL, then the codec-specific defaults won't be initialized,<br>
+	 *              which may result in suboptimal default settings (this is<br>
+	 *              important mainly for encoders, e.g. libx264).<br>
+	 * * @return An AVCodecContext filled with default values or NULL on failure.<br>
+	 * @see avcodec_get_context_defaults<br>
+	 * Original signature : <code>AVCodecContext* avcodec_alloc_context3(const AVCodec*)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:375</i>
+	 */
+	public static Pointer<AVCodecContext > avcodec_alloc_context3(Pointer<AVCodec > codec) {
+		return Pointer.pointerToAddress(avcodec_alloc_context3(Pointer.getPeer(codec)), AVCodecContext.class);
+	}
+	@Ptr 
+	protected native static long avcodec_alloc_context3(@Ptr long codec);
+	/**
+	 * Free the codec context and everything associated with it and write NULL to<br>
+	 * the provided pointer.<br>
+	 * Original signature : <code>void avcodec_free_context(AVCodecContext**)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:381</i>
+	 */
+	public static void avcodec_free_context(Pointer<Pointer<AVCodecContext > > avctx) {
+		avcodec_free_context(Pointer.getPeer(avctx));
+	}
+	protected native static void avcodec_free_context(@Ptr long avctx);
+	/**
+	 * Set the fields of the given AVCodecContext to default values corresponding<br>
+	 * to the given codec (defaults may be codec-dependent).<br>
+	 * * Do not call this function if a non-NULL codec has been passed<br>
+	 * to avcodec_alloc_context3() that allocated this AVCodecContext.<br>
+	 * If codec is non-NULL, it is illegal to call avcodec_open2() with a<br>
+	 * different codec on this AVCodecContext.<br>
+	 * Original signature : <code>int avcodec_get_context_defaults3(AVCodecContext*, const AVCodec*)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:391</i>
+	 */
+	public static int avcodec_get_context_defaults3(Pointer<AVCodecContext > s, Pointer<AVCodec > codec) {
+		return avcodec_get_context_defaults3(Pointer.getPeer(s), Pointer.getPeer(codec));
+	}
+	protected native static int avcodec_get_context_defaults3(@Ptr long s, @Ptr long codec);
+	/**
+	 * Original signature : <code>AVFrame* avcodec_alloc_frame()</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:393</i>
+	 */
+	public static Pointer<AVFrame > avcodec_alloc_frame() {
+		return Pointer.pointerToAddress(avcodec_alloc_frame$2(), AVFrame.class);
+	}
+	@Ptr 
+	protected native static long avcodec_alloc_frame$2();
+	/**
+	 * Initialize the AVCodecContext to use the given AVCodec. Prior to using this<br>
+	 * function the context has to be allocated with avcodec_alloc_context3().<br>
+	 * * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),<br>
+	 * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for<br>
+	 * retrieving a codec.<br>
+	 * * @warning This function is not thread safe!<br>
+	 * * @code<br>
+	 * avcodec_register_all();<br>
+	 * av_dict_set(&opts, "b", "2.5M", 0);<br>
+	 * codec = avcodec_find_decoder(AV_CODEC_ID_H264);<br>
+	 * if (!codec)<br>
+	 *     exit(1);<br>
+	 * * context = avcodec_alloc_context3(codec);<br>
+	 * * if (avcodec_open2(context, codec, opts) < 0)<br>
+	 *     exit(1);<br>
+	 * @endcode<br>
+	 * * @param avctx The context to initialize.<br>
+	 * @param codec The codec to open this context for. If a non-NULL codec has been<br>
+	 *              previously passed to avcodec_alloc_context3() or<br>
+	 *              avcodec_get_context_defaults3() for this context, then this<br>
+	 *              parameter MUST be either NULL or equal to the previously passed<br>
+	 *              codec.<br>
+	 * @param options A dictionary filled with AVCodecContext and codec-private options.<br>
+	 *                On return this object will be filled with options that were not found.<br>
+	 * * @return zero on success, a negative value on error<br>
+	 * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),<br>
+	 *      av_dict_set(), av_opt_find().<br>
+	 * Original signature : <code>int avcodec_open2(AVCodecContext*, const AVCodec*, AVDictionary**)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:424</i>
+	 */
+	public static int avcodec_open2(Pointer<AVCodecContext > avctx, Pointer<AVCodec > codec, Pointer<Pointer<AVDictionary > > options) {
+		return avcodec_open2(Pointer.getPeer(avctx), Pointer.getPeer(codec), Pointer.getPeer(options));
+	}
+	protected native static int avcodec_open2(@Ptr long avctx, @Ptr long codec, @Ptr long options);
+	/**
+	 * Close a given AVCodecContext and free all the data associated with it<br>
+	 * (but not the AVCodecContext itself).<br>
+	 * * Calling this function on an AVCodecContext that hasn't been opened will free<br>
+	 * the codec-specific data allocated in avcodec_alloc_context3() /<br>
+	 * avcodec_get_context_defaults3() with a non-NULL codec. Subsequent calls will<br>
+	 * do nothing.<br>
+	 * Original signature : <code>int avcodec_close(AVCodecContext*)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:434</i>
+	 */
+	public static int avcodec_close(Pointer<AVCodecContext > avctx) {
+		return avcodec_close(Pointer.getPeer(avctx));
+	}
+	protected native static int avcodec_close(@Ptr long avctx);
+	/**
+	 * Initialize optional fields of a packet with default values.<br>
+	 * * Note, this does not touch the data and size members, which have to be<br>
+	 * initialized separately.<br>
+	 * * @param pkt packet<br>
+	 * Original signature : <code>void av_init_packet(AVPacket*)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:442</i>
+	 */
+	public static void av_init_packet(Pointer<AVPacket > pkt) {
+		av_init_packet(Pointer.getPeer(pkt));
+	}
+	protected native static void av_init_packet(@Ptr long pkt);
+	/**
+	 * Free a packet.<br>
+	 * * @param pkt packet to free<br>
+	 * Original signature : <code>void av_free_packet(AVPacket*)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:448</i>
+	 */
+	public static void av_free_packet(Pointer<AVPacket > pkt) {
+		av_free_packet(Pointer.getPeer(pkt));
+	}
+	protected native static void av_free_packet(@Ptr long pkt);
+	/**
+	 * Find a registered decoder with a matching codec ID.<br>
+	 * * @param id AVCodecID of the requested decoder<br>
+	 * @return A decoder if one was found, NULL otherwise.<br>
+	 * Original signature : <code>AVCodec* avcodec_find_decoder(AVCodecID)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:455</i>
+	 */
+	public static Pointer<AVCodec > avcodec_find_decoder(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
+		return Pointer.pointerToAddress(avcodec_find_decoder((int)id.value()), AVCodec.class);
+	}
+	@Ptr 
+	protected native static long avcodec_find_decoder(int id);
+	/**
+	 * Decode the audio frame of size avpkt->size from avpkt->data into frame.<br>
+	 * * Some decoders may support multiple frames in a single AVPacket. Such<br>
+	 * decoders would then just decode the first frame and the return value would be<br>
+	 * less than the packet size. In this case, avcodec_decode_audio4 has to be<br>
+	 * called again with an AVPacket containing the remaining data in order to<br>
+	 * decode the second frame, etc...  Even if no frames are returned, the packet<br>
+	 * needs to be fed to the decoder with remaining data until it is completely<br>
+	 * consumed or an error occurs.<br>
+	 * * Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input<br>
+	 * and output. This means that for some packets they will not immediately<br>
+	 * produce decoded output and need to be flushed at the end of decoding to get<br>
+	 * all the decoded data. Flushing is done by calling this function with packets<br>
+	 * with avpkt->data set to NULL and avpkt->size set to 0 until it stops<br>
+	 * returning samples. It is safe to flush even those decoders that are not<br>
+	 * marked with CODEC_CAP_DELAY, then no samples will be returned.<br>
+	 * * @warning The input buffer, avpkt->data must be FF_INPUT_BUFFER_PADDING_SIZE<br>
+	 *          larger than the actual read bytes because some optimized bitstream<br>
+	 *          readers read 32 or 64 bits at once and could read over the end.<br>
+	 * * @param      avctx the codec context<br>
+	 * @param[out] frame The AVFrame in which to store decoded audio samples.<br>
+	 *                   The decoder will allocate a buffer for the decoded frame by<br>
+	 *                   calling the AVCodecContext.get_buffer2() callback.<br>
+	 *                   When AVCodecContext.refcounted_frames is set to 1, the frame is<br>
+	 *                   reference counted and the returned reference belongs to the<br>
+	 *                   caller. The caller must release the frame using av_frame_unref()<br>
+	 *                   when the frame is no longer needed. The caller may safely write<br>
+	 *                   to the frame if av_frame_is_writable() returns 1.<br>
+	 *                   When AVCodecContext.refcounted_frames is set to 0, the returned<br>
+	 *                   reference belongs to the decoder and is valid only until the<br>
+	 *                   next call to this function or until closing or flushing the<br>
+	 *                   decoder. The caller may not write to it.<br>
+	 * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is<br>
+	 *                           non-zero. Note that this field being set to zero<br>
+	 *                           does not mean that an error has occurred. For<br>
+	 *                           decoders with CODEC_CAP_DELAY set, no given decode<br>
+	 *                           call is guaranteed to produce a frame.<br>
+	 * @param[in]  avpkt The input AVPacket containing the input buffer.<br>
+	 *                   At least avpkt->data and avpkt->size should be set. Some<br>
+	 *                   decoders might also require additional fields to be set.<br>
+	 * @return A negative error code is returned if an error occurred during<br>
+	 *         decoding, otherwise the number of bytes consumed from the input<br>
+	 *         AVPacket is returned.<br>
+	 * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:501</i>
+	 */
+	public static int avcodec_decode_audio4(Pointer<AVCodecContext > avctx, Pointer<AVFrame > frame, Pointer<Integer > got_frame_ptr, Pointer<AVPacket > avpkt) {
+		return avcodec_decode_audio4(Pointer.getPeer(avctx), Pointer.getPeer(frame), Pointer.getPeer(got_frame_ptr), Pointer.getPeer(avpkt));
+	}
+	protected native static int avcodec_decode_audio4(@Ptr long avctx, @Ptr long frame, @Ptr long got_frame_ptr, @Ptr long avpkt);
+	/**
+	 * Decode the video frame of size avpkt->size from avpkt->data into picture.<br>
+	 * Some decoders may support multiple frames in a single AVPacket, such<br>
+	 * decoders would then just decode the first frame.<br>
+	 * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
+	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
+	 * bits at once and could read over the end.<br>
+	 * * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
+	 * no overreading happens for damaged MPEG streams.<br>
+	 * * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay<br>
+	 * between input and output, these need to be fed with avpkt->data=NULL,<br>
+	 * avpkt->size=0 at the end to return the remaining frames.<br>
+	 * * @param avctx the codec context<br>
+	 * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
+	 *             Use av_frame_alloc() to get an AVFrame. The codec will<br>
+	 *             allocate memory for the actual bitmap by calling the<br>
+	 *             AVCodecContext.get_buffer2() callback.<br>
+	 *             When AVCodecContext.refcounted_frames is set to 1, the frame is<br>
+	 *             reference counted and the returned reference belongs to the<br>
+	 *             caller. The caller must release the frame using av_frame_unref()<br>
+	 *             when the frame is no longer needed. The caller may safely write<br>
+	 *             to the frame if av_frame_is_writable() returns 1.<br>
+	 *             When AVCodecContext.refcounted_frames is set to 0, the returned<br>
+	 *             reference belongs to the decoder and is valid only until the<br>
+	 *             next call to this function or until closing or flushing the<br>
+	 *             decoder. The caller may not write to it.<br>
+	 * * @param[in] avpkt The input AVPacket containing the input buffer.<br>
+	 *            You can create such packet with av_init_packet() and by then setting<br>
+	 *            data and size, some decoders might in addition need other fields like<br>
+	 *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
+	 *            fields possible.<br>
+	 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
+	 * @return On error a negative value is returned, otherwise the number of bytes<br>
+	 * used or zero if no frame could be decompressed.<br>
+	 * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:538</i>
+	 */
+	public static int avcodec_decode_video2(Pointer<AVCodecContext > avctx, Pointer<AVFrame > picture, Pointer<Integer > got_picture_ptr, Pointer<AVPacket > avpkt) {
+		return avcodec_decode_video2(Pointer.getPeer(avctx), Pointer.getPeer(picture), Pointer.getPeer(got_picture_ptr), Pointer.getPeer(avpkt));
+	}
+	protected native static int avcodec_decode_video2(@Ptr long avctx, @Ptr long picture, @Ptr long got_picture_ptr, @Ptr long avpkt);
+	/**
+	 * Find a registered encoder with a matching codec ID.<br>
+	 * * @param id AVCodecID of the requested encoder<br>
+	 * @return An encoder if one was found, NULL otherwise.<br>
+	 * Original signature : <code>AVCodec* avcodec_find_encoder(AVCodecID)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:559</i>
+	 */
+	public static Pointer<AVCodec > avcodec_find_encoder(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
+		return Pointer.pointerToAddress(avcodec_find_encoder((int)id.value()), AVCodec.class);
+	}
+	@Ptr 
+	protected native static long avcodec_find_encoder(int id);
+	/**
+	 * Encode a frame of video.<br>
+	 * * Takes input raw video data from frame and writes the next output packet, if<br>
+	 * available, to avpkt. The output packet does not necessarily contain data for<br>
+	 * the most recent frame, as encoders can delay and reorder input frames<br>
+	 * internally as needed.<br>
+	 * * @param avctx     codec context<br>
+	 * @param avpkt     output AVPacket.<br>
+	 *                  The user can supply an output buffer by setting<br>
+	 *                  avpkt->data and avpkt->size prior to calling the<br>
+	 *                  function, but if the size of the user-provided data is not<br>
+	 *                  large enough, encoding will fail. All other AVPacket fields<br>
+	 *                  will be reset by the encoder using av_init_packet(). If<br>
+	 *                  avpkt->data is NULL, the encoder will allocate it.<br>
+	 *                  The encoder will set avpkt->size to the size of the<br>
+	 *                  output packet. The returned data (if any) belongs to the<br>
+	 *                  caller, he is responsible for freeing it.<br>
+	 * *                  If this function fails or produces no output, avpkt will be<br>
+	 *                  freed using av_free_packet() (i.e. avpkt->destruct will be<br>
+	 *                  called to free the user supplied buffer).<br>
+	 * @param[in] frame AVFrame containing the raw video data to be encoded.<br>
+	 *                  May be NULL when flushing an encoder that has the<br>
+	 *                  CODEC_CAP_DELAY capability set.<br>
+	 * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
+	 *                            output packet is non-empty, and to 0 if it is<br>
+	 *                            empty. If the function returns an error, the<br>
+	 *                            packet can be assumed to be invalid, and the<br>
+	 *                            value of got_packet_ptr is undefined and should<br>
+	 *                            not be used.<br>
+	 * @return          0 on success, negative error code on failure<br>
+	 * Original signature : <code>int avcodec_encode_video2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:592</i>
+	 */
+	public static int avcodec_encode_video2(Pointer<AVCodecContext > avctx, Pointer<AVPacket > avpkt, Pointer<AVFrame > frame, Pointer<Integer > got_packet_ptr) {
+		return avcodec_encode_video2(Pointer.getPeer(avctx), Pointer.getPeer(avpkt), Pointer.getPeer(frame), Pointer.getPeer(got_packet_ptr));
+	}
+	protected native static int avcodec_encode_video2(@Ptr long avctx, @Ptr long avpkt, @Ptr long frame, @Ptr long got_packet_ptr);
+	/**
+	 * Setup the picture fields based on the specified image parameters<br>
+	 * and the provided image data buffer.<br>
+	 * * The picture fields are filled in by using the image data buffer<br>
+	 * pointed to by ptr.<br>
+	 * * If ptr is NULL, the function will fill only the picture linesize<br>
+	 * array and return the required size for the image buffer.<br>
+	 * * To allocate an image buffer and fill the picture data in one call,<br>
+	 * use avpicture_alloc().<br>
+	 * * @param picture       the picture to be filled in<br>
+	 * @param ptr           buffer where the image data is stored, or NULL<br>
+	 * @param pix_fmt       the pixel format of the image<br>
+	 * @param width         the width of the image in pixels<br>
+	 * @param height        the height of the image in pixels<br>
+	 * @return the size in bytes required for src, a negative error code<br>
+	 * in case of failure<br>
+	 * * @see av_image_fill_arrays()<br>
+	 * Original signature : <code>int avpicture_fill(AVPicture*, const uint8_t*, AVPixelFormat, int, int)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:612</i>
+	 */
+	public static int avpicture_fill(Pointer<AvcodecLibrary.AVPicture > picture, Pointer<Byte > ptr, IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
+		return avpicture_fill(Pointer.getPeer(picture), Pointer.getPeer(ptr), (int)pix_fmt.value(), width, height);
+	}
+	protected native static int avpicture_fill(@Ptr long picture, @Ptr long ptr, int pix_fmt, int width, int height);
+	/**
+	 * Calculate the size in bytes that a picture of the given width and height<br>
+	 * would occupy if stored in the given picture format.<br>
+	 * * @param pix_fmt    picture pixel format<br>
+	 * @param width      picture width<br>
+	 * @param height     picture height<br>
+	 * @return the computed picture buffer size or a negative error code<br>
+	 * in case of error<br>
+	 * * @see av_image_get_buffer_size().<br>
+	 * Original signature : <code>int avpicture_get_size(AVPixelFormat, int, int)</code><br>
+	 * <i>native declaration : ./libavcodec/avcodec.h:624</i>
+	 */
+	public static int avpicture_get_size(IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
+		return avpicture_get_size((int)pix_fmt.value(), width, height);
+	}
+	protected native static int avpicture_get_size(int pix_fmt, int width, int height);
+	/** Undefined type */
+	public static interface AVPicture {
+		
+	};
+}
diff -pruN generated/org/ffmpeg/avformat/AvformatLibrary.java src/org/ffmpeg/avformat/AvformatLibrary.java
--- generated/org/ffmpeg/avformat/AvformatLibrary.java	2014-11-29 21:26:02.060482380 +0100
+++ src/org/ffmpeg/avformat/AvformatLibrary.java	2014-11-29 21:26:10.182464069 +0100
@@ -352,11 +352,11 @@ public class AvformatLibrary {
 	 * Original signature : <code>AVFormatContext* avformat_alloc_context()</code><br>
 	 * <i>native declaration : libavformat/avformat.h:706</i>
 	 */
-	public static Pointer<AVFormatContext > avformat_alloc_context() {
-		return Pointer.pointerToAddress(avformat_alloc_context$2(), AVFormatContext.class);
+	public static Pointer<AVFormatContext > alloc_context() {
+		return Pointer.pointerToAddress(avformat_alloc_context(), AVFormatContext.class);
 	}
 	@Ptr 
-	protected native static long avformat_alloc_context$2();
+	protected native static long avformat_alloc_context();
 	/**
 	 * Free an AVFormatContext and all its streams.<br>
 	 * @param s context to free<br>
diff -pruN generated/org/ffmpeg/avutil/AVUtil.java src/org/ffmpeg/avutil/AVUtil.java
--- generated/org/ffmpeg/avutil/AVUtil.java	1970-01-01 01:00:00.000000000 +0100
+++ src/org/ffmpeg/avutil/AVUtil.java	2014-11-29 21:26:10.182464069 +0100
@@ -0,0 +1,44 @@
+package org.ffmpeg.avutil;
+
+public class AVUtil {
+	public static final long AV_NOPTS_VALUE = Long.MIN_VALUE;
+
+	/** Inline-Funktion rational.h */
+	public static double av_q2d(AVRational a) {
+               return a.num() / (double) a.den();
+       }
+
+	public static String av_ts_make_string(long ts) {
+               if (ts == AV_NOPTS_VALUE)
+                       return "NOPTS";
+               else
+                       return Long.toHexString(ts);
+       }
+
+	/**
+	 * Original signaturre : #define av_ts2str(ts)
+	 * av_ts_make_string((char[AV_TS_MAX_STRING_SIZE]){0}, ts)
+	 */
+	public static String av_ts2str(long ts) {
+               return av_ts_make_string(ts);
+       }
+
+	public static String av_ts_make_time_string(long ts,
+                       AVRational tb) {
+               if (ts == AV_NOPTS_VALUE)
+                       return "NOPTS";
+               else {
+                       String s = String.format("%.6g", av_q2d(tb) * ts);
+                       return s;
+               }
+       }
+
+	/**
+	 * Original signature : #define av_ts2timestr(ts, tb)
+	 * av_ts_make_time_string((char[AV_TS_MAX_STRING_SIZE]){0}, ts, tb)
+	 */
+	public static String av_ts2timestr(long ts, AVRational tb) {
+               return av_ts_make_time_string(ts, tb);
+       }
+
+}
diff -pruN generated/org/ffmpeg/avutil/AvutilLibrary.java src/org/ffmpeg/avutil/AvutilLibrary.java
--- generated/org/ffmpeg/avutil/AvutilLibrary.java	2014-11-29 21:26:00.060486889 +0100
+++ src/org/ffmpeg/avutil/AvutilLibrary.java	2014-11-29 21:26:10.183464066 +0100
@@ -1043,11 +1043,11 @@ public class AvutilLibrary {
 	 * Original signature : <code>void* av_malloc(size_t)</code><br>
 	 * <i>native declaration : libavutil/mem.h:9</i>
 	 */
-	public static Pointer<? > av_malloc(@CLong long size) {
-		return Pointer.pointerToAddress(av_malloc$2(size));
+	public static Pointer<? > malloc(@CLong long size) {
+		return Pointer.pointerToAddress(av_malloc(size));
 	}
 	@Ptr 
-	protected native static long av_malloc$2(@CLong long size);
+	protected native static long av_malloc(@CLong long size);
 	/**
 	 * Free a memory block which has been allocated with av_malloc(z)() or<br>
 	 * av_realloc().<br>
diff -pruN generated/org/ffmpeg/FFMPeg.java src/org/ffmpeg/FFMPeg.java
--- generated/org/ffmpeg/FFMPeg.java	1970-01-01 01:00:00.000000000 +0100
+++ src/org/ffmpeg/FFMPeg.java	2014-11-29 21:26:10.185464062 +0100
@@ -0,0 +1,27 @@
+package org.ffmpeg;
+
+import org.ffmpeg.avcodec.AvcodecLibrary;
+import org.ffmpeg.avformat.AvformatLibrary;
+import org.ffmpeg.avutil.AvutilLibrary;
+import org.ffmpeg.swscale.SwscaleLibrary;
+
+public class FFMPeg {
+
+	public static void main(String[] args) {
+		System.out.println("Java-Bibliothek ffmpeg.jar");
+		System.out.println("==========================");
+		System.out.println("Die Bibliothek ffmpeg ist nur in den Bruchteilen implementiert, die fr\n"
+				+ "Open Source Physics tracker bentigt werden.");
+		System.out.println("ffmpeg in Version "+AvutilLibrary.FFMPEG_VERSION);
+		System.out.println("Bestandteile:");
+		System.out.println("avutil in Version "+AvutilLibrary.avutil_version());
+		System.out.println("avcodec in Version "+AvcodecLibrary.avcodec_version());
+		System.out.println("avformat in Version "+AvformatLibrary.avformat_version());
+		System.out.println("swscale in Version "+SwscaleLibrary.swscale_version());
+	}
+	
+	public static String getVersion() {
+		return AvutilLibrary.FFMPEG_VERSION;
+	}
+	
+}
diff -pruN generated/org/ffmpeg/swscale/SwscaleLibrary.java src/org/ffmpeg/swscale/SwscaleLibrary.java
--- generated/org/ffmpeg/swscale/SwscaleLibrary.java	2014-11-29 21:25:59.451488263 +0100
+++ src/org/ffmpeg/swscale/SwscaleLibrary.java	2014-11-29 21:26:10.186464060 +0100
@@ -127,20 +127,20 @@ public class SwscaleLibrary {
 	 * Original signature : <code>char* swscale_configuration()</code><br>
 	 * <i>native declaration : libswscale/swscale.h:3</i>
 	 */
-	public static Pointer<Byte > swscale_configuration() {
-		return Pointer.pointerToAddress(swscale_configuration$2(), Byte.class);
+	public static Pointer<Byte > swscale__configuration() {
+		return Pointer.pointerToAddress(swscale_configuration(), Byte.class);
 	}
 	@Ptr 
-	protected native static long swscale_configuration$2();
+	protected native static long swscale_configuration();
 	/**
 	 * Original signature : <code>char* swscale_license()</code><br>
 	 * <i>native declaration : libswscale/swscale.h:5</i>
 	 */
-	public static Pointer<Byte > swscale_license() {
-		return Pointer.pointerToAddress(swscale_license$2(), Byte.class);
+	public static Pointer<Byte > swscale__license() {
+		return Pointer.pointerToAddress(swscale_license(), Byte.class);
 	}
 	@Ptr 
-	protected native static long swscale_license$2();
+	protected native static long swscale_license();
 	/**
 	 * Original signature : <code>void sws_freeContext(SwsContext*)</code><br>
 	 * <i>native declaration : libswscale/swscale.h:8</i>
diff -pruN generated/test/AVInfo.java src/test/AVInfo.java
--- generated/test/AVInfo.java	1970-01-01 01:00:00.000000000 +0100
+++ src/test/AVInfo.java	2014-11-29 21:26:10.186464060 +0100
@@ -0,0 +1,64 @@
+package test;
+
+import static org.ffmpeg.avformat.AvformatLibrary.av_dump_format;
+import static org.ffmpeg.avformat.AvformatLibrary.av_register_all;
+import static org.ffmpeg.avformat.AvformatLibrary.avformat_close_input;
+import static org.ffmpeg.avformat.AvformatLibrary.avformat_open_input;
+
+import java.io.IOException;
+
+import org.bridj.Pointer;
+import org.ffmpeg.avformat.AVFormatContext;
+import org.ffmpeg.avformat.AVStream;
+
+public class AVInfo {
+	public static String src_filename;
+	public static Pointer<AVFormatContext> fmt_ctx;
+	public static Pointer<AVStream> stream;
+	
+	public static void main(String[] args) {
+		int ret = 0;
+
+		if (args.length != 1) {
+			System.err.printf("usage: AVInfo input_file \n"
+					+ "API example program to show input file infos.\n" + "\n");
+			System.exit(1);
+		}
+		src_filename = args[0];
+		try {
+			/* register all formats and codecs */
+			av_register_all();
+
+			/* open input file, and allocate format context */
+			Pointer<Pointer<AVFormatContext>> pfmt_ctx = Pointer
+					.allocatePointer(AVFormatContext.class);
+			if (avformat_open_input(pfmt_ctx,
+					Pointer.pointerToCString(src_filename), null, null) < 0) {
+				System.err.printf("Could not open source file %s\n",
+						src_filename);
+				System.exit(1);
+			}
+
+			fmt_ctx = pfmt_ctx.get();
+			/* dump input information to stderr */
+			av_dump_format(fmt_ctx, 0, Pointer.pointerToCString(src_filename), 0);
+
+			int streams = fmt_ctx.get().nb_streams();
+			for(int index = 0;index<streams;index++){
+				stream = fmt_ctx.get().streams().get(index);
+				
+			}
+			// } catch (IOException e) {
+			// e.printStackTrace();
+			// System.exit(1);
+		} finally {
+			System.err.print("freeing fmt_ctx...");
+			if (fmt_ctx != null) {
+				avformat_close_input(fmt_ctx.getReference());
+			}
+			System.err.println("freed");
+			System.exit(ret);
+		}
+	}
+
+}
diff -pruN generated/test/Demuxing.java src/test/Demuxing.java
--- generated/test/Demuxing.java	1970-01-01 01:00:00.000000000 +0100
+++ src/test/Demuxing.java	2014-11-29 21:26:10.187464057 +0100
@@ -0,0 +1,384 @@
+package test;
+
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+
+import org.bridj.IntValuedEnum;
+import org.bridj.Pointer;
+import org.ffmpeg.avcodec.AVCodec;
+import org.ffmpeg.avcodec.AVCodecContext;
+import org.ffmpeg.avcodec.AvcodecLibrary;
+import org.ffmpeg.avcodec.AVPacket;
+import org.ffmpeg.avformat.AVFormatContext;
+import org.ffmpeg.avformat.AVStream;
+import org.ffmpeg.avformat.AvformatLibrary;
+import org.ffmpeg.avutil.AVFrame;
+import org.ffmpeg.avutil.AvutilLibrary;
+import org.ffmpeg.avutil.AvutilLibrary.AVMediaType;
+import org.ffmpeg.avutil.AvutilLibrary.AVSampleFormat;
+
+import static org.ffmpeg.avcodec.AvcodecLibrary.*;
+import static org.ffmpeg.avutil.AvutilLibrary.*;
+import static org.ffmpeg.avformat.AvformatLibrary.*;
+import static org.ffmpeg.avutil.AVUtil.*;
+import static org.ffmpeg.avutil.AvutilLibrary.AVSampleFormat.*;
+
+/**
+ * @file libavformat demuxing API use example.
+ * 
+ *       Show how to use the libavformat and libavcodec API to demux and decode
+ *       audio and video data.
+ * @example doc/examples/demuxing.c
+ */
+
+public class Demuxing {
+	static Pointer<AVFormatContext> fmt_ctx = null;
+	static Pointer<AVCodecContext> video_dec_ctx = null, audio_dec_ctx;
+	static Pointer<AVStream> video_stream = null, audio_stream = null;
+	static Pointer<Byte> streamptr = null; 
+	static String src_filename = null;
+	static String video_dst_filename = null;
+	static String audio_dst_filename = null;
+	static FileOutputStream video_dst_file = null;
+	static FileOutputStream audio_dst_file = null;
+
+	static Pointer<Pointer<Byte>> video_dst_data = Pointer.allocatePointers(Byte.class, 4);
+	static Pointer<Integer> video_dst_linesize = Pointer.allocateInts(4);
+	static int video_dst_bufsize;
+
+	static Pointer<Integer> video_stream_idx = Pointer.allocateInt(), 
+			audio_stream_idx = Pointer.allocateInt();
+	static Pointer<AVFrame> frame = null;
+	static Pointer<AVPacket> pkt = null;
+	static int video_frame_count = 0;
+	static int audio_frame_count = 0;
+	static AvformatLibrary lavf = new AvformatLibrary();
+	static AvcodecLibrary lavc = new AvcodecLibrary();
+	static AvutilLibrary lavu = new AvutilLibrary();
+
+	static int decode_packet(Pointer<Integer> got_frame, int cached)
+			throws IOException {
+		int ret = 0;
+		int decoded = pkt.get().size();
+		got_frame.setInt(0);
+
+		if (pkt.get().stream_index() == video_stream_idx.get()) {
+			/* decode video frame */
+			ret = avcodec_decode_video2(video_dec_ctx, frame, got_frame,
+					pkt);
+			if (ret < 0) {
+				System.err.printf("Error decoding video frame\n");
+				return ret;
+			}
+
+			if (got_frame.get() != 0) {
+				System.out.printf("video_frame%s n:%d coded_n:%d pts:%s\n",
+						cached != 0 ? "(cached)" : "", video_frame_count++,
+						frame.get().coded_picture_number(), av_ts2timestr(
+								frame.get().pts(), video_dec_ctx.get().time_base()));
+
+				/*
+				 * copy decoded frame to destination buffer: this is required
+				 * since rawvideo expects non aligned data
+				 */
+				av_image_copy(video_dst_data, video_dst_linesize,
+						frame.get().data(), frame.get().linesize(), video_dec_ctx.get().pix_fmt(),
+						video_dec_ctx.get().width(), video_dec_ctx.get().height());
+
+				/* write to rawvideo file */
+				streamptr = video_dst_data.get();
+				video_dst_file.write(streamptr.getBytes(video_dst_bufsize));
+			}
+		} else if (pkt.get().stream_index() == audio_stream_idx.get()) {
+			/* decode audio frame */
+			ret = avcodec_decode_audio4(audio_dec_ctx, frame, got_frame,
+					pkt);
+			if (ret < 0) {
+				System.err.printf("Error decoding audio frame\n");
+				return ret;
+			}
+			/*
+			 * Some audio decoders decode only part of the packet, and have to
+			 * be called again with the remainder of the packet data. Sample:
+			 * fate-suite/lossless-audio/luckynight-partial.shn Also, some
+			 * decoders might over-read the packet.
+			 */
+			decoded = Math.min(ret, pkt.get().size());
+
+			if (got_frame.get() != 0) {
+				int unpadded_linesize = frame.get().nb_samples()
+						* av_get_bytes_per_sample(AVSampleFormat.fromValue(frame.get().format()));
+				System.out.printf("audio_frame%s n:%d nb_samples:%d pts:%s\n",
+						cached != 0 ? "(cached)" : "", audio_frame_count++,
+						frame.get().nb_samples(), av_ts2timestr(frame.get().pts(),
+								audio_dec_ctx.get().time_base()));
+
+				/*
+				 * Write the raw audio data samples of the first plane. This
+				 * works fine for packed formats (e.g. AV_SAMPLE_FMT_S16).
+				 * However, most audio decoders output planar audio, which uses
+				 * a separate plane of audio samples for each channel (e.g.
+				 * AV_SAMPLE_FMT_S16P). In other words, this code will write
+				 * only the first audio channel in these cases. You should use
+				 * libswresample or libavfilter to convert the frame to packed
+				 * data.
+				 */
+				streamptr = frame.get().extended_data().get();
+				audio_dst_file.write(streamptr.getBytes(unpadded_linesize));
+			}
+		}
+
+		return decoded;
+	}
+
+	static int open_codec_context(Pointer<Integer> stream_idx,
+			Pointer<AVFormatContext> fmt_ctx, AVMediaType type) {
+		int ret;
+		Pointer<AVStream> st;
+		Pointer<AVCodecContext> dec_ctx = null;
+		Pointer<AVCodec> dec = null;
+
+		ret = av_find_best_stream(fmt_ctx, type, -1, -1, null, 0);
+		if (ret < 0) {
+			System.err.printf("Could not find %s stream in input file '%s'\n",
+					av_get_media_type_string(type).getCString(), src_filename);
+			return ret;
+		} else {
+			stream_idx.set(ret);
+			st = fmt_ctx.get().streams().get(stream_idx.get());
+
+			/* find decoder for the stream */
+			dec_ctx = st.get().codec();
+			dec = avcodec_find_decoder(dec_ctx.get().codec_id());
+			if (dec == null) {
+				System.err.printf("Failed to find %s codec\n",
+						av_get_media_type_string(type));
+				return ret;
+			}
+
+			if ((ret = avcodec_open2(dec_ctx, dec, null)) < 0) {
+				System.err.printf("Failed to open %s codec\n",
+						av_get_media_type_string(type));
+				return ret;
+			}
+		}
+
+		return 0;
+	}
+
+	static String get_format_from_sample_fmt(IntValuedEnum<AVSampleFormat> sample_fmt) {
+		if(sample_fmt.value() == AV_SAMPLE_FMT_U8.value())
+			return "u8";
+		else if(sample_fmt.value() == AV_SAMPLE_FMT_S16.value())
+			return "s16le";
+		else if(sample_fmt.value() == AV_SAMPLE_FMT_S32.value())
+			return "s32le";
+		else if(sample_fmt.value() == AV_SAMPLE_FMT_FLT.value())
+			return "f32le";
+		else if(sample_fmt.value() == AV_SAMPLE_FMT_DBL.value())
+			return "f64le";
+		System.err.printf(
+				"sample format %s is not supported as output format\n",
+				av_get_sample_fmt_name(sample_fmt));
+		return null;
+	}
+
+	public static void main(String[] args) throws IOException {
+		int ret = 0;
+		Pointer<Integer> got_frame = Pointer.allocateInt();
+		got_frame.set(0);
+		video_stream_idx.set(-1);
+		audio_stream_idx.set(-1);
+		if (args.length != 3) {
+			System.err
+					.printf("usage: Demuxing input_file video_output_file audio_output_file\n"
+							+ "API example program to show how to read frames from an input file.\n"
+							+ "This program reads frames from a file, decodes them, and writes decoded\n"
+							+ "video frames to a rawvideo file named video_output_file, and decoded\n"
+							+ "audio frames to a rawaudio file named audio_output_file.\n"
+							+ "\n");
+			System.exit(1);
+		}
+		src_filename = args[0];
+		video_dst_filename = args[1];
+		audio_dst_filename = args[2];
+
+		try {
+			/* register all formats and codecs */
+			av_register_all();
+
+			/* open input file, and allocate format context */
+			Pointer<Pointer<AVFormatContext>> pfmt_ctx = Pointer.allocatePointer(AVFormatContext.class);
+			if (avformat_open_input(pfmt_ctx, Pointer.pointerToCString(src_filename), null, null) < 0) {
+				System.err.printf("Could not open source file %s\n",
+						src_filename);
+				System.exit(1);
+			}
+
+			fmt_ctx = pfmt_ctx.get();
+			/* retrieve stream information */
+			if (avformat_find_stream_info(fmt_ctx, null) < 0) {
+				System.err.printf("Could not find stream information\n");
+				System.exit(1);
+			}
+			
+			if (open_codec_context(video_stream_idx, fmt_ctx,
+					AVMediaType.AVMEDIA_TYPE_VIDEO) >= 0) {
+				video_stream = fmt_ctx.get().streams().get(video_stream_idx.get());
+				video_dec_ctx = video_stream.get().codec();
+
+				try {
+					video_dst_file = new FileOutputStream(video_dst_filename);
+				} catch (IOException e) {
+					System.err.printf("Could not open destination file %s\n",
+							video_dst_filename);
+					ret = 1;
+					System.exit(1);
+				}
+
+				/* allocate image where the decoded image will be put */
+				ret = av_image_alloc(video_dst_data, video_dst_linesize,
+						video_dec_ctx.get().width(), video_dec_ctx.get().height(),
+						video_dec_ctx.get().pix_fmt(), 1);
+				if (ret < 0) {
+					System.err.printf("Could not allocate raw video buffer\n");
+					System.exit(ret);
+				}
+				video_dst_bufsize = ret;
+			}
+
+			if (open_codec_context(audio_stream_idx, fmt_ctx,
+					AVMediaType.AVMEDIA_TYPE_AUDIO) >= 0) {
+				audio_stream = fmt_ctx.get().streams().get(audio_stream_idx.get());
+				audio_dec_ctx = audio_stream.get().codec();
+				try {
+					audio_dst_file = new FileOutputStream(audio_dst_filename);
+				} catch (IOException e) {
+					System.err.printf("Could not open destination file %s\n",
+							video_dst_filename);
+					System.exit(1);
+				}
+			}
+
+			/* dump input information to stderr */
+			av_dump_format(fmt_ctx, 0, Pointer.pointerToCString(src_filename), 0);
+
+			if (audio_stream == null && video_stream == null) {
+				System.err
+						.printf("Could not find audio or video stream in the input, aborting\n");
+				System.exit(1);
+			}
+
+			frame = alloc_frame();
+			if (frame == null) {
+				System.err.printf("Could not allocate frame\n");
+				System.exit(1);
+			}
+
+			/* initialize packet, set data to null, let the demuxer fill it */
+			pkt = Pointer.allocate(AVPacket.class);
+			av_init_packet(pkt);
+			pkt.get().data(null);
+			pkt.get().size(0);
+
+			if (video_stream != null)
+				System.out.printf("Demuxing video from file '%s' into '%s'\n",
+						src_filename, video_dst_filename);
+			if (audio_stream != null)
+				System.out.printf("Demuxing audio from file '%s' into '%s'\n",
+						src_filename, audio_dst_filename);
+
+			/* read frames from the file */
+			while (av_read_frame(fmt_ctx, pkt) >= 0) {
+				Pointer<AVPacket> orig_pkt = pkt;
+				do {
+					ret = decode_packet(got_frame, 0);
+					if (ret < 0)
+						break;
+					long ptr = pkt.get().data().getPeer();
+					ptr+=ret;
+					pkt.get().data((Pointer<Byte>)Pointer.pointerToAddress(ptr));
+					pkt.get().size(pkt.get().size()-ret);
+				} while (pkt.get().size() > 0);
+				av_free_packet(orig_pkt);
+			}
+
+			/* flush cached frames */
+			pkt.get().data(null);
+			pkt.get().size(0);
+			do {
+				got_frame.set(0);
+				decode_packet(got_frame, 1);
+			} while (got_frame.get() != 0);
+
+			System.out.printf("Demuxing succeeded.\n");
+
+			if (video_stream != null) {
+				System.out
+						.printf("Play the output video file with the command:\n"
+								+ "ffplay -f rawvideo -pix_fmt %s -video_size %dx%d %s\n",
+								av_get_pix_fmt_name(video_dec_ctx.get().pix_fmt()).getCString(),
+								video_dec_ctx.get().width(), video_dec_ctx.get().height(),
+								video_dst_filename);
+			}
+
+			if (audio_stream != null) {
+				IntValuedEnum<AVSampleFormat> sfmt = audio_dec_ctx.get().sample_fmt();
+				int n_channels = audio_dec_ctx.get().channels();
+				String fmt;
+
+				if (av_sample_fmt_is_planar(sfmt) != 0) {
+					String packed = av_get_sample_fmt_name(sfmt).getCString();
+					System.out
+							.printf("Warning: the sample format the decoder produced is planar "
+									+ "(%s). This example will output the first channel only.\n",
+									packed != null ? packed : "?");
+					sfmt = av_get_packed_sample_fmt(sfmt);
+					n_channels = 1;
+				}
+
+				if ((fmt = get_format_from_sample_fmt(sfmt)) == null)
+					System.exit(-1);
+				ret = 0;
+				System.out.printf(
+						"Play the output audio file with the command:\n"
+								+ "ffplay -f %s -ac %d -ar %d %s\n", fmt,
+						n_channels, audio_dec_ctx.get().sample_rate(),
+						audio_dst_filename);
+			}
+
+		} catch (IOException e) {
+			e.printStackTrace();
+			System.exit(1);
+		} finally {
+			System.err.print("freeing video_dec_ctx..");
+			if (video_dec_ctx != null)
+				avcodec_close(video_dec_ctx);
+			System.err.println("freed");
+			System.err.print("freeing audio_dec_ctx...");
+			if (audio_dec_ctx != null)
+				avcodec_close(audio_dec_ctx);
+			System.err.println("freed");
+			System.err.print("freeing fmt_ctx...");
+			if(fmt_ctx != null) {
+				avformat_close_input(fmt_ctx.getReference());
+			}
+			System.err.println("freed");
+			if (video_dst_file != null)
+				video_dst_file.close();
+			if (audio_dst_file != null)
+				audio_dst_file.close();
+			System.err.print("freeing frame...");
+			if(frame != null)
+				av_free(frame);
+			System.err.println("freed");
+			System.err.print("freeing video_dst_data...");
+			if(video_dst_data != null && video_dst_data.getValidElements() > 0)
+				av_freep(video_dst_data);
+			System.err.println("freed");
+		}
+		System.exit(ret);
+	}
+}
